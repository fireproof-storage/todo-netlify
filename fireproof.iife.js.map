{
  "version": 3,
  "sources": ["../../../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/encode.js", "../../../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/decode.js", "../../../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/length.js", "../../../../node_modules/.pnpm/varint@6.0.0/node_modules/varint/index.js", "../../../../node_modules/.pnpm/charwise@3.0.1/node_modules/charwise/codec/number.js", "../../../../node_modules/.pnpm/charwise@3.0.1/node_modules/charwise/codec/object.js", "../../../../node_modules/.pnpm/charwise@3.0.1/node_modules/charwise/index.js", "../../../../node_modules/.pnpm/@protobufjs+aspromise@1.1.2/node_modules/@protobufjs/aspromise/index.js", "../../../../node_modules/.pnpm/@protobufjs+base64@1.1.2/node_modules/@protobufjs/base64/index.js", "../../../../node_modules/.pnpm/@protobufjs+eventemitter@1.1.0/node_modules/@protobufjs/eventemitter/index.js", "../../../../node_modules/.pnpm/@protobufjs+float@1.0.2/node_modules/@protobufjs/float/index.js", "../../../../node_modules/.pnpm/@protobufjs+inquire@1.1.0/node_modules/@protobufjs/inquire/index.js", "../../../../node_modules/.pnpm/@protobufjs+utf8@1.1.0/node_modules/@protobufjs/utf8/index.js", "../../../../node_modules/.pnpm/@protobufjs+pool@1.1.0/node_modules/@protobufjs/pool/index.js", "../../../../node_modules/.pnpm/protobufjs@7.2.2/node_modules/protobufjs/src/util/longbits.js", "../../../../node_modules/.pnpm/protobufjs@7.2.2/node_modules/protobufjs/src/util/minimal.js", "../../../../node_modules/.pnpm/protobufjs@7.2.2/node_modules/protobufjs/src/writer.js", "../../../../node_modules/.pnpm/protobufjs@7.2.2/node_modules/protobufjs/src/writer_buffer.js", "../../../../node_modules/.pnpm/protobufjs@7.2.2/node_modules/protobufjs/src/reader.js", "../../../../node_modules/.pnpm/protobufjs@7.2.2/node_modules/protobufjs/src/reader_buffer.js", "../../../../node_modules/.pnpm/protobufjs@7.2.2/node_modules/protobufjs/src/rpc/service.js", "../../../../node_modules/.pnpm/protobufjs@7.2.2/node_modules/protobufjs/src/rpc.js", "../../../../node_modules/.pnpm/protobufjs@7.2.2/node_modules/protobufjs/src/roots.js", "../../../../node_modules/.pnpm/protobufjs@7.2.2/node_modules/protobufjs/src/index-minimal.js", "../../../../node_modules/.pnpm/protobufjs@7.2.2/node_modules/protobufjs/minimal.js", "../../../../node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js", "../../../../node_modules/.pnpm/murmurhash3js-revisited@3.0.0/node_modules/murmurhash3js-revisited/index.js", "../../../../node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js", "../../../../node_modules/.pnpm/sparse-array@1.3.2/node_modules/sparse-array/index.js", "../../../../node_modules/.pnpm/eventemitter3@4.0.7/node_modules/eventemitter3/index.js", "../../src/fireproof.ts", "../../../../node_modules/.pnpm/uuidv7@0.6.2/node_modules/uuidv7/dist/index.js", "../../src/write-queue.ts", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/vendor/varint.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/varint.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bytes.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/hashes/digest.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base58.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/vendor/base-x.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base32.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/cid.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/link.js", "../../../../node_modules/.pnpm/@alanshaw+pail@0.3.3/node_modules/@alanshaw/pail/src/block.js", "../../../../node_modules/.pnpm/yocto-queue@1.0.0/node_modules/yocto-queue/index.js", "../../../../node_modules/.pnpm/p-limit@4.0.0/node_modules/p-limit/index.js", "../../../../node_modules/.pnpm/@ipld+dag-cbor@9.0.4/node_modules/@ipld/dag-cbor/src/index.js", "../../../../node_modules/.pnpm/cborg@2.0.4/node_modules/cborg/esm/lib/is.js", "../../../../node_modules/.pnpm/cborg@2.0.4/node_modules/cborg/esm/lib/token.js", "../../../../node_modules/.pnpm/cborg@2.0.4/node_modules/cborg/esm/lib/byte-utils.js", "../../../../node_modules/.pnpm/cborg@2.0.4/node_modules/cborg/esm/lib/bl.js", "../../../../node_modules/.pnpm/cborg@2.0.4/node_modules/cborg/esm/lib/common.js", "../../../../node_modules/.pnpm/cborg@2.0.4/node_modules/cborg/esm/lib/0uint.js", "../../../../node_modules/.pnpm/cborg@2.0.4/node_modules/cborg/esm/lib/1negint.js", "../../../../node_modules/.pnpm/cborg@2.0.4/node_modules/cborg/esm/lib/2bytes.js", "../../../../node_modules/.pnpm/cborg@2.0.4/node_modules/cborg/esm/lib/3string.js", "../../../../node_modules/.pnpm/cborg@2.0.4/node_modules/cborg/esm/lib/4array.js", "../../../../node_modules/.pnpm/cborg@2.0.4/node_modules/cborg/esm/lib/5map.js", "../../../../node_modules/.pnpm/cborg@2.0.4/node_modules/cborg/esm/lib/6tag.js", "../../../../node_modules/.pnpm/cborg@2.0.4/node_modules/cborg/esm/lib/7float.js", "../../../../node_modules/.pnpm/cborg@2.0.4/node_modules/cborg/esm/lib/jump.js", "../../../../node_modules/.pnpm/cborg@2.0.4/node_modules/cborg/esm/lib/encode.js", "../../../../node_modules/.pnpm/cborg@2.0.4/node_modules/cborg/esm/lib/decode.js", "../../../../node_modules/.pnpm/multiformats@12.0.1/node_modules/multiformats/vendor/varint.js", "../../../../node_modules/.pnpm/multiformats@12.0.1/node_modules/multiformats/src/varint.js", "../../../../node_modules/.pnpm/multiformats@12.0.1/node_modules/multiformats/src/bytes.js", "../../../../node_modules/.pnpm/multiformats@12.0.1/node_modules/multiformats/src/hashes/digest.js", "../../../../node_modules/.pnpm/multiformats@12.0.1/node_modules/multiformats/vendor/base-x.js", "../../../../node_modules/.pnpm/multiformats@12.0.1/node_modules/multiformats/src/bases/base.js", "../../../../node_modules/.pnpm/multiformats@12.0.1/node_modules/multiformats/src/bases/base58.js", "../../../../node_modules/.pnpm/multiformats@12.0.1/node_modules/multiformats/src/bases/base32.js", "../../../../node_modules/.pnpm/multiformats@12.0.1/node_modules/multiformats/src/cid.js", "../../../../node_modules/.pnpm/@ipld+car@5.2.0/node_modules/@ipld/car/src/header-validator.js", "../../../../node_modules/.pnpm/@ipld+car@5.2.0/node_modules/@ipld/car/src/decoder-common.js", "../../../../node_modules/.pnpm/@ipld+car@5.2.0/node_modules/@ipld/car/src/decoder.js", "../../../../node_modules/.pnpm/@ipld+car@5.2.0/node_modules/@ipld/car/src/reader-browser.js", "../../../../node_modules/.pnpm/@ipld+car@5.2.0/node_modules/@ipld/car/src/indexer.js", "../../../../node_modules/.pnpm/@ipld+car@5.2.0/node_modules/@ipld/car/src/iterator.js", "../../../../node_modules/.pnpm/@ipld+car@5.2.0/node_modules/@ipld/car/src/encoder.js", "../../../../node_modules/.pnpm/@ipld+car@5.2.0/node_modules/@ipld/car/src/writer-browser.js", "../../../../node_modules/.pnpm/@ipld+car@5.2.0/node_modules/@ipld/car/src/buffer-writer.js", "../../../../node_modules/.pnpm/cborg@1.10.0/node_modules/cborg/esm/lib/is.js", "../../../../node_modules/.pnpm/cborg@1.10.0/node_modules/cborg/esm/lib/token.js", "../../../../node_modules/.pnpm/cborg@1.10.0/node_modules/cborg/esm/lib/byte-utils.js", "../../../../node_modules/.pnpm/cborg@1.10.0/node_modules/cborg/esm/lib/bl.js", "../../../../node_modules/.pnpm/cborg@1.10.0/node_modules/cborg/esm/lib/common.js", "../../../../node_modules/.pnpm/cborg@1.10.0/node_modules/cborg/esm/lib/0uint.js", "../../../../node_modules/.pnpm/cborg@1.10.0/node_modules/cborg/esm/lib/1negint.js", "../../../../node_modules/.pnpm/cborg@1.10.0/node_modules/cborg/esm/lib/2bytes.js", "../../../../node_modules/.pnpm/cborg@1.10.0/node_modules/cborg/esm/lib/3string.js", "../../../../node_modules/.pnpm/cborg@1.10.0/node_modules/cborg/esm/lib/4array.js", "../../../../node_modules/.pnpm/cborg@1.10.0/node_modules/cborg/esm/lib/5map.js", "../../../../node_modules/.pnpm/cborg@1.10.0/node_modules/cborg/esm/lib/6tag.js", "../../../../node_modules/.pnpm/cborg@1.10.0/node_modules/cborg/esm/lib/7float.js", "../../../../node_modules/.pnpm/cborg@1.10.0/node_modules/cborg/esm/lib/jump.js", "../../../../node_modules/.pnpm/cborg@1.10.0/node_modules/cborg/esm/lib/encode.js", "../../../../node_modules/.pnpm/cborg@1.10.0/node_modules/cborg/esm/lib/decode.js", "../../../../node_modules/.pnpm/cborg@1.10.0/node_modules/cborg/esm/lib/length.js", "../../../../node_modules/.pnpm/multiformats@12.0.1/node_modules/multiformats/src/hashes/hasher.js", "../../../../node_modules/.pnpm/multiformats@12.0.1/node_modules/multiformats/src/block.js", "../../../../node_modules/.pnpm/multiformats@12.0.1/node_modules/multiformats/src/hashes/sha2-browser.js", "../../../../node_modules/.pnpm/multiformats@12.0.1/node_modules/multiformats/src/codecs/raw.js", "../../src/loader-helpers.ts", "../../src/encrypted-block.ts", "../../src/crypto-web.ts", "../../../../node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/utils.js", "../../../../node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/base.js", "../../../../node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/cid-set.js", "../../src/crypto-ipld.ts", "../../../../node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/cache.js", "../../src/encrypt-helpers.ts", "../../../../node_modules/.pnpm/cborg@2.0.4/node_modules/cborg/esm/lib/json/encode.js", "../../../../node_modules/.pnpm/cborg@2.0.4/node_modules/cborg/esm/lib/json/decode.js", "../../../../node_modules/.pnpm/multiformats@12.0.1/node_modules/multiformats/src/bases/base64.js", "../../../../node_modules/.pnpm/@ipld+dag-json@10.1.3/node_modules/@ipld/dag-json/src/index.js", "../../../../node_modules/.pnpm/idb@7.1.1/node_modules/idb/build/wrap-idb-value.js", "../../../../node_modules/.pnpm/idb@7.1.1/node_modules/idb/build/index.js", "../../src/version.ts", "../../src/store.ts", "../../src/commit-queue.ts", "../../src/remote-wal.ts", "../../src/store-browser.ts", "../../src/loader.ts", "../../src/indexer-helpers.ts", "../../../../node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/map.js", "../../../../node_modules/.pnpm/prolly-trees@1.0.4/node_modules/prolly-trees/esm/src/db-index.js", "../../src/index.ts", "../../../../node_modules/.pnpm/multiformats@12.0.1/node_modules/multiformats/src/link.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/hashes/hasher.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/block.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/hashes/sha2-browser.js", "../../../../node_modules/.pnpm/@alanshaw+pail@0.3.3/node_modules/@alanshaw/pail/src/clock.js", "../../../../node_modules/.pnpm/@alanshaw+pail@0.3.3/node_modules/@alanshaw/pail/src/shard.js", "../../../../node_modules/.pnpm/@alanshaw+pail@0.3.3/node_modules/@alanshaw/pail/src/index.js", "../../../../node_modules/.pnpm/@alanshaw+pail@0.3.3/node_modules/@alanshaw/pail/src/crdt.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.1.1/node_modules/@ipld/unixfs/src/codec.js", "../../../../node_modules/.pnpm/@ipld+dag-pb@4.0.2/node_modules/@ipld/dag-pb/src/pb-decode.js", "../../../../node_modules/.pnpm/@ipld+dag-pb@4.0.2/node_modules/@ipld/dag-pb/src/pb-encode.js", "../../../../node_modules/.pnpm/@ipld+dag-pb@4.0.2/node_modules/@ipld/dag-pb/src/util.js", "../../../../node_modules/.pnpm/@ipld+dag-pb@4.0.2/node_modules/@ipld/dag-pb/src/index.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.1.1/node_modules/@ipld/unixfs/gen/unixfs.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.1.1/node_modules/@ipld/unixfs/src/unixfs.js", "../../../../node_modules/.pnpm/actor@2.3.1/node_modules/actor/src/lib.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.1.1/node_modules/@ipld/unixfs/src/file/chunker/indexed.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.1.1/node_modules/@ipld/unixfs/src/file/chunker/buffer.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.1.1/node_modules/@ipld/unixfs/src/writer/util.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.1.1/node_modules/@ipld/unixfs/src/file/chunker.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.1.1/node_modules/@ipld/unixfs/src/file/layout/queue.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.1.1/node_modules/@ipld/unixfs/src/file/writer.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.1.1/node_modules/@ipld/unixfs/src/file/chunker/fixed.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.1.1/node_modules/@ipld/unixfs/src/file/layout/balanced.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.1.1/node_modules/@ipld/unixfs/src/file.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.1.1/node_modules/@ipld/unixfs/src/directory.js", "../../../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/bitfield/Uint32.js", "../../../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/bitfield/api.js", "../../../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/Uint32.js", "../../../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/node.js", "../../../../node_modules/.pnpm/@multiformats+murmur3@2.1.5/node_modules/@multiformats/murmur3/src/index.js", "../../../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/Uint8Array.js", "../../../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/bitfield/Uint8Array.js", "../../../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/lib.js", "../../../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/path/InfiniteUint8Array.js", "../../../../node_modules/.pnpm/@perma+map@1.0.3/node_modules/@perma/map/src/unixfs.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.1.1/node_modules/@ipld/unixfs/src/sharded-directory.js", "../../../../node_modules/.pnpm/@ipld+unixfs@2.1.1/node_modules/@ipld/unixfs/src/lib.js", "../../../../node_modules/.pnpm/ipfs-unixfs-exporter@13.1.7/node_modules/ipfs-unixfs-exporter/src/index.ts", "../../../../node_modules/.pnpm/it-last@3.0.3/node_modules/it-last/src/index.ts", "../../../../node_modules/.pnpm/ipfs-unixfs-exporter@13.1.7/node_modules/ipfs-unixfs-exporter/src/resolvers/index.ts", "../../../../node_modules/.pnpm/multiformats@12.0.1/node_modules/multiformats/src/hashes/identity.js", "../../../../node_modules/.pnpm/ipfs-unixfs-exporter@13.1.7/node_modules/ipfs-unixfs-exporter/src/resolvers/dag-cbor.ts", "../../../../node_modules/.pnpm/ipfs-unixfs-exporter@13.1.7/node_modules/ipfs-unixfs-exporter/src/resolvers/identity.ts", "../../../../node_modules/.pnpm/progress-events@1.0.0/node_modules/progress-events/src/index.ts", "../../../../node_modules/.pnpm/ipfs-unixfs-exporter@13.1.7/node_modules/ipfs-unixfs-exporter/src/utils/extract-data-from-block.ts", "../../../../node_modules/.pnpm/ipfs-unixfs-exporter@13.1.7/node_modules/ipfs-unixfs-exporter/src/utils/validate-offset-and-length.ts", "../../../../node_modules/.pnpm/ipfs-unixfs-exporter@13.1.7/node_modules/ipfs-unixfs-exporter/src/resolvers/raw.ts", "../../../../node_modules/.pnpm/ipfs-unixfs-exporter@13.1.7/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/index.ts", "../../../../node_modules/.pnpm/ipfs-unixfs@11.0.2/node_modules/ipfs-unixfs/src/index.ts", "../../../../node_modules/.pnpm/protons-runtime@5.0.2/node_modules/protons-runtime/src/utils.ts", "../../../../node_modules/.pnpm/protons-runtime@5.0.2/node_modules/protons-runtime/src/decode.ts", "../../../../node_modules/.pnpm/protons-runtime@5.0.2/node_modules/protons-runtime/src/encode.ts", "../../../../node_modules/.pnpm/protons-runtime@5.0.2/node_modules/protons-runtime/src/codec.ts", "../../../../node_modules/.pnpm/protons-runtime@5.0.2/node_modules/protons-runtime/src/codecs/enum.ts", "../../../../node_modules/.pnpm/protons-runtime@5.0.2/node_modules/protons-runtime/src/codecs/message.ts", "../../../../node_modules/.pnpm/ipfs-unixfs@11.0.2/node_modules/ipfs-unixfs/src/unixfs.ts", "../../../../node_modules/.pnpm/hamt-sharding@3.0.2/node_modules/hamt-sharding/src/bucket.ts", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/identity.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base2.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base8.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base10.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base16.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base36.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base64.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/bases/base256emoji.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/hashes/identity.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/codecs/json.js", "../../../../node_modules/.pnpm/multiformats@11.0.2/node_modules/multiformats/src/basics.js", "../../../../node_modules/.pnpm/uint8arrays@4.0.3/node_modules/uint8arrays/src/util/as-uint8array.ts", "../../../../node_modules/.pnpm/uint8arrays@4.0.3/node_modules/uint8arrays/src/alloc.ts", "../../../../node_modules/.pnpm/uint8arrays@4.0.3/node_modules/uint8arrays/src/util/bases.ts", "../../../../node_modules/.pnpm/uint8arrays@4.0.3/node_modules/uint8arrays/src/from-string.ts", "../../../../node_modules/.pnpm/hamt-sharding@3.0.2/node_modules/hamt-sharding/src/consumable-buffer.ts", "../../../../node_modules/.pnpm/uint8arrays@4.0.3/node_modules/uint8arrays/src/concat.ts", "../../../../node_modules/.pnpm/hamt-sharding@3.0.2/node_modules/hamt-sharding/src/consumable-hash.ts", "../../../../node_modules/.pnpm/hamt-sharding@3.0.2/node_modules/hamt-sharding/src/index.ts", "../../../../node_modules/.pnpm/ipfs-unixfs-exporter@13.1.7/node_modules/ipfs-unixfs-exporter/src/utils/find-cid-in-shard.ts", "../../../../node_modules/.pnpm/it-peekable@3.0.2/node_modules/it-peekable/src/index.ts", "../../../../node_modules/.pnpm/it-filter@3.0.3/node_modules/it-filter/src/index.ts", "../../../../node_modules/.pnpm/it-map@3.0.4/node_modules/it-map/src/index.ts", "../../../../node_modules/.pnpm/p-defer@4.0.0/node_modules/p-defer/index.js", "../../../../node_modules/.pnpm/it-parallel@3.0.4/node_modules/it-parallel/src/index.ts", "../../../../node_modules/.pnpm/it-pushable@3.2.1/node_modules/it-pushable/src/fifo.ts", "../../../../node_modules/.pnpm/it-pushable@3.2.1/node_modules/it-pushable/src/index.ts", "../../../../node_modules/.pnpm/it-merge@3.0.2/node_modules/it-merge/src/index.ts", "../../../../node_modules/.pnpm/it-pipe@3.0.1/node_modules/it-pipe/src/index.ts", "../../../../node_modules/.pnpm/ipfs-unixfs-exporter@13.1.7/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/directory.ts", "../../../../node_modules/.pnpm/ipfs-unixfs-exporter@13.1.7/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/file.ts", "../../../../node_modules/.pnpm/p-queue@7.3.4/node_modules/p-queue/dist/index.js", "../../../../node_modules/.pnpm/p-timeout@5.1.0/node_modules/p-timeout/index.js", "../../../../node_modules/.pnpm/p-queue@7.3.4/node_modules/p-queue/dist/lower-bound.js", "../../../../node_modules/.pnpm/p-queue@7.3.4/node_modules/p-queue/dist/priority-queue.js", "../../../../node_modules/.pnpm/ipfs-unixfs-exporter@13.1.7/node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/hamt-sharded-directory.ts", "../../src/files.ts", "../../src/crdt-helpers.ts", "../../src/loaders.ts", "../../src/transaction.ts", "../../src/apply-head-queue.ts", "../../src/crdt-clock.ts", "../../src/crdt.ts", "../../src/database.ts"],
  "sourcesContent": ["module.exports = encode\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31)\n\nfunction encode(num, out, offset) {\n  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {\n    encode.bytes = 0\n    throw new RangeError('Could not encode varint')\n  }\n  out = out || []\n  offset = offset || 0\n  var oldOffset = offset\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB\n    num /= 128\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB\n    num >>>= 7\n  }\n  out[offset] = num | 0\n  \n  encode.bytes = offset - oldOffset + 1\n  \n  return out\n}\n", "module.exports = read\n\nvar MSB = 0x80\n  , REST = 0x7F\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length\n\n  do {\n    if (counter >= l || shift > 49) {\n      read.bytes = 0\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++]\n    res += shift < 28\n      ? (b & REST) << shift\n      : (b & REST) * Math.pow(2, shift)\n    shift += 7\n  } while (b >= MSB)\n\n  read.bytes = counter - offset\n\n  return res\n}\n", "\nvar N1 = Math.pow(2,  7)\nvar N2 = Math.pow(2, 14)\nvar N3 = Math.pow(2, 21)\nvar N4 = Math.pow(2, 28)\nvar N5 = Math.pow(2, 35)\nvar N6 = Math.pow(2, 42)\nvar N7 = Math.pow(2, 49)\nvar N8 = Math.pow(2, 56)\nvar N9 = Math.pow(2, 63)\n\nmodule.exports = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n}\n", "module.exports = {\n    encode: require('./encode.js')\n  , decode: require('./decode.js')\n  , encodingLength: require('./length.js')\n}\n", "// Number is encoded in scientific notation.\n// A Number is composed of an exponent and a mantissa. The exponent isan integer\n// in [-324, 308] and the mantissa is a decimal in ]-10, 10[.\n// First we encode the sign as N or P, then E marking the start of the exponent.\n// The exponent is offseted of 500 to be positive and startpadded to 3 chars.\n// We endpad mantissa with enough zero to exceed mantissa precision.\n// Then negative numbers' mantissa and exponent are flipped (nines' complement)\n\nexports.encode = function (number) {\n    if (isNaN(number)) { return \"DaN\"; }\n    if (number === 0) { return \"FE  0M0\"; }\n    if (number === Infinity) { return \"FF\"; }\n    if (number === -Infinity) { return \"DD\"; }\n\n    var splitScientificNotation = number.toExponential().split('e');\n    var exponent = Number(splitScientificNotation[1]) + 500;\n    var mantissa = splitScientificNotation[0] + (splitScientificNotation[0].indexOf('.') === -1 ? '.' : '') + '0'.repeat(20);\n    var encoded = 'E' + padStart(String(exponent), 3) + 'M' + String(mantissa);\n    if (number > 0) {\n        return 'F' + encoded;\n    } else {\n        return 'D' + flip(encoded);\n    }\n}\n\nexports.decode = function (encoded) {\n    if (encoded === 'DaN') { return NaN; }\n    if (encoded === 'FF') { return Infinity; }\n    if (encoded === 'DD') { return -Infinity; }\n\n    var isNegative = encoded[0] === 'D';\n    var splitEncoded = (isNegative ? flip(encoded) : encoded).slice(2).split('M');\n    return Number((isNegative ? '-':'') + splitEncoded[1] + 'e' + String(Number(splitEncoded[0])-500));\n}\n\nfunction flip(number) {\n    var flipped = '';\n    for (var i = 0; i < number.length; i++) {\n        var digit = number[i];\n        if (isNaN(Number(digit)) || digit === ' ') {\n            if (digit !== '-') { flipped += digit; }\n        } else {\n            flipped += String(9 - Number(digit));\n        }\n    }\n    return flipped;\n}\n\nfunction padStart (str, count) {\n  return (' ').repeat(count - str.length).substr(0,count) + str;\n};\n", "var dictEscape = { '?': '?@', '!': '??', '\"': '?%' };\nfunction escape(str) {\n    if (!/[!\"]/.test(str)) { return str; }\n    return str.replace(/[\\?!\"]/g, function (match) {\n        return dictEscape[match];\n    });\n\n}\n\nvar dictUnescape = { '?@': '?', '??': '!', '?%': '\"' };\nfunction unescape(str) {\n    if (!/\\?[%\\?@]/.test(str)) { return str; }\n    return str.replace(/\\?[%\\?@]/g, function (match) {\n        return dictUnescape[match];\n    });\n}\n\nexports.factory = function (codec) {\n\n    return {\n        encode: encode,\n        decode: decode\n    };\n\n    function encode(array) {\n        if (array === null) { return 'A'; }\n        if (!Array.isArray(array)) { throw new Error('can only encode arrays'); }\n        var l = array.length;\n        if (l == 0) { return 'K!'; }\n\n        var s = encodeItem(array[0]);\n        for (var i = 1; i < l; i++) {\n            s += '\"' + encodeItem(array[i]);\n        }\n\n        return 'K'+ s + '!';\n    }\n\n    function encodeItem(item) {\n        if (typeof item === 'object') {\n            return encode(item);\n        }\n        return escape(codec.encode(item));\n    }\n\n    function decode(encoded) {\n        if (encoded === 'A') { return null; }\n        if (encoded === 'K!') { return []; }\n        var items = encoded.split('\"');\n\n        var pointers = [[]];\n        var array;\n        var depth = 0;\n\n        var l = items.length;\n        for (var i = 0; i < l; i++) {\n            var item = items[i];\n            var itemLength = item.length;\n\n            var open = 0;\n            while (item[open] == 'K') { open++; }\n\n            var close = 0;\n            while (item[itemLength-close - 1] == '!') { close++; }\n\n            var content = item.slice(open, itemLength-close);\n\n            var newdepth = depth + open;\n            for (var j = depth; j < newdepth; j++) {\n                pointers[j + 1] = [];\n                pointers[j].push(pointers[j + 1]);\n                depth = newdepth;\n                array = pointers[depth];\n            }\n\n            if (content.length !== 0) {\n                array.push(codec.decode(unescape(content)));\n            }\n\n            var newdepth = depth - close;\n            for (var j = newdepth; j < depth; j++) {\n                pointers[j + 1] = [];\n                depth = newdepth;\n                array = pointers[depth];\n            }\n\n        }\n        return pointers[0][0];\n    }\n}\n", "var number = require('./codec/number.js');\nvar object = require('./codec/object.js');\n\nvar flip = exports.flip = function (n) {\n  var s = n.toString()\n  var f = ''\n  for(var i in s) {\n    f += s[i] == '.' ? '.' : (9 - +s[i])\n  }\n  return f\n}\n\nfunction round (n) {\n  return n < 0 ? Math.ceil(n) : Math.floor(n)\n}\n\nfunction fraction (f) {\n  return f - round(f)\n}\n\nexports.number = number;\n\nexports.string = {\n  encode: function (s) {\n    //we'll need to escape the separators\n    if(!/\\x00|\\x01/.test(s))\n      return 'J'+s\n    else {\n      return 'J'+s.replace(/\\x01/g, '\\x01\\x01').replace(/\\x00/g, '\\x01')\n    }\n  },\n  decode: function (s) {\n    if('J' === s[0])\n      return s.substring(1) //TODO, unescape things...\n  }\n}\n\nexports.encode = function (t) {\n  return exports[typeof t].encode(t)\n}\n\nexports.decode = function (s) {\n  if(s === '') return s\n\n  if(!decoders[s[0]])\n    throw new Error('no decoder for:'+JSON.stringify(s))\n  return decoders[s[0]](s)\n}\n\nexports.object = object.factory(exports);\n\nexports.boolean = {\n  encode: function (b) {\n    return b ? 'C' : 'B'\n  },\n  decode: function (b) {\n    return 'C' === b\n  }\n}\n\nexports.undefined = {\n  encode: function (b) {\n    return 'L'\n  },\n  decode: function () {\n    return undefined\n  }\n}\n\nvar decoders = {\n  A: exports.object.decode, //null\n  B: exports.boolean.decode, // false\n  C: exports.boolean.decode, // true\n  D: exports.number.decode, // number\n  F: exports.number.decode, // number\n  // G Date\n  // H Date\n  // I Buffer\n  J: exports.string.decode, // String\n  K: exports.object.decode, // Array\n  L: exports.undefined.decode, // undefined\n}\n\n\n//for leveldb, request strings\nexports.buffer = false\nexports.type = 'charwise'\n", "\"use strict\";\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n", "\"use strict\";\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n", "\"use strict\";\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n", "\"use strict\";\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n", "\"use strict\";\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n", "\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n", "\"use strict\";\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n", "\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(\"../util/minimal\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n", "\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(\"@protobufjs/aspromise\");\n\n// converts to / from base64 encoded strings\nutil.base64 = require(\"@protobufjs/base64\");\n\n// base class of rpc.Service\nutil.EventEmitter = require(\"@protobufjs/eventemitter\");\n\n// float handling accross browsers\nutil.float = require(\"@protobufjs/float\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(\"@protobufjs/inquire\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(\"@protobufjs/utf8\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(\"@protobufjs/pool\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(\"./longbits\");\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n        name: {\n            get: function get() { return name; },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true,\n        },\n        toString: {\n            value: function value() { return this.name + \": \" + this.message; },\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n    });\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n", "\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n", "\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(\"./writer\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n", "\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n        ? new this.buf.constructor(0)\n        : this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n", "\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(\"./reader\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n", "\"use strict\";\nmodule.exports = Service;\n\nvar util = require(\"../util/minimal\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n", "\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(\"./rpc/service\");\n", "\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n", "\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(\"./writer\");\nprotobuf.BufferWriter = require(\"./writer_buffer\");\nprotobuf.Reader       = require(\"./reader\");\nprotobuf.BufferReader = require(\"./reader_buffer\");\n\n// Utility\nprotobuf.util         = require(\"./util/minimal\");\nprotobuf.rpc          = require(\"./rpc\");\nprotobuf.roots        = require(\"./roots\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n", "// minimal library entry point.\n\n\"use strict\";\nmodule.exports = require(\"./src/index-minimal\");\n", "/* jshint -W086: true */\n// +----------------------------------------------------------------------+\n// | murmurHash3js.js v3.0.1 // https://github.com/pid/murmurHash3js\n// | A javascript implementation of MurmurHash3's x86 hashing algorithms. |\n// |----------------------------------------------------------------------|\n// | Copyright (c) 2012-2015 Karan Lyons                                       |\n// | https://github.com/karanlyons/murmurHash3.js/blob/c1778f75792abef7bdd74bc85d2d4e1a3d25cfe9/murmurHash3.js |\n// | Freely distributable under the MIT license.                          |\n// +----------------------------------------------------------------------+\n\n;(function (root, undefined) {\n    'use strict';\n\n    // Create a local object that'll be exported or referenced globally.\n    var library = {\n        'version': '3.0.0',\n        'x86': {},\n        'x64': {},\n        'inputValidation': true\n    };\n\n    // PRIVATE FUNCTIONS\n    // -----------------\n\n    function _validBytes(bytes) {\n        // check the input is an array or a typed array\n        if (!Array.isArray(bytes) && !ArrayBuffer.isView(bytes)) {\n            return false;\n        }\n\n        // check all bytes are actually bytes\n        for (var i = 0; i < bytes.length; i++) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] < 0 || bytes[i] > 255) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function _x86Multiply(m, n) {\n        //\n        // Given two 32bit ints, returns the two multiplied together as a\n        // 32bit int.\n        //\n\n        return ((m & 0xffff) * n) + ((((m >>> 16) * n) & 0xffff) << 16);\n    }\n\n    function _x86Rotl(m, n) {\n        //\n        // Given a 32bit int and an int representing a number of bit positions,\n        // returns the 32bit int rotated left by that number of positions.\n        //\n\n        return (m << n) | (m >>> (32 - n));\n    }\n\n    function _x86Fmix(h) {\n        //\n        // Given a block, returns murmurHash3's final x86 mix of that block.\n        //\n\n        h ^= h >>> 16;\n        h = _x86Multiply(h, 0x85ebca6b);\n        h ^= h >>> 13;\n        h = _x86Multiply(h, 0xc2b2ae35);\n        h ^= h >>> 16;\n\n        return h;\n    }\n\n    function _x64Add(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // added together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];\n        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];\n        var o = [0, 0, 0, 0];\n\n        o[3] += m[3] + n[3];\n        o[2] += o[3] >>> 16;\n        o[3] &= 0xffff;\n\n        o[2] += m[2] + n[2];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[1] += m[1] + n[1];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[0] += m[0] + n[0];\n        o[0] &= 0xffff;\n\n        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n    }\n\n    function _x64Multiply(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // multiplied together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];\n        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];\n        var o = [0, 0, 0, 0];\n\n        o[3] += m[3] * n[3];\n        o[2] += o[3] >>> 16;\n        o[3] &= 0xffff;\n\n        o[2] += m[2] * n[3];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[2] += m[3] * n[2];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[1] += m[1] * n[3];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[1] += m[2] * n[2];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[1] += m[3] * n[1];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[0] += (m[0] * n[3]) + (m[1] * n[2]) + (m[2] * n[1]) + (m[3] * n[0]);\n        o[0] &= 0xffff;\n\n        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n    }\n\n    function _x64Rotl(m, n) {\n        //\n        // Given a 64bit int (as an array of two 32bit ints) and an int\n        // representing a number of bit positions, returns the 64bit int (as an\n        // array of two 32bit ints) rotated left by that number of positions.\n        //\n\n        n %= 64;\n\n        if (n === 32) {\n            return [m[1], m[0]];\n        } else if (n < 32) {\n            return [(m[0] << n) | (m[1] >>> (32 - n)), (m[1] << n) | (m[0] >>> (32 - n))];\n        } else {\n            n -= 32;\n            return [(m[1] << n) | (m[0] >>> (32 - n)), (m[0] << n) | (m[1] >>> (32 - n))];\n        }\n    }\n\n    function _x64LeftShift(m, n) {\n        //\n        // Given a 64bit int (as an array of two 32bit ints) and an int\n        // representing a number of bit positions, returns the 64bit int (as an\n        // array of two 32bit ints) shifted left by that number of positions.\n        //\n\n        n %= 64;\n\n        if (n === 0) {\n            return m;\n        } else if (n < 32) {\n            return [(m[0] << n) | (m[1] >>> (32 - n)), m[1] << n];\n        } else {\n            return [m[1] << (n - 32), 0];\n        }\n    }\n\n    function _x64Xor(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // xored together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        return [m[0] ^ n[0], m[1] ^ n[1]];\n    }\n\n    function _x64Fmix(h) {\n        //\n        // Given a block, returns murmurHash3's final x64 mix of that block.\n        // (`[0, h[0] >>> 1]` is a 33 bit unsigned right shift. This is the\n        // only place where we need to right shift 64bit ints.)\n        //\n\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n        h = _x64Multiply(h, [0xff51afd7, 0xed558ccd]);\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n        h = _x64Multiply(h, [0xc4ceb9fe, 0x1a85ec53]);\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n\n        return h;\n    }\n\n    // PUBLIC FUNCTIONS\n    // ----------------\n\n    library.x86.hash32 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 32 bit hash\n        // using the x86 flavor of MurmurHash3, as an unsigned int.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n        seed = seed || 0;\n\n        var remainder = bytes.length % 4;\n        var blocks = bytes.length - remainder;\n\n        var h1 = seed;\n\n        var k1 = 0;\n\n        var c1 = 0xcc9e2d51;\n        var c2 = 0x1b873593;\n\n        for (var i = 0; i < blocks; i = i + 4) {\n            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);\n\n            k1 = _x86Multiply(k1, c1);\n            k1 = _x86Rotl(k1, 15);\n            k1 = _x86Multiply(k1, c2);\n\n            h1 ^= k1;\n            h1 = _x86Rotl(h1, 13);\n            h1 = _x86Multiply(h1, 5) + 0xe6546b64;\n        }\n\n        k1 = 0;\n\n        switch (remainder) {\n            case 3:\n                k1 ^= bytes[i + 2] << 16;\n\n            case 2:\n                k1 ^= bytes[i + 1] << 8;\n\n            case 1:\n                k1 ^= bytes[i];\n                k1 = _x86Multiply(k1, c1);\n                k1 = _x86Rotl(k1, 15);\n                k1 = _x86Multiply(k1, c2);\n                h1 ^= k1;\n        }\n\n        h1 ^= bytes.length;\n        h1 = _x86Fmix(h1);\n\n        return h1 >>> 0;\n    };\n\n    library.x86.hash128 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 128 bit\n        // hash using the x86 flavor of MurmurHash3, as an unsigned hex.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n\n        seed = seed || 0;\n        var remainder = bytes.length % 16;\n        var blocks = bytes.length - remainder;\n\n        var h1 = seed;\n        var h2 = seed;\n        var h3 = seed;\n        var h4 = seed;\n\n        var k1 = 0;\n        var k2 = 0;\n        var k3 = 0;\n        var k4 = 0;\n\n        var c1 = 0x239b961b;\n        var c2 = 0xab0e9789;\n        var c3 = 0x38b34ae5;\n        var c4 = 0xa1e38b93;\n\n        for (var i = 0; i < blocks; i = i + 16) {\n            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);\n            k2 = (bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24);\n            k3 = (bytes[i + 8]) | (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24);\n            k4 = (bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24);\n\n            k1 = _x86Multiply(k1, c1);\n            k1 = _x86Rotl(k1, 15);\n            k1 = _x86Multiply(k1, c2);\n            h1 ^= k1;\n\n            h1 = _x86Rotl(h1, 19);\n            h1 += h2;\n            h1 = _x86Multiply(h1, 5) + 0x561ccd1b;\n\n            k2 = _x86Multiply(k2, c2);\n            k2 = _x86Rotl(k2, 16);\n            k2 = _x86Multiply(k2, c3);\n            h2 ^= k2;\n\n            h2 = _x86Rotl(h2, 17);\n            h2 += h3;\n            h2 = _x86Multiply(h2, 5) + 0x0bcaa747;\n\n            k3 = _x86Multiply(k3, c3);\n            k3 = _x86Rotl(k3, 17);\n            k3 = _x86Multiply(k3, c4);\n            h3 ^= k3;\n\n            h3 = _x86Rotl(h3, 15);\n            h3 += h4;\n            h3 = _x86Multiply(h3, 5) + 0x96cd1c35;\n\n            k4 = _x86Multiply(k4, c4);\n            k4 = _x86Rotl(k4, 18);\n            k4 = _x86Multiply(k4, c1);\n            h4 ^= k4;\n\n            h4 = _x86Rotl(h4, 13);\n            h4 += h1;\n            h4 = _x86Multiply(h4, 5) + 0x32ac3b17;\n        }\n\n        k1 = 0;\n        k2 = 0;\n        k3 = 0;\n        k4 = 0;\n\n        switch (remainder) {\n            case 15:\n                k4 ^= bytes[i + 14] << 16;\n\n            case 14:\n                k4 ^= bytes[i + 13] << 8;\n\n            case 13:\n                k4 ^= bytes[i + 12];\n                k4 = _x86Multiply(k4, c4);\n                k4 = _x86Rotl(k4, 18);\n                k4 = _x86Multiply(k4, c1);\n                h4 ^= k4;\n\n            case 12:\n                k3 ^= bytes[i + 11] << 24;\n\n            case 11:\n                k3 ^= bytes[i + 10] << 16;\n\n            case 10:\n                k3 ^= bytes[i + 9] << 8;\n\n            case 9:\n                k3 ^= bytes[i + 8];\n                k3 = _x86Multiply(k3, c3);\n                k3 = _x86Rotl(k3, 17);\n                k3 = _x86Multiply(k3, c4);\n                h3 ^= k3;\n\n            case 8:\n                k2 ^= bytes[i + 7] << 24;\n\n            case 7:\n                k2 ^= bytes[i + 6] << 16;\n\n            case 6:\n                k2 ^= bytes[i + 5] << 8;\n\n            case 5:\n                k2 ^= bytes[i + 4];\n                k2 = _x86Multiply(k2, c2);\n                k2 = _x86Rotl(k2, 16);\n                k2 = _x86Multiply(k2, c3);\n                h2 ^= k2;\n\n            case 4:\n                k1 ^= bytes[i + 3] << 24;\n\n            case 3:\n                k1 ^= bytes[i + 2] << 16;\n\n            case 2:\n                k1 ^= bytes[i + 1] << 8;\n\n            case 1:\n                k1 ^= bytes[i];\n                k1 = _x86Multiply(k1, c1);\n                k1 = _x86Rotl(k1, 15);\n                k1 = _x86Multiply(k1, c2);\n                h1 ^= k1;\n        }\n\n        h1 ^= bytes.length;\n        h2 ^= bytes.length;\n        h3 ^= bytes.length;\n        h4 ^= bytes.length;\n\n        h1 += h2;\n        h1 += h3;\n        h1 += h4;\n        h2 += h1;\n        h3 += h1;\n        h4 += h1;\n\n        h1 = _x86Fmix(h1);\n        h2 = _x86Fmix(h2);\n        h3 = _x86Fmix(h3);\n        h4 = _x86Fmix(h4);\n\n        h1 += h2;\n        h1 += h3;\n        h1 += h4;\n        h2 += h1;\n        h3 += h1;\n        h4 += h1;\n\n        return (\"00000000\" + (h1 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h3 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h4 >>> 0).toString(16)).slice(-8);\n    };\n\n    library.x64.hash128 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 128 bit\n        // hash using the x64 flavor of MurmurHash3, as an unsigned hex.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n        seed = seed || 0;\n\n        var remainder = bytes.length % 16;\n        var blocks = bytes.length - remainder;\n\n        var h1 = [0, seed];\n        var h2 = [0, seed];\n\n        var k1 = [0, 0];\n        var k2 = [0, 0];\n\n        var c1 = [0x87c37b91, 0x114253d5];\n        var c2 = [0x4cf5ad43, 0x2745937f];\n\n        for (var i = 0; i < blocks; i = i + 16) {\n            k1 = [(bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24), (bytes[i]) |\n                (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24)];\n            k2 = [(bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24), (bytes[i + 8]) |\n                (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24)];\n\n            k1 = _x64Multiply(k1, c1);\n            k1 = _x64Rotl(k1, 31);\n            k1 = _x64Multiply(k1, c2);\n            h1 = _x64Xor(h1, k1);\n\n            h1 = _x64Rotl(h1, 27);\n            h1 = _x64Add(h1, h2);\n            h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 0x52dce729]);\n\n            k2 = _x64Multiply(k2, c2);\n            k2 = _x64Rotl(k2, 33);\n            k2 = _x64Multiply(k2, c1);\n            h2 = _x64Xor(h2, k2);\n\n            h2 = _x64Rotl(h2, 31);\n            h2 = _x64Add(h2, h1);\n            h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 0x38495ab5]);\n        }\n\n        k1 = [0, 0];\n        k2 = [0, 0];\n\n        switch (remainder) {\n            case 15:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 14]], 48));\n\n            case 14:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 13]], 40));\n\n            case 13:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 12]], 32));\n\n            case 12:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 11]], 24));\n\n            case 11:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 10]], 16));\n\n            case 10:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 9]], 8));\n\n            case 9:\n                k2 = _x64Xor(k2, [0, bytes[i + 8]]);\n                k2 = _x64Multiply(k2, c2);\n                k2 = _x64Rotl(k2, 33);\n                k2 = _x64Multiply(k2, c1);\n                h2 = _x64Xor(h2, k2);\n\n            case 8:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 7]], 56));\n\n            case 7:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 6]], 48));\n\n            case 6:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 5]], 40));\n\n            case 5:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 4]], 32));\n\n            case 4:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 3]], 24));\n\n            case 3:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 2]], 16));\n\n            case 2:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 1]], 8));\n\n            case 1:\n                k1 = _x64Xor(k1, [0, bytes[i]]);\n                k1 = _x64Multiply(k1, c1);\n                k1 = _x64Rotl(k1, 31);\n                k1 = _x64Multiply(k1, c2);\n                h1 = _x64Xor(h1, k1);\n        }\n\n        h1 = _x64Xor(h1, [0, bytes.length]);\n        h2 = _x64Xor(h2, [0, bytes.length]);\n\n        h1 = _x64Add(h1, h2);\n        h2 = _x64Add(h2, h1);\n\n        h1 = _x64Fmix(h1);\n        h2 = _x64Fmix(h2);\n\n        h1 = _x64Add(h1, h2);\n        h2 = _x64Add(h2, h1);\n\n        return (\"00000000\" + (h1[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h1[1] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2[1] >>> 0).toString(16)).slice(-8);\n    };\n\n    // INITIALIZATION\n    // --------------\n\n    // Export murmurHash3 for CommonJS, either as an AMD module or just as part\n    // of the global object.\n    if (typeof exports !== 'undefined') {\n\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = library;\n        }\n\n        exports.murmurHash3 = library;\n\n    } else if (typeof define === 'function' && define.amd) {\n\n        define([], function () {\n            return library;\n        });\n    } else {\n\n        // Use murmurHash3.noConflict to restore `murmurHash3` back to its\n        // original value. Returns a reference to the library object, to allow\n        // it to be used under a different name.\n        library._murmurHash3 = root.murmurHash3;\n\n        library.noConflict = function () {\n            root.murmurHash3 = library._murmurHash3;\n            library._murmurHash3 = undefined;\n            library.noConflict = undefined;\n\n            return library;\n        };\n\n        root.murmurHash3 = library;\n    }\n})(this);\n", "module.exports = require('./lib/murmurHash3js');\n", "'use strict';\n\n/**\n * @typedef {{ [key: string]: any }} Extensions\n * @typedef {Error} Err\n * @property {string} message\n */\n\n/**\n *\n * @param {Error} obj\n * @param {Extensions} props\n * @returns {Error & Extensions}\n */\nfunction assign(obj, props) {\n    for (const key in props) {\n        Object.defineProperty(obj, key, {\n            value: props[key],\n            enumerable: true,\n            configurable: true,\n        });\n    }\n\n    return obj;\n}\n\n/**\n *\n * @param {any} err - An Error\n * @param {string|Extensions} code - A string code or props to set on the error\n * @param {Extensions} [props] - Props to set on the error\n * @returns {Error & Extensions}\n */\nfunction createError(err, code, props) {\n    if (!err || typeof err === 'string') {\n        throw new TypeError('Please pass an Error to err-code');\n    }\n\n    if (!props) {\n        props = {};\n    }\n\n    if (typeof code === 'object') {\n        props = code;\n        code = '';\n    }\n\n    if (code) {\n        props.code = code;\n    }\n\n    try {\n        return assign(err, props);\n    } catch (_) {\n        props.message = err.message;\n        props.stack = err.stack;\n\n        const ErrClass = function () {};\n\n        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));\n\n        // @ts-ignore\n        const output = assign(new ErrClass(), props);\n\n        return output;\n    }\n}\n\nmodule.exports = createError;\n", "'use strict'\n\n// JS treats subjects of bitwise operators as SIGNED 32 bit numbers,\n// which means the maximum amount of bits we can store inside each byte\n// is 7..\nconst BITS_PER_BYTE = 7\n\nmodule.exports = class SparseArray {\n  constructor () {\n    this._bitArrays = []\n    this._data = []\n    this._length = 0\n    this._changedLength = false\n    this._changedData = false\n  }\n\n  set (index, value) {\n    let pos = this._internalPositionFor(index, false)\n    if (value === undefined) {\n      // unsetting\n      if (pos !== -1) {\n        // remove item from bit array and array itself\n        this._unsetInternalPos(pos)\n        this._unsetBit(index)\n        this._changedLength = true\n        this._changedData = true\n      }\n    } else {\n      let needsSort = false\n      if (pos === -1) {\n        pos = this._data.length\n        this._setBit(index)\n        this._changedData = true\n      } else {\n        needsSort = true\n      }\n      this._setInternalPos(pos, index, value, needsSort)\n      this._changedLength = true\n    }\n  }\n\n  unset (index) {\n    this.set(index, undefined)\n  }\n\n  get (index) {\n    this._sortData()\n    const pos = this._internalPositionFor(index, true)\n    if (pos === -1) {\n      return undefined\n    }\n    return this._data[pos][1]\n  }\n\n  push (value) {\n    this.set(this.length, value)\n    return this.length\n  }\n\n  get length () {\n    this._sortData()\n    if (this._changedLength) {\n      const last = this._data[this._data.length - 1]\n      this._length = last ? last[0] + 1 : 0\n      this._changedLength = false\n    }\n    return this._length\n  }\n\n  forEach (iterator) {\n    let i = 0\n    while(i < this.length) {\n      iterator(this.get(i), i, this)\n      i++\n    }\n  }\n\n  map (iterator) {\n    let i = 0\n    let mapped = new Array(this.length)\n    while(i < this.length) {\n      mapped[i] = iterator(this.get(i), i, this)\n      i++\n    }\n    return mapped\n  }\n\n  reduce (reducer, initialValue) {\n    let i = 0\n    let acc = initialValue\n    while(i < this.length) {\n      const value = this.get(i)\n      acc = reducer(acc, value, i)\n      i++\n    }\n    return acc\n  }\n\n  find (finder) {\n    let i = 0, found, last\n    while ((i < this.length) && !found) {\n      last = this.get(i)\n      found = finder(last)\n      i++\n    }\n    return found ? last : undefined\n  }\n\n  _internalPositionFor (index, noCreate) {\n    const bytePos = this._bytePosFor(index, noCreate)\n    if (bytePos >= this._bitArrays.length) {\n      return -1\n    }\n    const byte = this._bitArrays[bytePos]\n    const bitPos = index - bytePos * BITS_PER_BYTE\n    const exists = (byte & (1 << bitPos)) > 0\n    if (!exists) {\n      return -1\n    }\n    const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0)\n\n    const mask = ~(0xffffffff << (bitPos + 1))\n    const bytePopCount = popCount(byte & mask)\n    const arrayPos = previousPopCount + bytePopCount - 1\n    return arrayPos\n  }\n\n  _bytePosFor (index, noCreate) {\n    const bytePos = Math.floor(index / BITS_PER_BYTE)\n    const targetLength = bytePos + 1\n    while (!noCreate && this._bitArrays.length < targetLength) {\n      this._bitArrays.push(0)\n    }\n    return bytePos\n  }\n\n  _setBit (index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] |= (1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _unsetBit(index) {\n    const bytePos = this._bytePosFor(index, false)\n    this._bitArrays[bytePos] &= ~(1 << (index - (bytePos * BITS_PER_BYTE)))\n  }\n\n  _setInternalPos(pos, index, value, needsSort) {\n    const data =this._data\n    const elem = [index, value]\n    if (needsSort) {\n      this._sortData()\n      data[pos] = elem\n    } else {\n      // new element. just shove it into the array\n      // but be nice about where we shove it\n      // in order to make sorting it later easier\n      if (data.length) {\n        if (data[data.length - 1][0] >= index) {\n          data.push(elem)\n        } else if (data[0][0] <= index) {\n          data.unshift(elem)\n        } else {\n          const randomIndex = Math.round(data.length / 2)\n          this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex))\n        }\n      } else {\n        this._data.push(elem)\n      }\n      this._changedData = true\n      this._changedLength = true\n    }\n  }\n\n  _unsetInternalPos (pos) {\n    this._data.splice(pos, 1)\n  }\n\n  _sortData () {\n    if (this._changedData) {\n      this._data.sort(sortInternal)\n    }\n\n    this._changedData = false\n  }\n\n  bitField () {\n    const bytes = []\n    let pendingBitsForResultingByte = 8\n    let pendingBitsForNewByte = 0\n    let resultingByte = 0\n    let newByte\n    const pending = this._bitArrays.slice()\n    while (pending.length || pendingBitsForNewByte) {\n      if (pendingBitsForNewByte === 0) {\n        newByte = pending.shift()\n        pendingBitsForNewByte = 7\n      }\n\n      const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte)\n      const mask = ~(0b11111111 << usingBits)\n      const masked = newByte & mask\n      resultingByte |= masked << (8 - pendingBitsForResultingByte)\n      newByte = newByte >>> usingBits\n      pendingBitsForNewByte -= usingBits\n      pendingBitsForResultingByte -= usingBits\n\n      if (!pendingBitsForResultingByte || (!pendingBitsForNewByte && !pending.length)) {\n        bytes.push(resultingByte)\n        resultingByte = 0\n        pendingBitsForResultingByte = 8\n      }\n    }\n\n    // remove trailing zeroes\n    for(var i = bytes.length - 1; i > 0; i--) {\n      const value = bytes[i]\n      if (value === 0) {\n        bytes.pop()\n      } else {\n        break\n      }\n    }\n\n    return bytes\n  }\n\n  compactArray () {\n    this._sortData()\n    return this._data.map(valueOnly)\n  }\n}\n\nfunction popCountReduce (count, byte) {\n  return count + popCount(byte)\n}\n\nfunction popCount(_v) {\n  let v = _v\n  v = v - ((v >> 1) & 0x55555555)                    // reuse input as temporary\n  v = (v & 0x33333333) + ((v >> 2) & 0x33333333)     // temp\n  return ((v + (v >> 4) & 0xF0F0F0F) * 0x1010101) >> 24\n}\n\nfunction sortInternal (a, b) {\n  return a[0] - b[0]\n}\n\nfunction valueOnly (elem) {\n  return elem[1]\n}", "'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n", "// ts-unused-exports:disable-next-line\nexport * from './database'\n// ts-unused-exports:disable-next-line\nexport * from './index'\n// ts-unused-exports:disable-next-line\nexport * from './loader-helpers'\n\nexport * from './store'\nexport * from './loader'", "/**\n * uuidv7: An experimental implementation of the proposed UUID Version 7\n *\n * @license Apache-2.0\n * @copyright 2021-2023 LiosK\n * @packageDocumentation\n */\nconst DIGITS = \"0123456789abcdef\";\n/** Represents a UUID as a 16-byte byte array. */\nexport class UUID {\n    /** @param bytes - The 16-byte byte array representation. */\n    constructor(bytes) {\n        this.bytes = bytes;\n    }\n    /**\n     * Creates an object from the internal representation, a 16-byte byte array\n     * containing the binary UUID representation in the big-endian byte order.\n     *\n     * This method does NOT shallow-copy the argument, and thus the created object\n     * holds the reference to the underlying buffer.\n     *\n     * @throws TypeError if the length of the argument is not 16.\n     */\n    static ofInner(bytes) {\n        if (bytes.length !== 16) {\n            throw new TypeError(\"not 128-bit length\");\n        }\n        else {\n            return new UUID(bytes);\n        }\n    }\n    /**\n     * Builds a byte array from UUIDv7 field values.\n     *\n     * @param unixTsMs - A 48-bit `unix_ts_ms` field value.\n     * @param randA - A 12-bit `rand_a` field value.\n     * @param randBHi - The higher 30 bits of 62-bit `rand_b` field value.\n     * @param randBLo - The lower 32 bits of 62-bit `rand_b` field value.\n     * @throws RangeError if any field value is out of the specified range.\n     */\n    static fromFieldsV7(unixTsMs, randA, randBHi, randBLo) {\n        if (!Number.isInteger(unixTsMs) ||\n            !Number.isInteger(randA) ||\n            !Number.isInteger(randBHi) ||\n            !Number.isInteger(randBLo) ||\n            unixTsMs < 0 ||\n            randA < 0 ||\n            randBHi < 0 ||\n            randBLo < 0 ||\n            unixTsMs > 281474976710655 ||\n            randA > 0xfff ||\n            randBHi > 1073741823 ||\n            randBLo > 4294967295) {\n            throw new RangeError(\"invalid field value\");\n        }\n        const bytes = new Uint8Array(16);\n        bytes[0] = unixTsMs / 2 ** 40;\n        bytes[1] = unixTsMs / 2 ** 32;\n        bytes[2] = unixTsMs / 2 ** 24;\n        bytes[3] = unixTsMs / 2 ** 16;\n        bytes[4] = unixTsMs / 2 ** 8;\n        bytes[5] = unixTsMs;\n        bytes[6] = 0x70 | (randA >>> 8);\n        bytes[7] = randA;\n        bytes[8] = 0x80 | (randBHi >>> 24);\n        bytes[9] = randBHi >>> 16;\n        bytes[10] = randBHi >>> 8;\n        bytes[11] = randBHi;\n        bytes[12] = randBLo >>> 24;\n        bytes[13] = randBLo >>> 16;\n        bytes[14] = randBLo >>> 8;\n        bytes[15] = randBLo;\n        return new UUID(bytes);\n    }\n    /**\n     * Builds a byte array from a string representation.\n     *\n     * This method accepts the following formats:\n     *\n     * - 32-digit hexadecimal format without hyphens: `0189dcd553117d408db09496a2eef37b`\n     * - 8-4-4-4-12 hyphenated format: `0189dcd5-5311-7d40-8db0-9496a2eef37b`\n     * - Hyphenated format with surrounding braces: `{0189dcd5-5311-7d40-8db0-9496a2eef37b}`\n     * - RFC 4122 URN format: `urn:uuid:0189dcd5-5311-7d40-8db0-9496a2eef37b`\n     *\n     * Leading and trailing whitespaces represents an error.\n     *\n     * @throws SyntaxError if the argument could not parse as a valid UUID string.\n     */\n    static parse(uuid) {\n        var _a, _b, _c, _d;\n        let hex = undefined;\n        switch (uuid.length) {\n            case 32:\n                hex = (_a = /^[0-9a-f]{32}$/i.exec(uuid)) === null || _a === void 0 ? void 0 : _a[0];\n                break;\n            case 36:\n                hex =\n                    (_b = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i\n                        .exec(uuid)) === null || _b === void 0 ? void 0 : _b.slice(1, 6).join(\"\");\n                break;\n            case 38:\n                hex =\n                    (_c = /^\\{([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})\\}$/i\n                        .exec(uuid)) === null || _c === void 0 ? void 0 : _c.slice(1, 6).join(\"\");\n                break;\n            case 45:\n                hex =\n                    (_d = /^urn:uuid:([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i\n                        .exec(uuid)) === null || _d === void 0 ? void 0 : _d.slice(1, 6).join(\"\");\n                break;\n            default:\n                break;\n        }\n        if (hex) {\n            const inner = new Uint8Array(16);\n            for (let i = 0; i < 16; i += 4) {\n                const n = parseInt(hex.substring(2 * i, 2 * i + 8), 16);\n                inner[i + 0] = n >>> 24;\n                inner[i + 1] = n >>> 16;\n                inner[i + 2] = n >>> 8;\n                inner[i + 3] = n;\n            }\n            return new UUID(inner);\n        }\n        else {\n            throw new SyntaxError(\"could not parse UUID string\");\n        }\n    }\n    /**\n     * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n     * (`0189dcd5-5311-7d40-8db0-9496a2eef37b`).\n     */\n    toString() {\n        let text = \"\";\n        for (let i = 0; i < this.bytes.length; i++) {\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\n            if (i === 3 || i === 5 || i === 7 || i === 9) {\n                text += \"-\";\n            }\n        }\n        return text;\n    }\n    /**\n     * @returns The 32-digit hexadecimal representation without hyphens\n     * (`0189dcd553117d408db09496a2eef37b`).\n     */\n    toHex() {\n        let text = \"\";\n        for (let i = 0; i < this.bytes.length; i++) {\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\n        }\n        return text;\n    }\n    /** @returns The 8-4-4-4-12 canonical hexadecimal string representation. */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * Reports the variant field value of the UUID or, if appropriate, \"NIL\" or\n     * \"MAX\".\n     *\n     * For convenience, this method reports \"NIL\" or \"MAX\" if `this` represents\n     * the Nil or Max UUID, although the Nil and Max UUIDs are technically\n     * subsumed under the variants `0b0` and `0b111`, respectively.\n     */\n    getVariant() {\n        const n = this.bytes[8] >>> 4;\n        if (n < 0) {\n            throw new Error(\"unreachable\");\n        }\n        else if (n <= 0b0111) {\n            return this.bytes.every((e) => e === 0) ? \"NIL\" : \"VAR_0\";\n        }\n        else if (n <= 0b1011) {\n            return \"VAR_10\";\n        }\n        else if (n <= 0b1101) {\n            return \"VAR_110\";\n        }\n        else if (n <= 0b1111) {\n            return this.bytes.every((e) => e === 0xff) ? \"MAX\" : \"VAR_RESERVED\";\n        }\n        else {\n            throw new Error(\"unreachable\");\n        }\n    }\n    /**\n     * Returns the version field value of the UUID or `undefined` if the UUID does\n     * not have the variant field value of `0b10`.\n     */\n    getVersion() {\n        return this.getVariant() === \"VAR_10\" ? this.bytes[6] >>> 4 : undefined;\n    }\n    /** Creates an object from `this`. */\n    clone() {\n        return new UUID(this.bytes.slice(0));\n    }\n    /** Returns true if `this` is equivalent to `other`. */\n    equals(other) {\n        return this.compareTo(other) === 0;\n    }\n    /**\n     * Returns a negative integer, zero, or positive integer if `this` is less\n     * than, equal to, or greater than `other`, respectively.\n     */\n    compareTo(other) {\n        for (let i = 0; i < 16; i++) {\n            const diff = this.bytes[i] - other.bytes[i];\n            if (diff !== 0) {\n                return Math.sign(diff);\n            }\n        }\n        return 0;\n    }\n}\n/**\n * Encapsulates the monotonic counter state.\n *\n * This class provides APIs to utilize a separate counter state from that of the\n * global generator used by {@link uuidv7} and {@link uuidv7obj}. In addition to\n * the default {@link generate} method, this class has {@link generateOrAbort}\n * that is useful to absolutely guarantee the monotonically increasing order of\n * generated UUIDs despite a significant rollback of the system clock.\n */\nexport class V7Generator {\n    /**\n     * Creates a generator object with the default random number generator, or\n     * with the specified one if passed as an argument. The specified random\n     * number generator should be cryptographically strong and securely seeded.\n     */\n    constructor(randomNumberGenerator) {\n        this.timestamp = 0;\n        this.counter = 0;\n        this.random = randomNumberGenerator !== null && randomNumberGenerator !== void 0 ? randomNumberGenerator : getDefaultRandom();\n    }\n    /**\n     * Generates a new UUIDv7 object from the current timestamp, or resets the\n     * generator upon significant timestamp rollback.\n     *\n     * This method returns monotonically increasing UUIDs unless the up-to-date\n     * timestamp is significantly (by more than ten seconds) smaller than the one\n     * embedded in the immediately preceding UUID. If such a significant clock\n     * rollback is detected, this method resets the generator and returns a new\n     * UUID based on the current timestamp.\n     */\n    generate() {\n        return this.generateOrResetCore(Date.now(), 10000);\n    }\n    /**\n     * Generates a new UUIDv7 object from the current timestamp, or returns\n     * `undefined` upon significant timestamp rollback.\n     *\n     * This method returns monotonically increasing UUIDs unless the up-to-date\n     * timestamp is significantly (by more than ten seconds) smaller than the one\n     * embedded in the immediately preceding UUID. If such a significant clock\n     * rollback is detected, this method aborts and returns `undefined`.\n     */\n    generateOrAbort() {\n        return this.generateOrAbortCore(Date.now(), 10000);\n    }\n    /**\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or resets the\n     * generator upon significant timestamp rollback.\n     *\n     * This method is equivalent to {@link generate} except that it takes a custom\n     * timestamp and clock rollback allowance.\n     *\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\n     * considered significant. A suggested value is `10_000` (milliseconds).\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\n     */\n    generateOrResetCore(unixTsMs, rollbackAllowance) {\n        let value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\n        if (value === undefined) {\n            // reset state and resume\n            this.timestamp = 0;\n            value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\n        }\n        return value;\n    }\n    /**\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or returns\n     * `undefined` upon significant timestamp rollback.\n     *\n     * This method is equivalent to {@link generateOrAbort} except that it takes a\n     * custom timestamp and clock rollback allowance.\n     *\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\n     * considered significant. A suggested value is `10_000` (milliseconds).\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\n     */\n    generateOrAbortCore(unixTsMs, rollbackAllowance) {\n        const MAX_COUNTER = 4398046511103;\n        if (!Number.isInteger(unixTsMs) ||\n            unixTsMs < 1 ||\n            unixTsMs > 281474976710655) {\n            throw new RangeError(\"`unixTsMs` must be a 48-bit positive integer\");\n        }\n        else if (rollbackAllowance < 0 || rollbackAllowance > 281474976710655) {\n            throw new RangeError(\"`rollbackAllowance` out of reasonable range\");\n        }\n        if (unixTsMs > this.timestamp) {\n            this.timestamp = unixTsMs;\n            this.resetCounter();\n        }\n        else if (unixTsMs + rollbackAllowance >= this.timestamp) {\n            // go on with previous timestamp if new one is not much smaller\n            this.counter++;\n            if (this.counter > MAX_COUNTER) {\n                // increment timestamp at counter overflow\n                this.timestamp++;\n                this.resetCounter();\n            }\n        }\n        else {\n            // abort if clock went backwards to unbearable extent\n            return undefined;\n        }\n        return UUID.fromFieldsV7(this.timestamp, Math.trunc(this.counter / 2 ** 30), this.counter & (2 ** 30 - 1), this.random.nextUint32());\n    }\n    /** Initializes the counter at a 42-bit random integer. */\n    resetCounter() {\n        this.counter =\n            this.random.nextUint32() * 0x400 + (this.random.nextUint32() & 0x3ff);\n    }\n    /**\n     * Generates a new UUIDv4 object utilizing the random number generator inside.\n     *\n     * @internal\n     */\n    generateV4() {\n        const bytes = new Uint8Array(Uint32Array.of(this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32()).buffer);\n        bytes[6] = 0x40 | (bytes[6] >>> 4);\n        bytes[8] = 0x80 | (bytes[8] >>> 2);\n        return UUID.ofInner(bytes);\n    }\n}\n/** Returns the default random number generator available in the environment. */\nconst getDefaultRandom = () => {\n    // detect Web Crypto API\n    if (typeof crypto !== \"undefined\" &&\n        typeof crypto.getRandomValues !== \"undefined\") {\n        return new BufferedCryptoRandom();\n    }\n    else {\n        // fall back on Math.random() unless the flag is set to true\n        if (typeof UUIDV7_DENY_WEAK_RNG !== \"undefined\" && UUIDV7_DENY_WEAK_RNG) {\n            throw new Error(\"no cryptographically strong RNG available\");\n        }\n        return {\n            nextUint32: () => Math.trunc(Math.random() * 65536) * 65536 +\n                Math.trunc(Math.random() * 65536),\n        };\n    }\n};\n/**\n * Wraps `crypto.getRandomValues()` to enable buffering; this uses a small\n * buffer by default to avoid both unbearable throughput decline in some\n * environments and the waste of time and space for unused values.\n */\nclass BufferedCryptoRandom {\n    constructor() {\n        this.buffer = new Uint32Array(8);\n        this.cursor = 0xffff;\n    }\n    nextUint32() {\n        if (this.cursor >= this.buffer.length) {\n            crypto.getRandomValues(this.buffer);\n            this.cursor = 0;\n        }\n        return this.buffer[this.cursor++];\n    }\n}\nlet defaultGenerator;\n/**\n * Generates a UUIDv7 string.\n *\n * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n * (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\n */\nexport const uuidv7 = () => uuidv7obj().toString();\n/** Generates a UUIDv7 object. */\nexport const uuidv7obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generate();\n/**\n * Generates a UUIDv4 string.\n *\n * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n * (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\n */\nexport const uuidv4 = () => uuidv4obj().toString();\n/** Generates a UUIDv4 object. */\nexport const uuidv4obj = () => (defaultGenerator || (defaultGenerator = new V7Generator())).generateV4();\n", "import { BulkResult, DocUpdate } from './types'\n\ntype WorkerFunction = (tasks: DocUpdate[]) => Promise<BulkResult>;\n\nexport type WriteQueue = {\n  push(task: DocUpdate): Promise<BulkResult>;\n};\n\nexport function writeQueue(worker: WorkerFunction, payload: number = Infinity, unbounded: boolean = false): WriteQueue {\n  const queue: {\n    task: DocUpdate;\n    resolve: (result: BulkResult) => void;\n    reject: (error: Error) => void;\n  }[] = []\n  let isProcessing = false\n\n  async function process() {\n    if (isProcessing || queue.length === 0) return\n    isProcessing = true\n\n    const tasksToProcess = queue.splice(0, payload)\n    const updates = tasksToProcess.map(item => item.task)\n\n    if (unbounded) {\n      // Run all updates in parallel and resolve/reject them individually\n      const promises = updates.map(async (update, index) => {\n        try {\n          const result = await worker([update])\n          tasksToProcess[index].resolve(result)\n        } catch (error) {\n          tasksToProcess[index].reject(error as Error)\n        }\n      })\n\n      await Promise.all(promises)\n    } else {\n      // Original logic: Run updates in a batch and resolve/reject them together\n      try {\n        const result = await worker(updates)\n        tasksToProcess.forEach(task => task.resolve(result))\n      } catch (error) {\n        tasksToProcess.forEach(task => task.reject(error as Error))\n      }\n    }\n\n    isProcessing = false\n    void process()\n  }\n\n  return {\n    push(task: DocUpdate): Promise<BulkResult> {\n      return new Promise<BulkResult>((resolve, reject) => {\n        queue.push({ task, resolve, reject })\n        void process()\n      })\n    }\n  }\n}\n", "var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n", "const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "import basex from '../../vendor/base-x.js'\nimport { coerce } from '../bytes.js'\n// Linter can't see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.BaseEncoder}\n */\nclass Encoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   */\n  constructor (name, prefix, baseEncode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {API.Multibase<Prefix>}\n   */\n  encode (bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * @template {string} Prefix\n */\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.UnibaseDecoder<Prefix>}\n * @implements {API.BaseDecoder}\n */\nclass Decoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    /* c8 ignore next 3 */\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    /** @private */\n    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))\n    this.baseDecode = baseDecode\n  }\n\n  /**\n   * @param {string} text\n   */\n  decode (text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n}\n\n/**\n * @template {string} Prefix\n * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders\n */\n\n/**\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.CombobaseDecoder<Prefix>}\n */\nclass ComposedDecoder {\n  /**\n   * @param {Decoders<Prefix>} decoders\n   */\n  constructor (decoders) {\n    this.decoders = decoders\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n\n  /**\n   * @param {string} input\n   * @returns {Uint8Array}\n   */\n  decode (input) {\n    const prefix = /** @type {Prefix} */ (input[0])\n    const decoder = this.decoders[prefix]\n    if (decoder) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\n/**\n * @template {string} L\n * @template {string} R\n * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left\n * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right\n * @returns {ComposedDecoder<L|R>}\n */\nexport const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({\n  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),\n  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })\n}))\n\n/**\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseCodec<Prefix>}\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.BaseCodec}\n * @implements {API.BaseEncoder}\n * @implements {API.BaseDecoder}\n */\nexport class Codec {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseEncode, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  encode (input) {\n    return this.encoder.encode(input)\n  }\n\n  /**\n   * @param {string} input\n   */\n  decode (input) {\n    return this.decoder.decode(input)\n  }\n}\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {(bytes:Uint8Array) => string} options.encode\n * @param {(input:string) => Uint8Array} options.decode\n * @returns {Codec<Base, Prefix>}\n */\nexport const from = ({ name, prefix, encode, decode }) =>\n  new Codec(name, prefix, encode, decode)\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @returns {Codec<Base, Prefix>}\n */\nexport const baseX = ({ prefix, name, alphabet }) => {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    /**\n     * @param {string} text\n     */\n    decode: text => coerce(decode(text))\n  })\n}\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @param {string} name\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n *\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @param {number} options.bitsPerChar\n */\nexport const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {\n  return from({\n    prefix,\n    name,\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n", "import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n", "import * as varint from './varint.js'\nimport * as Digest from './hashes/digest.js'\nimport { base58btc } from './bases/base58.js'\nimport { base32 } from './bases/base32.js'\nimport { coerce } from './bytes.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   *\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n", "// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport { CID, format, toJSON, fromJSON } from './cid.js'\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nconst DAG_PB_CODE = 0x70\n// eslint-disable-next-line\nconst SHA_256_CODE = 0x12\n\n/**\n * Simplified version of `create` for CIDv0.\n *\n * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n * @returns {API.LegacyLink}\n */\nexport const createLegacy = digest => CID.create(0, DAG_PB_CODE, digest)\n\n/**\n * Simplified version of `create` for CIDv1.\n *\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @param {Code} code - Content encoding format code.\n * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n * @returns {API.Link<Data, Code, Alg>}\n */\nexport const create = (code, digest) => CID.create(1, code, digest)\n\n/**\n * Type predicate returns true if value is the link.\n *\n * @template {API.Link<unknown, number, number, 0|1>} L\n * @param {unknown|L} value\n * @returns {value is L & CID}\n */\nexport const isLink = value => {\n  if (value == null) {\n    return false\n  }\n\n  const withSlash = /** @type {{'/'?: Uint8Array, bytes: Uint8Array}} */ (value)\n\n  if (withSlash['/'] != null && withSlash['/'] === withSlash.bytes) {\n    return true\n  }\n\n  const withAsCID = /** @type {{'asCID'?: unknown}} */ (value)\n\n  if (withAsCID.asCID === value) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Takes cid in a string representation and creates an instance. If `base`\n * decoder is not provided will use a default from the configuration. It will\n * throw an error if encoding of the CID is not compatible with supplied (or\n * a default decoder).\n *\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {API.Link<Data, Code, Alg, Ver>}\n */\nexport const parse = (source, base) => CID.parse(source, base)\n\nexport { format, toJSON, fromJSON }\n\n/**\n * Decoded a CID from its binary representation. The byte array must contain\n * only the CID with no additional bytes.\n *\n * An error will be thrown if the bytes provided do not contain a valid\n * binary representation of a CID.\n *\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n * @returns {API.Link<Data, Code, Alg, Ver>}\n */\nexport const decode = bytes => CID.decode(bytes)\n", "import { parse } from 'multiformats/link'\n\n/**\n * @typedef {{ cid: import('./link').AnyLink, bytes: Uint8Array }} AnyBlock\n * @typedef {{ get: (link: import('./link').AnyLink) => Promise<AnyBlock | undefined> }} BlockFetcher\n */\n\n/** @implements {BlockFetcher} */\nexport class MemoryBlockstore {\n  /** @type {Map<string, Uint8Array>} */\n  #blocks = new Map()\n\n  /**\n   * @param {Array<AnyBlock>} [blocks]\n   */\n  constructor (blocks) {\n    if (blocks) {\n      this.#blocks = new Map(blocks.map(b => [b.cid.toString(), b.bytes]))\n    }\n  }\n\n  /**\n   * @param {import('./link').AnyLink} cid\n   * @returns {Promise<AnyBlock | undefined>}\n   */\n  async get (cid) {\n    const bytes = this.#blocks.get(cid.toString())\n    if (!bytes) return\n    return { cid, bytes }\n  }\n\n  /**\n   * @param {import('./link').AnyLink} cid\n   * @param {Uint8Array} bytes\n   */\n  async put (cid, bytes) {\n    this.#blocks.set(cid.toString(), bytes)\n  }\n\n  /**\n   * @param {import('./link').AnyLink} cid\n   * @param {Uint8Array} bytes\n   */\n  putSync (cid, bytes) {\n    this.#blocks.set(cid.toString(), bytes)\n  }\n\n  /** @param {import('./link').AnyLink} cid */\n  async delete (cid) {\n    this.#blocks.delete(cid.toString())\n  }\n\n  /** @param {import('./link').AnyLink} cid */\n  deleteSync (cid) {\n    this.#blocks.delete(cid.toString())\n  }\n\n  * entries () {\n    for (const [str, bytes] of this.#blocks) {\n      yield { cid: parse(str), bytes }\n    }\n  }\n}\n\nexport class MultiBlockFetcher {\n  /** @type {BlockFetcher[]} */\n  #fetchers\n\n  /** @param {BlockFetcher[]} fetchers */\n  constructor (...fetchers) {\n    this.#fetchers = fetchers\n  }\n\n  /** @param {import('./link').AnyLink} link */\n  async get (link) {\n    for (const f of this.#fetchers) {\n      const v = await f.get(link)\n      if (v) return v\n    }\n  }\n}\n", "/*\nHow it works:\n`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.\n*/\n\nclass Node {\n\tvalue;\n\tnext;\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n}\n\nexport default class Queue {\n\t#head;\n\t#tail;\n\t#size;\n\n\tconstructor() {\n\t\tthis.clear();\n\t}\n\n\tenqueue(value) {\n\t\tconst node = new Node(value);\n\n\t\tif (this.#head) {\n\t\t\tthis.#tail.next = node;\n\t\t\tthis.#tail = node;\n\t\t} else {\n\t\t\tthis.#head = node;\n\t\t\tthis.#tail = node;\n\t\t}\n\n\t\tthis.#size++;\n\t}\n\n\tdequeue() {\n\t\tconst current = this.#head;\n\t\tif (!current) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.#head = this.#head.next;\n\t\tthis.#size--;\n\t\treturn current.value;\n\t}\n\n\tclear() {\n\t\tthis.#head = undefined;\n\t\tthis.#tail = undefined;\n\t\tthis.#size = 0;\n\t}\n\n\tget size() {\n\t\treturn this.#size;\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tlet current = this.#head;\n\n\t\twhile (current) {\n\t\t\tyield current.value;\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n}\n", "import Queue from 'yocto-queue';\n\nexport default function pLimit(concurrency) {\n\tif (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {\n\t\tthrow new TypeError('Expected `concurrency` to be a number from 1 and up');\n\t}\n\n\tconst queue = new Queue();\n\tlet activeCount = 0;\n\n\tconst next = () => {\n\t\tactiveCount--;\n\n\t\tif (queue.size > 0) {\n\t\t\tqueue.dequeue()();\n\t\t}\n\t};\n\n\tconst run = async (fn, resolve, args) => {\n\t\tactiveCount++;\n\n\t\tconst result = (async () => fn(...args))();\n\n\t\tresolve(result);\n\n\t\ttry {\n\t\t\tawait result;\n\t\t} catch {}\n\n\t\tnext();\n\t};\n\n\tconst enqueue = (fn, resolve, args) => {\n\t\tqueue.enqueue(run.bind(undefined, fn, resolve, args));\n\n\t\t(async () => {\n\t\t\t// This function needs to wait until the next microtask before comparing\n\t\t\t// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n\t\t\t// when the run function is dequeued and called. The comparison in the if-statement\n\t\t\t// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n\t\t\tawait Promise.resolve();\n\n\t\t\tif (activeCount < concurrency && queue.size > 0) {\n\t\t\t\tqueue.dequeue()();\n\t\t\t}\n\t\t})();\n\t};\n\n\tconst generator = (fn, ...args) => new Promise(resolve => {\n\t\tenqueue(fn, resolve, args);\n\t});\n\n\tObject.defineProperties(generator, {\n\t\tactiveCount: {\n\t\t\tget: () => activeCount,\n\t\t},\n\t\tpendingCount: {\n\t\t\tget: () => queue.size,\n\t\t},\n\t\tclearQueue: {\n\t\t\tvalue: () => {\n\t\t\t\tqueue.clear();\n\t\t\t},\n\t\t},\n\t});\n\n\treturn generator;\n}\n", "import * as cborg from 'cborg'\nimport { CID } from 'multiformats/cid'\n\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_CBOR_TAG = 42\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal.\n *\n * @param {any} obj\n * @returns {cborg.Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1)\n  bytes.set(cid.bytes, 1) // prefix is 0x00, for historical reasons\n  return [\n    new cborg.Token(cborg.Type.tag, CID_CBOR_TAG),\n    new cborg.Token(cborg.Type.bytes, bytes)\n  ]\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null\n}\n\nconst encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {CID}\n */\nfunction cidDecoder (bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00')\n  }\n  return CID.decode(bytes.subarray(1)) // ignore leading 0x00\n}\n\nconst decodeOptions = {\n  allowIndefinite: false,\n  coerceUndefinedToNull: true,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\ndecodeOptions.tags[CID_CBOR_TAG] = cidDecoder\n\nexport const name = 'dag-cbor'\nexport const code = 0x71\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborg.encode(node, encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => cborg.decode(data, decodeOptions)\n", "const typeofs = [\n  'string',\n  'number',\n  'bigint',\n  'symbol'\n];\nconst objectTypeNames = [\n  'Function',\n  'Generator',\n  'AsyncGenerator',\n  'GeneratorFunction',\n  'AsyncGeneratorFunction',\n  'AsyncFunction',\n  'Observable',\n  'Array',\n  'Buffer',\n  'Object',\n  'RegExp',\n  'Date',\n  'Error',\n  'Map',\n  'Set',\n  'WeakMap',\n  'WeakSet',\n  'ArrayBuffer',\n  'SharedArrayBuffer',\n  'DataView',\n  'Promise',\n  'URL',\n  'HTMLElement',\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Uint16Array',\n  'Int32Array',\n  'Uint32Array',\n  'Float32Array',\n  'Float64Array',\n  'BigInt64Array',\n  'BigUint64Array'\n];\nexport function is(value) {\n  if (value === null) {\n    return 'null';\n  }\n  if (value === undefined) {\n    return 'undefined';\n  }\n  if (value === true || value === false) {\n    return 'boolean';\n  }\n  const typeOf = typeof value;\n  if (typeofs.includes(typeOf)) {\n    return typeOf;\n  }\n  if (typeOf === 'function') {\n    return 'Function';\n  }\n  if (Array.isArray(value)) {\n    return 'Array';\n  }\n  if (isBuffer(value)) {\n    return 'Buffer';\n  }\n  const objectType = getObjectType(value);\n  if (objectType) {\n    return objectType;\n  }\n  return 'Object';\n}\nfunction isBuffer(value) {\n  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);\n}\nfunction getObjectType(value) {\n  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);\n  if (objectTypeNames.includes(objectTypeName)) {\n    return objectTypeName;\n  }\n  return undefined;\n}", "class Type {\n  constructor(major, name, terminal) {\n    this.major = major;\n    this.majorEncoded = major << 5;\n    this.name = name;\n    this.terminal = terminal;\n  }\n  toString() {\n    return `Type[${ this.major }].${ this.name }`;\n  }\n  compare(typ) {\n    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;\n  }\n}\nType.uint = new Type(0, 'uint', true);\nType.negint = new Type(1, 'negint', true);\nType.bytes = new Type(2, 'bytes', true);\nType.string = new Type(3, 'string', true);\nType.array = new Type(4, 'array', false);\nType.map = new Type(5, 'map', false);\nType.tag = new Type(6, 'tag', false);\nType.float = new Type(7, 'float', true);\nType.false = new Type(7, 'false', true);\nType.true = new Type(7, 'true', true);\nType.null = new Type(7, 'null', true);\nType.undefined = new Type(7, 'undefined', true);\nType.break = new Type(7, 'break', true);\nclass Token {\n  constructor(type, value, encodedLength) {\n    this.type = type;\n    this.value = value;\n    this.encodedLength = encodedLength;\n    this.encodedBytes = undefined;\n    this.byteValue = undefined;\n  }\n  toString() {\n    return `Token[${ this.type }].${ this.value }`;\n  }\n}\nexport {\n  Type,\n  Token\n};", "export const useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === 'function';\nconst textDecoder = new TextDecoder();\nconst textEncoder = new TextEncoder();\nfunction isBuffer(buf) {\n  return useBuffer && globalThis.Buffer.isBuffer(buf);\n}\nexport function asU8A(buf) {\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf);\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf;\n}\nexport const toString = useBuffer ? (bytes, start, end) => {\n  return end - start > 64 ? globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8') : utf8Slice(bytes, start, end);\n} : (bytes, start, end) => {\n  return end - start > 64 ? textDecoder.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);\n};\nexport const fromString = useBuffer ? string => {\n  return string.length > 64 ? globalThis.Buffer.from(string) : utf8ToBytes(string);\n} : string => {\n  return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string);\n};\nexport const fromArray = arr => {\n  return Uint8Array.from(arr);\n};\nexport const slice = useBuffer ? (bytes, start, end) => {\n  if (isBuffer(bytes)) {\n    return new Uint8Array(bytes.subarray(start, end));\n  }\n  return bytes.slice(start, end);\n} : (bytes, start, end) => {\n  return bytes.slice(start, end);\n};\nexport const concat = useBuffer ? (chunks, length) => {\n  chunks = chunks.map(c => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));\n  return asU8A(globalThis.Buffer.concat(chunks, length));\n} : (chunks, length) => {\n  const out = new Uint8Array(length);\n  let off = 0;\n  for (let b of chunks) {\n    if (off + b.length > out.length) {\n      b = b.subarray(0, out.length - off);\n    }\n    out.set(b, off);\n    off += b.length;\n  }\n  return out;\n};\nexport const alloc = useBuffer ? size => {\n  return globalThis.Buffer.allocUnsafe(size);\n} : size => {\n  return new Uint8Array(size);\n};\nexport const toHex = useBuffer ? d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  return globalThis.Buffer.from(toBytes(d)).toString('hex');\n} : d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  return Array.prototype.reduce.call(toBytes(d), (p, c) => `${ p }${ c.toString(16).padStart(2, '0') }`, '');\n};\nexport const fromHex = useBuffer ? hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  return globalThis.Buffer.from(hex, 'hex');\n} : hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  if (!hex.length) {\n    return new Uint8Array(0);\n  }\n  return new Uint8Array(hex.split('').map((c, i, d) => i % 2 === 0 ? `0x${ c }${ d[i + 1] }` : '').filter(Boolean).map(e => parseInt(e, 16)));\n};\nfunction toBytes(obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj;\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj);\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n}\nexport function compare(b1, b2) {\n  if (isBuffer(b1) && isBuffer(b2)) {\n    return b1.compare(b2);\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue;\n    }\n    return b1[i] < b2[i] ? -1 : 1;\n  }\n  return 0;\n}\nfunction utf8ToBytes(string, units = Infinity) {\n  let codePoint;\n  const length = string.length;\n  let leadSurrogate = null;\n  const bytes = [];\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n    if (codePoint > 55295 && codePoint < 57344) {\n      if (!leadSurrogate) {\n        if (codePoint > 56319) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n          continue;\n        } else if (i + 1 === length) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n          continue;\n        }\n        leadSurrogate = codePoint;\n        continue;\n      }\n      if (codePoint < 56320) {\n        if ((units -= 3) > -1)\n          bytes.push(239, 191, 189);\n        leadSurrogate = codePoint;\n        continue;\n      }\n      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n    } else if (leadSurrogate) {\n      if ((units -= 3) > -1)\n        bytes.push(239, 191, 189);\n    }\n    leadSurrogate = null;\n    if (codePoint < 128) {\n      if ((units -= 1) < 0)\n        break;\n      bytes.push(codePoint);\n    } else if (codePoint < 2048) {\n      if ((units -= 2) < 0)\n        break;\n      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n    } else if (codePoint < 65536) {\n      if ((units -= 3) < 0)\n        break;\n      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else if (codePoint < 1114112) {\n      if ((units -= 4) < 0)\n        break;\n      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n  return bytes;\n}\nfunction utf8Slice(buf, offset, end) {\n  const res = [];\n  while (offset < end) {\n    const firstByte = buf[offset];\n    let codePoint = null;\n    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint;\n      switch (bytesPerSequence) {\n      case 1:\n        if (firstByte < 128) {\n          codePoint = firstByte;\n        }\n        break;\n      case 2:\n        secondByte = buf[offset + 1];\n        if ((secondByte & 192) === 128) {\n          tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n          if (tempCodePoint > 127) {\n            codePoint = tempCodePoint;\n          }\n        }\n        break;\n      case 3:\n        secondByte = buf[offset + 1];\n        thirdByte = buf[offset + 2];\n        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n          tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n          if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n            codePoint = tempCodePoint;\n          }\n        }\n        break;\n      case 4:\n        secondByte = buf[offset + 1];\n        thirdByte = buf[offset + 2];\n        fourthByte = buf[offset + 3];\n        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n          tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n          if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n            codePoint = tempCodePoint;\n          }\n        }\n      }\n    }\n    if (codePoint === null) {\n      codePoint = 65533;\n      bytesPerSequence = 1;\n    } else if (codePoint > 65535) {\n      codePoint -= 65536;\n      res.push(codePoint >>> 10 & 1023 | 55296);\n      codePoint = 56320 | codePoint & 1023;\n    }\n    res.push(codePoint);\n    offset += bytesPerSequence;\n  }\n  return decodeCodePointsArray(res);\n}\nconst MAX_ARGUMENTS_LENGTH = 4096;\nexport function decodeCodePointsArray(codePoints) {\n  const len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints);\n  }\n  let res = '';\n  let i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n  return res;\n}", "import {\n  alloc,\n  concat,\n  slice\n} from './byte-utils.js';\nconst defaultChunkSize = 256;\nexport class Bl {\n  constructor(chunkSize = defaultChunkSize) {\n    this.chunkSize = chunkSize;\n    this.cursor = 0;\n    this.maxCursor = -1;\n    this.chunks = [];\n    this._initReuseChunk = null;\n  }\n  reset() {\n    this.cursor = 0;\n    this.maxCursor = -1;\n    if (this.chunks.length) {\n      this.chunks = [];\n    }\n    if (this._initReuseChunk !== null) {\n      this.chunks.push(this._initReuseChunk);\n      this.maxCursor = this._initReuseChunk.length - 1;\n    }\n  }\n  push(bytes) {\n    let topChunk = this.chunks[this.chunks.length - 1];\n    const newMax = this.cursor + bytes.length;\n    if (newMax <= this.maxCursor + 1) {\n      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;\n      topChunk.set(bytes, chunkPos);\n    } else {\n      if (topChunk) {\n        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;\n        if (chunkPos < topChunk.length) {\n          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);\n          this.maxCursor = this.cursor - 1;\n        }\n      }\n      if (bytes.length < 64 && bytes.length < this.chunkSize) {\n        topChunk = alloc(this.chunkSize);\n        this.chunks.push(topChunk);\n        this.maxCursor += topChunk.length;\n        if (this._initReuseChunk === null) {\n          this._initReuseChunk = topChunk;\n        }\n        topChunk.set(bytes, 0);\n      } else {\n        this.chunks.push(bytes);\n        this.maxCursor += bytes.length;\n      }\n    }\n    this.cursor += bytes.length;\n  }\n  toBytes(reset = false) {\n    let byts;\n    if (this.chunks.length === 1) {\n      const chunk = this.chunks[0];\n      if (reset && this.cursor > chunk.length / 2) {\n        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);\n        this._initReuseChunk = null;\n        this.chunks = [];\n      } else {\n        byts = slice(chunk, 0, this.cursor);\n      }\n    } else {\n      byts = concat(this.chunks, this.cursor);\n    }\n    if (reset) {\n      this.reset();\n    }\n    return byts;\n  }\n}", "const decodeErrPrefix = 'CBOR decode error:';\nconst encodeErrPrefix = 'CBOR encode error:';\nconst uintMinorPrefixBytes = [];\nuintMinorPrefixBytes[23] = 1;\nuintMinorPrefixBytes[24] = 2;\nuintMinorPrefixBytes[25] = 3;\nuintMinorPrefixBytes[26] = 5;\nuintMinorPrefixBytes[27] = 9;\nfunction assertEnoughData(data, pos, need) {\n  if (data.length - pos < need) {\n    throw new Error(`${ decodeErrPrefix } not enough data for type`);\n  }\n}\nexport {\n  decodeErrPrefix,\n  encodeErrPrefix,\n  uintMinorPrefixBytes,\n  assertEnoughData\n};", "import {\n  Token,\n  Type\n} from './token.js';\nimport {\n  decodeErrPrefix,\n  assertEnoughData\n} from './common.js';\nexport const uintBoundaries = [\n  24,\n  256,\n  65536,\n  4294967296,\n  BigInt('18446744073709551616')\n];\nexport function readUint8(data, offset, options) {\n  assertEnoughData(data, offset, 1);\n  const value = data[offset];\n  if (options.strict === true && value < uintBoundaries[0]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\nexport function readUint16(data, offset, options) {\n  assertEnoughData(data, offset, 2);\n  const value = data[offset] << 8 | data[offset + 1];\n  if (options.strict === true && value < uintBoundaries[1]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\nexport function readUint32(data, offset, options) {\n  assertEnoughData(data, offset, 4);\n  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];\n  if (options.strict === true && value < uintBoundaries[2]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\nexport function readUint64(data, offset, options) {\n  assertEnoughData(data, offset, 8);\n  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];\n  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];\n  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);\n  if (options.strict === true && value < uintBoundaries[3]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  if (value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value);\n  }\n  if (options.allowBigInt === true) {\n    return value;\n  }\n  throw new Error(`${ decodeErrPrefix } integers outside of the safe integer range are not supported`);\n}\nexport function decodeUint8(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);\n}\nexport function decodeUint16(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);\n}\nexport function decodeUint32(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);\n}\nexport function decodeUint64(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);\n}\nexport function encodeUint(buf, token) {\n  return encodeUintValue(buf, 0, token.value);\n}\nexport function encodeUintValue(buf, major, uint) {\n  if (uint < uintBoundaries[0]) {\n    const nuint = Number(uint);\n    buf.push([major | nuint]);\n  } else if (uint < uintBoundaries[1]) {\n    const nuint = Number(uint);\n    buf.push([\n      major | 24,\n      nuint\n    ]);\n  } else if (uint < uintBoundaries[2]) {\n    const nuint = Number(uint);\n    buf.push([\n      major | 25,\n      nuint >>> 8,\n      nuint & 255\n    ]);\n  } else if (uint < uintBoundaries[3]) {\n    const nuint = Number(uint);\n    buf.push([\n      major | 26,\n      nuint >>> 24 & 255,\n      nuint >>> 16 & 255,\n      nuint >>> 8 & 255,\n      nuint & 255\n    ]);\n  } else {\n    const buint = BigInt(uint);\n    if (buint < uintBoundaries[4]) {\n      const set = [\n        major | 27,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0\n      ];\n      let lo = Number(buint & BigInt(4294967295));\n      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));\n      set[8] = lo & 255;\n      lo = lo >> 8;\n      set[7] = lo & 255;\n      lo = lo >> 8;\n      set[6] = lo & 255;\n      lo = lo >> 8;\n      set[5] = lo & 255;\n      set[4] = hi & 255;\n      hi = hi >> 8;\n      set[3] = hi & 255;\n      hi = hi >> 8;\n      set[2] = hi & 255;\n      hi = hi >> 8;\n      set[1] = hi & 255;\n      buf.push(set);\n    } else {\n      throw new Error(`${ decodeErrPrefix } encountered BigInt larger than allowable range`);\n    }\n  }\n}\nencodeUint.encodedSize = function encodedSize(token) {\n  return encodeUintValue.encodedSize(token.value);\n};\nencodeUintValue.encodedSize = function encodedSize(uint) {\n  if (uint < uintBoundaries[0]) {\n    return 1;\n  }\n  if (uint < uintBoundaries[1]) {\n    return 2;\n  }\n  if (uint < uintBoundaries[2]) {\n    return 3;\n  }\n  if (uint < uintBoundaries[3]) {\n    return 5;\n  }\n  return 9;\n};\nencodeUint.compareTokens = function compareTokens(tok1, tok2) {\n  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;\n};", "import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\nexport function decodeNegint8(data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint8(data, pos + 1, options), 2);\n}\nexport function decodeNegint16(data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint16(data, pos + 1, options), 3);\n}\nexport function decodeNegint32(data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint32(data, pos + 1, options), 5);\n}\nconst neg1b = BigInt(-1);\nconst pos1b = BigInt(1);\nexport function decodeNegint64(data, pos, _minor, options) {\n  const int = uint.readUint64(data, pos + 1, options);\n  if (typeof int !== 'bigint') {\n    const value = -1 - int;\n    if (value >= Number.MIN_SAFE_INTEGER) {\n      return new Token(Type.negint, value, 9);\n    }\n  }\n  if (options.allowBigInt !== true) {\n    throw new Error(`${ decodeErrPrefix } integers outside of the safe integer range are not supported`);\n  }\n  return new Token(Type.negint, neg1b - BigInt(int), 9);\n}\nexport function encodeNegint(buf, token) {\n  const negint = token.value;\n  const unsigned = typeof negint === 'bigint' ? negint * neg1b - pos1b : negint * -1 - 1;\n  uint.encodeUintValue(buf, token.type.majorEncoded, unsigned);\n}\nencodeNegint.encodedSize = function encodedSize(token) {\n  const negint = token.value;\n  const unsigned = typeof negint === 'bigint' ? negint * neg1b - pos1b : negint * -1 - 1;\n  if (unsigned < uint.uintBoundaries[0]) {\n    return 1;\n  }\n  if (unsigned < uint.uintBoundaries[1]) {\n    return 2;\n  }\n  if (unsigned < uint.uintBoundaries[2]) {\n    return 3;\n  }\n  if (unsigned < uint.uintBoundaries[3]) {\n    return 5;\n  }\n  return 9;\n};\nencodeNegint.compareTokens = function compareTokens(tok1, tok2) {\n  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;\n};", "import {\n  Token,\n  Type\n} from './token.js';\nimport {\n  assertEnoughData,\n  decodeErrPrefix\n} from './common.js';\nimport * as uint from './0uint.js';\nimport {\n  compare,\n  fromString,\n  slice\n} from './byte-utils.js';\nfunction toToken(data, pos, prefix, length) {\n  assertEnoughData(data, pos, prefix + length);\n  const buf = slice(data, pos + prefix, pos + prefix + length);\n  return new Token(Type.bytes, buf, prefix + length);\n}\nexport function decodeBytesCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeBytes8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeBytes16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeBytes32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeBytes64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer bytes lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nfunction tokenBytes(token) {\n  if (token.encodedBytes === undefined) {\n    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value;\n  }\n  return token.encodedBytes;\n}\nexport function encodeBytes(buf, token) {\n  const bytes = tokenBytes(token);\n  uint.encodeUintValue(buf, token.type.majorEncoded, bytes.length);\n  buf.push(bytes);\n}\nencodeBytes.encodedSize = function encodedSize(token) {\n  const bytes = tokenBytes(token);\n  return uint.encodeUintValue.encodedSize(bytes.length) + bytes.length;\n};\nencodeBytes.compareTokens = function compareTokens(tok1, tok2) {\n  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));\n};\nexport function compareBytes(b1, b2) {\n  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);\n}", "import {\n  Token,\n  Type\n} from './token.js';\nimport {\n  assertEnoughData,\n  decodeErrPrefix\n} from './common.js';\nimport * as uint from './0uint.js';\nimport { encodeBytes } from './2bytes.js';\nimport {\n  toString,\n  slice\n} from './byte-utils.js';\nfunction toToken(data, pos, prefix, length, options) {\n  const totLength = prefix + length;\n  assertEnoughData(data, pos, totLength);\n  const tok = new Token(Type.string, toString(data, pos + prefix, pos + totLength), totLength);\n  if (options.retainStringBytes === true) {\n    tok.byteValue = slice(data, pos + prefix, pos + totLength);\n  }\n  return tok;\n}\nexport function decodeStringCompact(data, pos, minor, options) {\n  return toToken(data, pos, 1, minor, options);\n}\nexport function decodeString8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options), options);\n}\nexport function decodeString16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options), options);\n}\nexport function decodeString32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options), options);\n}\nexport function decodeString64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer string lengths not supported`);\n  }\n  return toToken(data, pos, 9, l, options);\n}\nexport const encodeString = encodeBytes;", "import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\nfunction toToken(_data, _pos, prefix, length) {\n  return new Token(Type.array, length, prefix);\n}\nexport function decodeArrayCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeArray8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeArray16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeArray32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeArray64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer array lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nexport function decodeArrayIndefinite(data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${ decodeErrPrefix } indefinite length items not allowed`);\n  }\n  return toToken(data, pos, 1, Infinity);\n}\nexport function encodeArray(buf, token) {\n  uint.encodeUintValue(buf, Type.array.majorEncoded, token.value);\n}\nencodeArray.compareTokens = uint.encodeUint.compareTokens;\nencodeArray.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};", "import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\nfunction toToken(_data, _pos, prefix, length) {\n  return new Token(Type.map, length, prefix);\n}\nexport function decodeMapCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeMap8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeMap16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeMap32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeMap64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer map lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nexport function decodeMapIndefinite(data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${ decodeErrPrefix } indefinite length items not allowed`);\n  }\n  return toToken(data, pos, 1, Infinity);\n}\nexport function encodeMap(buf, token) {\n  uint.encodeUintValue(buf, Type.map.majorEncoded, token.value);\n}\nencodeMap.compareTokens = uint.encodeUint.compareTokens;\nencodeMap.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};", "import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nexport function decodeTagCompact(_data, _pos, minor, _options) {\n  return new Token(Type.tag, minor, 1);\n}\nexport function decodeTag8(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint8(data, pos + 1, options), 2);\n}\nexport function decodeTag16(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint16(data, pos + 1, options), 3);\n}\nexport function decodeTag32(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint32(data, pos + 1, options), 5);\n}\nexport function decodeTag64(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint64(data, pos + 1, options), 9);\n}\nexport function encodeTag(buf, token) {\n  uint.encodeUintValue(buf, Type.tag.majorEncoded, token.value);\n}\nencodeTag.compareTokens = uint.encodeUint.compareTokens;\nencodeTag.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};", "import {\n  Token,\n  Type\n} from './token.js';\nimport { decodeErrPrefix } from './common.js';\nimport { encodeUint } from './0uint.js';\nconst MINOR_FALSE = 20;\nconst MINOR_TRUE = 21;\nconst MINOR_NULL = 22;\nconst MINOR_UNDEFINED = 23;\nexport function decodeUndefined(_data, _pos, _minor, options) {\n  if (options.allowUndefined === false) {\n    throw new Error(`${ decodeErrPrefix } undefined values are not supported`);\n  } else if (options.coerceUndefinedToNull === true) {\n    return new Token(Type.null, null, 1);\n  }\n  return new Token(Type.undefined, undefined, 1);\n}\nexport function decodeBreak(_data, _pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${ decodeErrPrefix } indefinite length items not allowed`);\n  }\n  return new Token(Type.break, undefined, 1);\n}\nfunction createToken(value, bytes, options) {\n  if (options) {\n    if (options.allowNaN === false && Number.isNaN(value)) {\n      throw new Error(`${ decodeErrPrefix } NaN values are not supported`);\n    }\n    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {\n      throw new Error(`${ decodeErrPrefix } Infinity values are not supported`);\n    }\n  }\n  return new Token(Type.float, value, bytes);\n}\nexport function decodeFloat16(data, pos, _minor, options) {\n  return createToken(readFloat16(data, pos + 1), 3, options);\n}\nexport function decodeFloat32(data, pos, _minor, options) {\n  return createToken(readFloat32(data, pos + 1), 5, options);\n}\nexport function decodeFloat64(data, pos, _minor, options) {\n  return createToken(readFloat64(data, pos + 1), 9, options);\n}\nexport function encodeFloat(buf, token, options) {\n  const float = token.value;\n  if (float === false) {\n    buf.push([Type.float.majorEncoded | MINOR_FALSE]);\n  } else if (float === true) {\n    buf.push([Type.float.majorEncoded | MINOR_TRUE]);\n  } else if (float === null) {\n    buf.push([Type.float.majorEncoded | MINOR_NULL]);\n  } else if (float === undefined) {\n    buf.push([Type.float.majorEncoded | MINOR_UNDEFINED]);\n  } else {\n    let decoded;\n    let success = false;\n    if (!options || options.float64 !== true) {\n      encodeFloat16(float);\n      decoded = readFloat16(ui8a, 1);\n      if (float === decoded || Number.isNaN(float)) {\n        ui8a[0] = 249;\n        buf.push(ui8a.slice(0, 3));\n        success = true;\n      } else {\n        encodeFloat32(float);\n        decoded = readFloat32(ui8a, 1);\n        if (float === decoded) {\n          ui8a[0] = 250;\n          buf.push(ui8a.slice(0, 5));\n          success = true;\n        }\n      }\n    }\n    if (!success) {\n      encodeFloat64(float);\n      decoded = readFloat64(ui8a, 1);\n      ui8a[0] = 251;\n      buf.push(ui8a.slice(0, 9));\n    }\n  }\n}\nencodeFloat.encodedSize = function encodedSize(token, options) {\n  const float = token.value;\n  if (float === false || float === true || float === null || float === undefined) {\n    return 1;\n  }\n  if (!options || options.float64 !== true) {\n    encodeFloat16(float);\n    let decoded = readFloat16(ui8a, 1);\n    if (float === decoded || Number.isNaN(float)) {\n      return 3;\n    }\n    encodeFloat32(float);\n    decoded = readFloat32(ui8a, 1);\n    if (float === decoded) {\n      return 5;\n    }\n  }\n  return 9;\n};\nconst buffer = new ArrayBuffer(9);\nconst dataView = new DataView(buffer, 1);\nconst ui8a = new Uint8Array(buffer, 0);\nfunction encodeFloat16(inp) {\n  if (inp === Infinity) {\n    dataView.setUint16(0, 31744, false);\n  } else if (inp === -Infinity) {\n    dataView.setUint16(0, 64512, false);\n  } else if (Number.isNaN(inp)) {\n    dataView.setUint16(0, 32256, false);\n  } else {\n    dataView.setFloat32(0, inp);\n    const valu32 = dataView.getUint32(0);\n    const exponent = (valu32 & 2139095040) >> 23;\n    const mantissa = valu32 & 8388607;\n    if (exponent === 255) {\n      dataView.setUint16(0, 31744, false);\n    } else if (exponent === 0) {\n      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);\n    } else {\n      const logicalExponent = exponent - 127;\n      if (logicalExponent < -24) {\n        dataView.setUint16(0, 0);\n      } else if (logicalExponent < -14) {\n        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);\n      } else {\n        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);\n      }\n    }\n  }\n}\nfunction readFloat16(ui8a, pos) {\n  if (ui8a.length - pos < 2) {\n    throw new Error(`${ decodeErrPrefix } not enough data for float16`);\n  }\n  const half = (ui8a[pos] << 8) + ui8a[pos + 1];\n  if (half === 31744) {\n    return Infinity;\n  }\n  if (half === 64512) {\n    return -Infinity;\n  }\n  if (half === 32256) {\n    return NaN;\n  }\n  const exp = half >> 10 & 31;\n  const mant = half & 1023;\n  let val;\n  if (exp === 0) {\n    val = mant * 2 ** -24;\n  } else if (exp !== 31) {\n    val = (mant + 1024) * 2 ** (exp - 25);\n  } else {\n    val = mant === 0 ? Infinity : NaN;\n  }\n  return half & 32768 ? -val : val;\n}\nfunction encodeFloat32(inp) {\n  dataView.setFloat32(0, inp, false);\n}\nfunction readFloat32(ui8a, pos) {\n  if (ui8a.length - pos < 4) {\n    throw new Error(`${ decodeErrPrefix } not enough data for float32`);\n  }\n  const offset = (ui8a.byteOffset || 0) + pos;\n  return new DataView(ui8a.buffer, offset, 4).getFloat32(0, false);\n}\nfunction encodeFloat64(inp) {\n  dataView.setFloat64(0, inp, false);\n}\nfunction readFloat64(ui8a, pos) {\n  if (ui8a.length - pos < 8) {\n    throw new Error(`${ decodeErrPrefix } not enough data for float64`);\n  }\n  const offset = (ui8a.byteOffset || 0) + pos;\n  return new DataView(ui8a.buffer, offset, 8).getFloat64(0, false);\n}\nencodeFloat.compareTokens = encodeUint.compareTokens;", "import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport * as negint from './1negint.js';\nimport * as bytes from './2bytes.js';\nimport * as string from './3string.js';\nimport * as array from './4array.js';\nimport * as map from './5map.js';\nimport * as tag from './6tag.js';\nimport * as float from './7float.js';\nimport { decodeErrPrefix } from './common.js';\nimport { fromArray } from './byte-utils.js';\nfunction invalidMinor(data, pos, minor) {\n  throw new Error(`${ decodeErrPrefix } encountered invalid minor (${ minor }) for major ${ data[pos] >>> 5 }`);\n}\nfunction errorer(msg) {\n  return () => {\n    throw new Error(`${ decodeErrPrefix } ${ msg }`);\n  };\n}\nexport const jump = [];\nfor (let i = 0; i <= 23; i++) {\n  jump[i] = invalidMinor;\n}\njump[24] = uint.decodeUint8;\njump[25] = uint.decodeUint16;\njump[26] = uint.decodeUint32;\njump[27] = uint.decodeUint64;\njump[28] = invalidMinor;\njump[29] = invalidMinor;\njump[30] = invalidMinor;\njump[31] = invalidMinor;\nfor (let i = 32; i <= 55; i++) {\n  jump[i] = invalidMinor;\n}\njump[56] = negint.decodeNegint8;\njump[57] = negint.decodeNegint16;\njump[58] = negint.decodeNegint32;\njump[59] = negint.decodeNegint64;\njump[60] = invalidMinor;\njump[61] = invalidMinor;\njump[62] = invalidMinor;\njump[63] = invalidMinor;\nfor (let i = 64; i <= 87; i++) {\n  jump[i] = bytes.decodeBytesCompact;\n}\njump[88] = bytes.decodeBytes8;\njump[89] = bytes.decodeBytes16;\njump[90] = bytes.decodeBytes32;\njump[91] = bytes.decodeBytes64;\njump[92] = invalidMinor;\njump[93] = invalidMinor;\njump[94] = invalidMinor;\njump[95] = errorer('indefinite length bytes/strings are not supported');\nfor (let i = 96; i <= 119; i++) {\n  jump[i] = string.decodeStringCompact;\n}\njump[120] = string.decodeString8;\njump[121] = string.decodeString16;\njump[122] = string.decodeString32;\njump[123] = string.decodeString64;\njump[124] = invalidMinor;\njump[125] = invalidMinor;\njump[126] = invalidMinor;\njump[127] = errorer('indefinite length bytes/strings are not supported');\nfor (let i = 128; i <= 151; i++) {\n  jump[i] = array.decodeArrayCompact;\n}\njump[152] = array.decodeArray8;\njump[153] = array.decodeArray16;\njump[154] = array.decodeArray32;\njump[155] = array.decodeArray64;\njump[156] = invalidMinor;\njump[157] = invalidMinor;\njump[158] = invalidMinor;\njump[159] = array.decodeArrayIndefinite;\nfor (let i = 160; i <= 183; i++) {\n  jump[i] = map.decodeMapCompact;\n}\njump[184] = map.decodeMap8;\njump[185] = map.decodeMap16;\njump[186] = map.decodeMap32;\njump[187] = map.decodeMap64;\njump[188] = invalidMinor;\njump[189] = invalidMinor;\njump[190] = invalidMinor;\njump[191] = map.decodeMapIndefinite;\nfor (let i = 192; i <= 215; i++) {\n  jump[i] = tag.decodeTagCompact;\n}\njump[216] = tag.decodeTag8;\njump[217] = tag.decodeTag16;\njump[218] = tag.decodeTag32;\njump[219] = tag.decodeTag64;\njump[220] = invalidMinor;\njump[221] = invalidMinor;\njump[222] = invalidMinor;\njump[223] = invalidMinor;\nfor (let i = 224; i <= 243; i++) {\n  jump[i] = errorer('simple values are not supported');\n}\njump[244] = invalidMinor;\njump[245] = invalidMinor;\njump[246] = invalidMinor;\njump[247] = float.decodeUndefined;\njump[248] = errorer('simple values are not supported');\njump[249] = float.decodeFloat16;\njump[250] = float.decodeFloat32;\njump[251] = float.decodeFloat64;\njump[252] = invalidMinor;\njump[253] = invalidMinor;\njump[254] = invalidMinor;\njump[255] = float.decodeBreak;\nexport const quick = [];\nfor (let i = 0; i < 24; i++) {\n  quick[i] = new Token(Type.uint, i, 1);\n}\nfor (let i = -1; i >= -24; i--) {\n  quick[31 - i] = new Token(Type.negint, i, 1);\n}\nquick[64] = new Token(Type.bytes, new Uint8Array(0), 1);\nquick[96] = new Token(Type.string, '', 1);\nquick[128] = new Token(Type.array, 0, 1);\nquick[160] = new Token(Type.map, 0, 1);\nquick[244] = new Token(Type.false, false, 1);\nquick[245] = new Token(Type.true, true, 1);\nquick[246] = new Token(Type.null, null, 1);\nexport function quickEncodeToken(token) {\n  switch (token.type) {\n  case Type.false:\n    return fromArray([244]);\n  case Type.true:\n    return fromArray([245]);\n  case Type.null:\n    return fromArray([246]);\n  case Type.bytes:\n    if (!token.value.length) {\n      return fromArray([64]);\n    }\n    return;\n  case Type.string:\n    if (token.value === '') {\n      return fromArray([96]);\n    }\n    return;\n  case Type.array:\n    if (token.value === 0) {\n      return fromArray([128]);\n    }\n    return;\n  case Type.map:\n    if (token.value === 0) {\n      return fromArray([160]);\n    }\n    return;\n  case Type.uint:\n    if (token.value < 24) {\n      return fromArray([Number(token.value)]);\n    }\n    return;\n  case Type.negint:\n    if (token.value >= -24) {\n      return fromArray([31 - Number(token.value)]);\n    }\n  }\n}", "import { is } from './is.js';\nimport {\n  Token,\n  Type\n} from './token.js';\nimport { Bl } from './bl.js';\nimport { encodeErrPrefix } from './common.js';\nimport { quickEncodeToken } from './jump.js';\nimport { asU8A } from './byte-utils.js';\nimport { encodeUint } from './0uint.js';\nimport { encodeNegint } from './1negint.js';\nimport { encodeBytes } from './2bytes.js';\nimport { encodeString } from './3string.js';\nimport { encodeArray } from './4array.js';\nimport { encodeMap } from './5map.js';\nimport { encodeTag } from './6tag.js';\nimport { encodeFloat } from './7float.js';\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n};\nexport function makeCborEncoders() {\n  const encoders = [];\n  encoders[Type.uint.major] = encodeUint;\n  encoders[Type.negint.major] = encodeNegint;\n  encoders[Type.bytes.major] = encodeBytes;\n  encoders[Type.string.major] = encodeString;\n  encoders[Type.array.major] = encodeArray;\n  encoders[Type.map.major] = encodeMap;\n  encoders[Type.tag.major] = encodeTag;\n  encoders[Type.float.major] = encodeFloat;\n  return encoders;\n}\nconst cborEncoders = makeCborEncoders();\nconst buf = new Bl();\nclass Ref {\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n  includes(obj) {\n    let p = this;\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent);\n    return false;\n  }\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${ encodeErrPrefix } object contains circular references`);\n    }\n    return new Ref(obj, stack);\n  }\n}\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n};\nconst typeEncoders = {\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj);\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj);\n  },\n  string(obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj);\n  },\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj));\n  },\n  DataView(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyArray,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyArray;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.array, obj.length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.array, obj.length),\n      entries\n    ];\n  },\n  Object(obj, typ, options, refStack) {\n    const isMap = typ !== 'Object';\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyMap,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyMap;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ];\n    }\n    sortMapEntries(entries, options);\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.map, length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.map, length),\n      entries\n    ];\n  }\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${ typ }Array`] = typeEncoders.DataView;\n}\nfunction objectToTokens(obj, options = {}, refStack) {\n  const typ = is(obj);\n  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n  const typeEncoder = typeEncoders[typ];\n  if (!typeEncoder) {\n    throw new Error(`${ encodeErrPrefix } unsupported type: ${ typ }`);\n  }\n  return typeEncoder(obj, typ, options, refStack);\n}\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\nfunction mapSorter(e1, e2) {\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n  const major = keyToken1.type.major;\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n  return tcmp;\n}\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n    if (quickBytes) {\n      return quickBytes;\n    }\n    const encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new Bl(size);\n      encoder(buf, tokens, options);\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${ tokens } was wrong`);\n      }\n      return asU8A(buf.chunks[0]);\n    }\n  }\n  buf.reset();\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\nexport {\n  objectToTokens,\n  encode,\n  encodeCustom,\n  Ref\n};", "import { decodeErrPrefix } from './common.js';\nimport { Type } from './token.js';\nimport {\n  jump,\n  quick\n} from './jump.js';\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n};\nclass Tokeniser {\n  constructor(data, options = {}) {\n    this.pos = 0;\n    this.data = data;\n    this.options = options;\n  }\n  done() {\n    return this.pos >= this.data.length;\n  }\n  next() {\n    const byt = this.data[this.pos];\n    let token = quick[byt];\n    if (token === undefined) {\n      const decoder = jump[byt];\n      if (!decoder) {\n        throw new Error(`${ decodeErrPrefix } no decoder for major type ${ byt >>> 5 } (byte 0x${ byt.toString(16).padStart(2, '0') })`);\n      }\n      const minor = byt & 31;\n      token = decoder(this.data, this.pos, minor, this.options);\n    }\n    this.pos += token.encodedLength;\n    return token;\n  }\n}\nconst DONE = Symbol.for('DONE');\nconst BREAK = Symbol.for('BREAK');\nfunction tokenToArray(token, tokeniser, options) {\n  const arr = [];\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options);\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        break;\n      }\n      throw new Error(`${ decodeErrPrefix } got unexpected break to lengthed array`);\n    }\n    if (value === DONE) {\n      throw new Error(`${ decodeErrPrefix } found array but not enough entries (got ${ i }, expected ${ token.value })`);\n    }\n    arr[i] = value;\n  }\n  return arr;\n}\nfunction tokenToMap(token, tokeniser, options) {\n  const useMaps = options.useMaps === true;\n  const obj = useMaps ? undefined : {};\n  const m = useMaps ? new Map() : undefined;\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options);\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        break;\n      }\n      throw new Error(`${ decodeErrPrefix } got unexpected break to lengthed map`);\n    }\n    if (key === DONE) {\n      throw new Error(`${ decodeErrPrefix } found map but not enough entries (got ${ i } [no key], expected ${ token.value })`);\n    }\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${ decodeErrPrefix } non-string keys not supported (got ${ typeof key })`);\n    }\n    if (options.rejectDuplicateMapKeys === true) {\n      if (useMaps && m.has(key) || !useMaps && key in obj) {\n        throw new Error(`${ decodeErrPrefix } found repeat map key \"${ key }\"`);\n      }\n    }\n    const value = tokensToObject(tokeniser, options);\n    if (value === DONE) {\n      throw new Error(`${ decodeErrPrefix } found map but not enough entries (got ${ i } [no value], expected ${ token.value })`);\n    }\n    if (useMaps) {\n      m.set(key, value);\n    } else {\n      obj[key] = value;\n    }\n  }\n  return useMaps ? m : obj;\n}\nfunction tokensToObject(tokeniser, options) {\n  if (tokeniser.done()) {\n    return DONE;\n  }\n  const token = tokeniser.next();\n  if (token.type === Type.break) {\n    return BREAK;\n  }\n  if (token.type.terminal) {\n    return token.value;\n  }\n  if (token.type === Type.array) {\n    return tokenToArray(token, tokeniser, options);\n  }\n  if (token.type === Type.map) {\n    return tokenToMap(token, tokeniser, options);\n  }\n  if (token.type === Type.tag) {\n    if (options.tags && typeof options.tags[token.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options);\n      return options.tags[token.value](tagged);\n    }\n    throw new Error(`${ decodeErrPrefix } tag not supported (${ token.value })`);\n  }\n  throw new Error('unsupported');\n}\nfunction decode(data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${ decodeErrPrefix } data to decode must be a Uint8Array`);\n  }\n  options = Object.assign({}, defaultDecodeOptions, options);\n  const tokeniser = options.tokenizer || new Tokeniser(data, options);\n  const decoded = tokensToObject(tokeniser, options);\n  if (decoded === DONE) {\n    throw new Error(`${ decodeErrPrefix } did not find any content to decode`);\n  }\n  if (decoded === BREAK) {\n    throw new Error(`${ decodeErrPrefix } got unexpected break`);\n  }\n  if (!tokeniser.done()) {\n    throw new Error(`${ decodeErrPrefix } too many terminals, data makes no sense`);\n  }\n  return decoded;\n}\nexport {\n  Tokeniser,\n  tokensToObject,\n  decode\n};", "var encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import varint from '../vendor/varint.js'\n\n/**\n * @param {Uint8Array} data\n * @param {number} [offset=0]\n * @returns {[number, number]}\n */\nexport const decode = (data, offset = 0) => {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\n/**\n * @param {number} int\n * @param {Uint8Array} target\n * @param {number} [offset=0]\n */\nexport const encodeTo = (int, target, offset = 0) => {\n  varint.encode(int, target, offset)\n  return target\n}\n\n/**\n * @param {number} int\n * @returns {number}\n */\nexport const encodingLength = (int) => {\n  return varint.encodingLength(int)\n}\n", "const empty = new Uint8Array(0)\n\n/**\n * @param {Uint8Array} d\n */\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n\n/**\n * @param {string} hex\n */\nconst fromHex = hex => {\n  const hexes = hex.match(/../g)\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\n/**\n * @param {Uint8Array} aa\n * @param {Uint8Array} bb\n */\nconst equals = (aa, bb) => {\n  if (aa === bb) return true\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {ArrayBufferView|ArrayBuffer|Uint8Array} o\n * @returns {Uint8Array}\n */\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o\n  if (o instanceof ArrayBuffer) return new Uint8Array(o)\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {any} o\n * @returns {o is ArrayBuffer|ArrayBufferView}\n */\nconst isBinary = o =>\n  o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nconst fromString = str => (new TextEncoder()).encode(str)\n\n/**\n * @param {Uint8Array} b\n * @returns {string}\n */\nconst toString = b => (new TextDecoder()).decode(b)\n\nexport { equals, coerce, isBinary, fromHex, toHex, fromString, toString, empty }\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\n\n/**\n * Creates a multihash digest.\n *\n * @template {number} Code\n * @param {Code} code\n * @param {Uint8Array} digest\n */\nexport const create = (code, digest) => {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n *\n * @param {Uint8Array} multihash\n * @returns {MultihashDigest}\n */\nexport const decode = (multihash) => {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * @param {MultihashDigest} a\n * @param {unknown} b\n * @returns {b is MultihashDigest}\n */\nexport const equals = (a, b) => {\n  if (a === b) {\n    return true\n  } else {\n    const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */(b)\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * @typedef {import('./interface.js').MultihashDigest} MultihashDigest\n */\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n *\n * @template {number} Code\n * @template {number} Size\n * @class\n * @implements {MultihashDigest}\n */\nexport class Digest {\n  /**\n   * Creates a multihash digest.\n   *\n   * @param {Code} code\n   * @param {Size} size\n   * @param {Uint8Array} digest\n   * @param {Uint8Array} bytes\n   */\n  constructor (code, size, digest, bytes) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n", "// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "import basex from '../../vendor/base-x.js'\nimport { coerce } from '../bytes.js'\n// Linter can't see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.BaseEncoder}\n */\nclass Encoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   */\n  constructor (name, prefix, baseEncode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {API.Multibase<Prefix>}\n   */\n  encode (bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * @template {string} Prefix\n */\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n *\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.UnibaseDecoder<Prefix>}\n * @implements {API.BaseDecoder}\n */\nclass Decoder {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    /* c8 ignore next 3 */\n    if (prefix.codePointAt(0) === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    /** @private */\n    this.prefixCodePoint = /** @type {number} */ (prefix.codePointAt(0))\n    this.baseDecode = baseDecode\n  }\n\n  /**\n   * @param {string} text\n   */\n  decode (text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n}\n\n/**\n * @template {string} Prefix\n * @typedef {Record<Prefix, API.UnibaseDecoder<Prefix>>} Decoders\n */\n\n/**\n * @template {string} Prefix\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.CombobaseDecoder<Prefix>}\n */\nclass ComposedDecoder {\n  /**\n   * @param {Decoders<Prefix>} decoders\n   */\n  constructor (decoders) {\n    this.decoders = decoders\n  }\n\n  /**\n   * @template {string} OtherPrefix\n   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder\n   * @returns {ComposedDecoder<Prefix|OtherPrefix>}\n   */\n  or (decoder) {\n    return or(this, decoder)\n  }\n\n  /**\n   * @param {string} input\n   * @returns {Uint8Array}\n   */\n  decode (input) {\n    const prefix = /** @type {Prefix} */ (input[0])\n    const decoder = this.decoders[prefix]\n    if (decoder) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\n/**\n * @template {string} L\n * @template {string} R\n * @param {API.UnibaseDecoder<L>|API.CombobaseDecoder<L>} left\n * @param {API.UnibaseDecoder<R>|API.CombobaseDecoder<R>} right\n * @returns {ComposedDecoder<L|R>}\n */\nexport const or = (left, right) => new ComposedDecoder(/** @type {Decoders<L|R>} */({\n  ...(left.decoders || { [/** @type API.UnibaseDecoder<L> */(left).prefix]: left }),\n  ...(right.decoders || { [/** @type API.UnibaseDecoder<R> */(right).prefix]: right })\n}))\n\n/**\n * @class\n * @template {string} Base\n * @template {string} Prefix\n * @implements {API.MultibaseCodec<Prefix>}\n * @implements {API.MultibaseEncoder<Prefix>}\n * @implements {API.MultibaseDecoder<Prefix>}\n * @implements {API.BaseCodec}\n * @implements {API.BaseEncoder}\n * @implements {API.BaseDecoder}\n */\nexport class Codec {\n  /**\n   * @param {Base} name\n   * @param {Prefix} prefix\n   * @param {(bytes:Uint8Array) => string} baseEncode\n   * @param {(text:string) => Uint8Array} baseDecode\n   */\n  constructor (name, prefix, baseEncode, baseDecode) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  /**\n   * @param {Uint8Array} input\n   */\n  encode (input) {\n    return this.encoder.encode(input)\n  }\n\n  /**\n   * @param {string} input\n   */\n  decode (input) {\n    return this.decoder.decode(input)\n  }\n}\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {(bytes:Uint8Array) => string} options.encode\n * @param {(input:string) => Uint8Array} options.decode\n * @returns {Codec<Base, Prefix>}\n */\nexport const from = ({ name, prefix, encode, decode }) =>\n  new Codec(name, prefix, encode, decode)\n\n/**\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @returns {Codec<Base, Prefix>}\n */\nexport const baseX = ({ prefix, name, alphabet }) => {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    /**\n     * @param {string} text\n     */\n    decode: text => coerce(decode(text))\n  })\n}\n\n/**\n * @param {string} string\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @param {string} name\n * @returns {Uint8Array}\n */\nconst decode = (string, alphabet, bitsPerChar, name) => {\n  // Build the character lookup table:\n  /** @type {Record<string, number>} */\n  const codes = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    codes[alphabet[i]] = i\n  }\n\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = codes[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\n/**\n * @param {Uint8Array} data\n * @param {string} alphabet\n * @param {number} bitsPerChar\n * @returns {string}\n */\nconst encode = (data, alphabet, bitsPerChar) => {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar) & 7) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\n/**\n * RFC4648 Factory\n *\n * @template {string} Base\n * @template {string} Prefix\n * @param {object} options\n * @param {Base} options.name\n * @param {Prefix} options.prefix\n * @param {string} options.alphabet\n * @param {number} options.bitsPerChar\n */\nexport const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {\n  return from({\n    prefix,\n    name,\n    encode (input) {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input) {\n      return decode(input, alphabet, bitsPerChar, name)\n    }\n  })\n}\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n", "import * as varint from './varint.js'\nimport * as Digest from './hashes/digest.js'\nimport { base58btc } from './bases/base58.js'\nimport { base32 } from './bases/base32.js'\nimport { coerce } from './bytes.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\n/**\n * @template {API.Link<unknown, number, number, API.Version>} T\n * @template {string} Prefix\n * @param {T} link\n * @param {API.MultibaseEncoder<Prefix>} [base]\n * @returns {API.ToString<T, Prefix>}\n */\nexport const format = (link, base) => {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<\"z\">} */ (base) || base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        /** @type {API.MultibaseEncoder<Prefix>} */ (base || base32.encoder)\n      )\n  }\n}\n\n/**\n * @template {API.UnknownLink} Link\n * @param {Link} link\n * @returns {API.LinkJSON<Link>}\n */\nexport const toJSON = (link) => ({\n  '/': format(link)\n})\n\n/**\n * @template {API.UnknownLink} Link\n * @param {API.LinkJSON<Link>} json\n */\nexport const fromJSON = (json) =>\n  CID.parse(json['/'])\n\n/** @type {WeakMap<API.UnknownLink, Map<string, string>>} */\nconst cache = new WeakMap()\n\n/**\n * @param {API.UnknownLink} cid\n * @returns {Map<string, string>}\n */\nconst baseCache = cid => {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\n/**\n * @template {unknown} [Data=unknown]\n * @template {number} [Format=number]\n * @template {number} [Alg=number]\n * @template {API.Version} [Version=API.Version]\n * @implements {API.Link<Data, Format, Alg, Version>}\n */\n\nexport class CID {\n  /**\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.\n   * @param {Uint8Array} bytes\n   *\n   */\n  constructor (version, code, multihash, bytes) {\n    /** @readonly */\n    this.code = code\n    /** @readonly */\n    this.version = version\n    /** @readonly */\n    this.multihash = multihash\n    /** @readonly */\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    /** @readonly */\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID () {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset () {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength () {\n    return this.bytes.byteLength\n  }\n\n  /**\n   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}\n   */\n  toV0 () {\n    switch (this.version) {\n      case 0: {\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (this)\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ (\n          CID.createV0(\n            /** @type {API.MultihashDigest<API.SHA_256>} */ (multihash)\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @returns {CID<Data, Format, Alg, 1>}\n   */\n  toV1 () {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return /** @type {CID<Data, Format, Alg, 1>} */ (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return /** @type {CID<Data, Format, Alg, 1>} */ (this)\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  /**\n   * @param {unknown} other\n   * @returns {other is CID<Data, Format, Alg, Version>}\n   */\n  equals (other) {\n    return CID.equals(this, other)\n  }\n\n  /**\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {API.Link<Data, Format, Alg, Version>} self\n   * @param {unknown} other\n   * @returns {other is CID}\n   */\n  static equals (self, other) {\n    const unknown =\n      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ (\n        other\n      )\n    return (\n      unknown &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  /**\n   * @param {API.MultibaseEncoder<string>} [base]\n   * @returns {string}\n   */\n  toString (base) {\n    return format(this, base)\n  }\n\n  toJSON () {\n    return { '/': format(this) }\n  }\n\n  link () {\n    return this\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'CID'\n  }\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @template {unknown} U\n   * @param {API.Link<Data, Format, Alg, Version>|U} input\n   * @returns {CID<Data, Format, Alg, Version>|null}\n   */\n  static asCID (input) {\n    if (input == null) {\n      return null\n    }\n\n    const value = /** @type {any} */ (input)\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        /** @type {API.MultihashDigest<Alg>} */ (multihash),\n        bytes || encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest =\n        /** @type {API.MultihashDigest<Alg>} */\n        (Digest.decode(multihash))\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   *\n   * @template {unknown} Data\n   * @template {number} Format\n   * @template {number} Alg\n   * @template {API.Version} Version\n   * @param {Version} version - Version of the CID\n   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.\n   * @returns {CID<Data, Format, Alg, Version>}\n   */\n  static create (version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   *\n   * @template {unknown} [T=unknown]\n   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}\n   */\n  static createV0 (digest) {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @param {Code} code - Content encoding format code.\n   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n   * @returns {CID<Data, Code, Alg, 1>}\n   */\n  static createV1 (code, digest) {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   *\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static decode (bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes\n   * @returns {[CID<T, C, A, V>, Uint8Array]}\n   */\n  static decodeFirst (bytes) {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ (digest))\n        : CID.createV1(specs.codec, digest)\n    return [/** @type {CID<T, C, A, V>} */(cid), bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   *\n   * @template {unknown} T\n   * @template {number} C\n   * @template {number} A\n   * @template {API.Version} V\n   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes\n   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}\n   */\n  static inspectBytes (initialBytes) {\n    let offset = 0\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = /** @type {V} */ (next())\n    let codec = /** @type {C} */ (DAG_PB_CODE)\n    if (/** @type {number} */(version) === 18) {\n      // CIDv0\n      version = /** @type {V} */ (0)\n      offset = 0\n    } else {\n      codec = /** @type {C} */ (next())\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = /** @type {A} */ (next()) // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   *\n   * @template {string} Prefix\n   * @template {unknown} Data\n   * @template {number} Code\n   * @template {number} Alg\n   * @template {API.Version} Ver\n   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n   * @param {API.MultibaseDecoder<Prefix>} [base]\n   * @returns {CID<Data, Code, Alg, Ver>}\n   */\n  static parse (source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {[Prefix, API.ByteView<API.Link<Data, Code, Alg, Ver>>]}\n */\nconst parseCIDtoBytes = (source, base) => {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base || base58btc\n      return [\n        /** @type {Prefix} */ (base58btc.prefix),\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base || base58btc\n      return [/** @type {Prefix} */(base58btc.prefix), decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base || base32\n      return [/** @type {Prefix} */(base32.prefix), decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [/** @type {Prefix} */(source[0]), base.decode(source)]\n    }\n  }\n}\n\n/**\n *\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<'z'>} base\n */\nconst toStringV0 = (bytes, cache, base) => {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\n/**\n * @template {string} Prefix\n * @param {Uint8Array} bytes\n * @param {Map<string, string>} cache\n * @param {API.MultibaseEncoder<Prefix>} base\n */\nconst toStringV1 = (bytes, cache, base) => {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\n/**\n * @param {API.Version} version\n * @param {number} code\n * @param {Uint8Array} multihash\n * @returns {Uint8Array}\n */\nconst encodeCID = (version, code, multihash) => {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n", "/* eslint-disable jsdoc/check-indentation */\n\n/** Auto-generated with ipld-schema-validator@0.0.0-dev at Thu Jun 17 2021 from IPLD Schema:\n *\n * type CarHeader struct {\n *   version Int\n *   roots optional [&Any]\n *   # roots is _not_ optional for CarV1 but we defer that check within code to\n *   # gracefully handle the >V1 case where it's just {version:X}\n * }\n *\n */\n\nconst Kinds = {\n  Null: /**\n         * @param {any} obj\n         * @returns {boolean}\n         */ (/** @type {any} */ obj) => obj === null,\n  Int: /**\n        * @param {any} obj\n        * @returns {boolean}\n        */ (/** @type {any} */ obj) => Number.isInteger(obj),\n  Float: /**\n          * @param {any} obj\n          * @returns {boolean}\n          */ (/** @type {any} */ obj) => typeof obj === 'number' && Number.isFinite(obj),\n  String: /**\n           * @param {any} obj\n           * @returns {boolean}\n           */ (/** @type {any} */ obj) => typeof obj === 'string',\n  Bool: /**\n         * @param {any} obj\n         * @returns {boolean}\n         */ (/** @type {any} */ obj) => typeof obj === 'boolean',\n  Bytes: /**\n          * @param {any} obj\n          * @returns {boolean}\n          */ (/** @type {any} */ obj) => obj instanceof Uint8Array,\n  Link: /**\n         * @param {any} obj\n         * @returns {boolean}\n         */ (/** @type {any} */ obj) => !Kinds.Null(obj) && typeof obj === 'object' && obj.asCID === obj,\n  List: /**\n         * @param {any} obj\n         * @returns {boolean}\n         */ (/** @type {any} */ obj) => Array.isArray(obj),\n  Map: /**\n        * @param {any} obj\n        * @returns {boolean}\n        */ (/** @type {any} */ obj) => !Kinds.Null(obj) && typeof obj === 'object' && obj.asCID !== obj && !Kinds.List(obj) && !Kinds.Bytes(obj)\n}\n/** @type {{ [k in string]: (obj:any)=>boolean}} */\nconst Types = {\n  Int: Kinds.Int,\n  'CarHeader > version': /**\n                          * @param {any} obj\n                          * @returns {boolean}\n                          */ (/** @type {any} */ obj) => Types.Int(obj),\n  'CarHeader > roots (anon) > valueType (anon)': Kinds.Link,\n  'CarHeader > roots (anon)': /**\n                               * @param {any} obj\n                               * @returns {boolean}\n                               */ (/** @type {any} */ obj) => Kinds.List(obj) && Array.prototype.every.call(obj, Types['CarHeader > roots (anon) > valueType (anon)']),\n  'CarHeader > roots': /**\n                        * @param {any} obj\n                        * @returns {boolean}\n                        */ (/** @type {any} */ obj) => Types['CarHeader > roots (anon)'](obj),\n  CarHeader: /**\n              * @param {any} obj\n              * @returns {boolean}\n              */ (/** @type {any} */ obj) => { const keys = obj && Object.keys(obj); return Kinds.Map(obj) && ['version'].every((k) => keys.includes(k)) && Object.entries(obj).every(([name, value]) => Types['CarHeader > ' + name] && Types['CarHeader > ' + name](value)) }\n}\n\nexport const CarHeader = Types.CarHeader\n", "import varint from 'varint'\n\nexport const CIDV0_BYTES = {\n  SHA2_256: 0x12,\n  LENGTH: 0x20,\n  DAG_PB: 0x70\n}\n\nexport const V2_HEADER_LENGTH = /* characteristics */ 16 /* v1 offset */ + 8 /* v1 size */ + 8 /* index offset */ + 8\n\n/**\n * Decodes varint and seeks the buffer\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.upTo(8) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n * @param {import('./coding').Seekable} seeker\n * @returns {number}\n */\nexport function decodeVarint (bytes, seeker) {\n  if (!bytes.length) {\n    throw new Error('Unexpected end of data')\n  }\n  const i = varint.decode(bytes)\n  seeker.seek(/** @type {number} */(varint.decode.bytes))\n  return i\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n\n/**\n * Decode v2 header\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.exactly(V2_HEADER_LENGTH, true) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n * @returns {import('./coding').CarV2FixedHeader}\n */\nexport function decodeV2Header (bytes) {\n  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  let offset = 0\n  const header = {\n    version: 2,\n    /** @type {[bigint, bigint]} */\n    characteristics: [\n      dv.getBigUint64(offset, true),\n      dv.getBigUint64(offset += 8, true)\n    ],\n    dataOffset: Number(dv.getBigUint64(offset += 8, true)),\n    dataSize: Number(dv.getBigUint64(offset += 8, true)),\n    indexOffset: Number(dv.getBigUint64(offset += 8, true))\n  }\n  return header\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n\n/**\n * Checks the length of the multihash to be read afterwards\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.upTo(8) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n */\nexport function getMultihashLength (bytes) {\n  // | code | length | .... |\n  // where both code and length are varints, so we have to decode\n  // them first before we can know total length\n\n  varint.decode(bytes) // code\n  const codeLength = /** @type {number} */(varint.decode.bytes)\n  const length = varint.decode(bytes.subarray(varint.decode.bytes))\n  const lengthLength = /** @type {number} */(varint.decode.bytes)\n  const mhLength = codeLength + lengthLength + length\n\n  return mhLength\n}\n", "import { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { decode as decodeDagCbor } from '@ipld/dag-cbor'\nimport { CarHeader as headerValidator } from './header-validator.js'\nimport { CIDV0_BYTES, decodeV2Header, decodeVarint, getMultihashLength, V2_HEADER_LENGTH } from './decoder-common.js'\n\n/**\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').BlockHeader} BlockHeader\n * @typedef {import('./api').BlockIndex} BlockIndex\n * @typedef {import('./coding').BytesReader} BytesReader\n * @typedef {import('./coding').CarHeader} CarHeader\n * @typedef {import('./coding').CarV2Header} CarV2Header\n * @typedef {import('./coding').CarV2FixedHeader} CarV2FixedHeader\n * @typedef {import('./coding').CarDecoder} CarDecoder\n */\n\n/**\n * Reads header data from a `BytesReader`. The header may either be in the form\n * of a `CarHeader` or `CarV2Header` depending on the CAR being read.\n *\n * @name async decoder.readHeader(reader)\n * @param {BytesReader} reader\n * @param {number} [strictVersion]\n * @returns {Promise<CarHeader|CarV2Header>}\n */\nexport async function readHeader (reader, strictVersion) {\n  const length = decodeVarint(await reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)')\n  }\n  const header = await reader.exactly(length, true)\n  const block = decodeDagCbor(header)\n  if (!headerValidator(block)) {\n    throw new Error('Invalid CAR header format')\n  }\n  if ((block.version !== 1 && block.version !== 2) || (strictVersion !== undefined && block.version !== strictVersion)) {\n    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`)\n  }\n  // we've made 'roots' optional in the schema so we can do the version check\n  // before rejecting the block as invalid if there is no version\n  const hasRoots = Array.isArray(block.roots)\n  if ((block.version === 1 && !hasRoots) || (block.version === 2 && hasRoots)) {\n    throw new Error('Invalid CAR header format')\n  }\n  if (block.version === 1) {\n    return block\n  }\n  // version 2\n  const v2Header = decodeV2Header(await reader.exactly(V2_HEADER_LENGTH, true))\n  reader.seek(v2Header.dataOffset - reader.pos)\n  const v1Header = await readHeader(reader, 1)\n  return Object.assign(v1Header, v2Header)\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<CID>}\n */\nasync function readCid (reader) {\n  const first = await reader.exactly(2, false)\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    // cidv0 32-byte sha2-256\n    const bytes = await reader.exactly(34, true)\n    const multihash = Digest.decode(bytes)\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash)\n  }\n\n  const version = decodeVarint(await reader.upTo(8), reader)\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`)\n  }\n  const codec = decodeVarint(await reader.upTo(8), reader)\n  const bytes = await reader.exactly(getMultihashLength(await reader.upTo(8)), true)\n  const multihash = Digest.decode(bytes)\n  return CID.create(version, codec, multihash)\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n\n/**\n * Reads the leading data of an individual block from CAR data from a\n * `BytesReader`. Returns a `BlockHeader` object which contains\n * `{ cid, length, blockLength }` which can be used to either index the block\n * or read the block binary data.\n *\n * @name async decoder.readBlockHead(reader)\n * @param {BytesReader} reader\n * @returns {Promise<BlockHeader>}\n */\nexport async function readBlockHead (reader) {\n  // length includes a CID + Binary, where CID has a variable length\n  // we have to deal with\n  const start = reader.pos\n  let length = decodeVarint(await reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)')\n  }\n  length += (reader.pos - start)\n  const cid = await readCid(reader)\n  const blockLength = length - Number(reader.pos - start) // subtract CID length\n\n  return { cid, length, blockLength }\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<Block>}\n */\nasync function readBlock (reader) {\n  const { cid, blockLength } = await readBlockHead(reader)\n  const bytes = await reader.exactly(blockLength, true)\n  return { bytes, cid }\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<BlockIndex>}\n */\nasync function readBlockIndex (reader) {\n  const offset = reader.pos\n  const { cid, length, blockLength } = await readBlockHead(reader)\n  const index = { cid, length, blockLength, offset, blockOffset: reader.pos }\n  reader.seek(index.blockLength)\n  return index\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n\n/**\n * Creates a `CarDecoder` from a `BytesReader`. The `CarDecoder` is as async\n * interface that will consume the bytes from the `BytesReader` to yield a\n * `header()` and either `blocks()` or `blocksIndex()` data.\n *\n * @name decoder.createDecoder(reader)\n * @param {BytesReader} reader\n * @returns {CarDecoder}\n */\nexport function createDecoder (reader) {\n  const headerPromise = (async () => {\n    const header = await readHeader(reader)\n    if (header.version === 2) {\n      const v1length = reader.pos - header.dataOffset\n      reader = limitReader(reader, header.dataSize - v1length)\n    }\n    return header\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  })()\n\n  return {\n    header: () => headerPromise,\n\n    async * blocks () {\n      await headerPromise\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader)\n      }\n    },\n\n    async * blocksIndex () {\n      await headerPromise\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader)\n      }\n    }\n  }\n}\n\n/**\n * Creates a `BytesReader` from a `Uint8Array`.\n *\n * @name decoder.bytesReader(bytes)\n * @param {Uint8Array} bytes\n * @returns {BytesReader}\n */\nexport function bytesReader (bytes) {\n  let pos = 0\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      const out = bytes.subarray(pos, pos + Math.min(length, bytes.length - pos))\n      /* c8 ignore next 2 */\n      return out\n      // Node.js 12 c8 bug\n    },\n\n    async exactly (length, seek = false) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data')\n      }\n      const out = bytes.subarray(pos, pos + length)\n      if (seek) {\n        pos += length\n      }\n      return out\n      /* c8 ignore next 2 */\n      // Node.js 12 c8 bug\n    },\n\n    seek (length) {\n      pos += length\n    },\n\n    get pos () {\n      return pos\n    }\n  }\n}\n\n/**\n * @ignore\n * reusable reader for streams and files, we just need a way to read an\n * additional chunk (of some undetermined size) and a way to close the\n * reader when finished\n * @param {() => Promise<Uint8Array|null>} readChunk\n * @returns {BytesReader}\n */\nexport function chunkReader (readChunk /*, closer */) {\n  let pos = 0\n  let have = 0\n  let offset = 0\n  let currentChunk = new Uint8Array(0)\n\n  const read = async (/** @type {number} */ length) => {\n    have = currentChunk.length - offset\n    const bufa = [currentChunk.subarray(offset)]\n    while (have < length) {\n      const chunk = await readChunk()\n      if (chunk == null) {\n        break\n      }\n      /* c8 ignore next 8 */\n      // undo this ignore ^ when we have a fd implementation that can seek()\n      if (have < 0) { // because of a seek()\n        /* c8 ignore next 4 */\n        // toohard to test the else\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have))\n        } // else discard\n      } else {\n        bufa.push(chunk)\n      }\n      have += chunk.length\n    }\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0))\n    let off = 0\n    for (const b of bufa) {\n      currentChunk.set(b, off)\n      off += b.length\n    }\n    offset = 0\n  }\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      if (currentChunk.length - offset < length) {\n        await read(length)\n      }\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length))\n      /* c8 ignore next 2 */\n      // Node.js 12 c8 bug\n    },\n\n    async exactly (length, seek = false) {\n      if (currentChunk.length - offset < length) {\n        await read(length)\n      }\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data')\n      }\n      const out = currentChunk.subarray(offset, offset + length)\n      if (seek) {\n        pos += length\n        offset += length\n      }\n      return out\n      /* c8 ignore next 2 */\n      // Node.js 12 c8 bug\n    },\n\n    seek (length) {\n      pos += length\n      offset += length\n    },\n\n    get pos () {\n      return pos\n    }\n  }\n}\n\n/**\n * Creates a `BytesReader` from an `AsyncIterable<Uint8Array>`, which allows for\n * consumption of CAR data from a streaming source.\n *\n * @name decoder.asyncIterableReader(asyncIterable)\n * @param {AsyncIterable<Uint8Array>} asyncIterable\n * @returns {BytesReader}\n */\nexport function asyncIterableReader (asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]()\n\n  async function readChunk () {\n    const next = await iterator.next()\n    if (next.done) {\n      return null\n    }\n    return next.value\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n\n  return chunkReader(readChunk)\n}\n\n/**\n * Wraps a `BytesReader` in a limiting `BytesReader` which limits maximum read\n * to `byteLimit` bytes. It _does not_ update `pos` of the original\n * `BytesReader`.\n *\n * @name decoder.limitReader(reader, byteLimit)\n * @param {BytesReader} reader\n * @param {number} byteLimit\n * @returns {BytesReader}\n */\nexport function limitReader (reader, byteLimit) {\n  let bytesRead = 0\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      let bytes = await reader.upTo(length)\n      if (bytes.length + bytesRead > byteLimit) {\n        bytes = bytes.subarray(0, byteLimit - bytesRead)\n      }\n      return bytes\n      /* c8 ignore next 2 */\n      // Node.js 12 c8 bug\n    },\n\n    async exactly (length, seek = false) {\n      const bytes = await reader.exactly(length, seek)\n      if (bytes.length + bytesRead > byteLimit) {\n        throw new Error('Unexpected end of data')\n      }\n      if (seek) {\n        bytesRead += length\n      }\n      return bytes\n      /* c8 ignore next 2 */\n      // Node.js 12 c8 bug\n    },\n\n    seek (length) {\n      bytesRead += length\n      reader.seek(length)\n    },\n\n    get pos () {\n      return reader.pos\n    }\n  }\n}\n", "import { asyncIterableReader, bytesReader, createDecoder } from './decoder.js'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').CarReader} CarReaderIface\n * @typedef {import('./coding').BytesReader} BytesReader\n * @typedef {import('./coding').CarHeader} CarHeader\n * @typedef {import('./coding').CarV2Header} CarV2Header\n */\n\n/**\n * Provides blockstore-like access to a CAR.\n *\n * Implements the `RootsReader` interface:\n * {@link CarReader.getRoots `getRoots()`}. And the `BlockReader` interface:\n * {@link CarReader.get `get()`}, {@link CarReader.has `has()`},\n * {@link CarReader.blocks `blocks()`} (defined as a `BlockIterator`) and\n * {@link CarReader.cids `cids()`} (defined as a `CIDIterator`).\n *\n * Load this class with either `import { CarReader } from '@ipld/car/reader'`\n * (`const { CarReader } = require('@ipld/car/reader')`). Or\n * `import { CarReader } from '@ipld/car'` (`const { CarReader } = require('@ipld/car')`).\n * The former will likely result in smaller bundle sizes where this is\n * important.\n *\n * @name CarReader\n * @class\n * @implements {CarReaderIface}\n * @property {number} version The version number of the CAR referenced by this\n * reader (should be `1` or `2`).\n */\nexport class CarReader {\n  /**\n   * @constructs CarReader\n   * @param {CarHeader|CarV2Header} header\n   * @param {Block[]} blocks\n   */\n  constructor (header, blocks) {\n    this._header = header\n    this._blocks = blocks\n    this._keys = blocks.map((b) => b.cid.toString())\n  }\n\n  /**\n   * @property\n   * @memberof CarReader\n   * @instance\n   */\n  get version () {\n    return this._header.version\n  }\n\n  /**\n   * Get the list of roots defined by the CAR referenced by this reader. May be\n   * zero or more `CID`s.\n   *\n   * @function\n   * @memberof CarReader\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n  async getRoots () {\n    return this._header.roots\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n\n  /**\n   * Check whether a given `CID` exists within the CAR referenced by this\n   * reader.\n   *\n   * @function\n   * @memberof CarReader\n   * @instance\n   * @async\n   * @param {CID} key\n   * @returns {Promise<boolean>}\n   */\n  async has (key) {\n    return this._keys.indexOf(key.toString()) > -1\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n\n  /**\n   * Fetch a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) from the CAR\n   * referenced by this reader matching the provided `CID`. In the case where\n   * the provided `CID` doesn't exist within the CAR, `undefined` will be\n   * returned.\n   *\n   * @function\n   * @memberof CarReader\n   * @instance\n   * @async\n   * @param {CID} key\n   * @returns {Promise<Block | undefined>}\n   */\n  async get (key) {\n    const index = this._keys.indexOf(key.toString())\n    return index > -1 ? this._blocks[index] : undefined\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n\n  /**\n   * Returns a `BlockIterator` (`AsyncIterable<Block>`) that iterates over all\n   * of the `Block`s (`{ cid:CID, bytes:Uint8Array }` pairs) contained within\n   * the CAR referenced by this reader.\n   *\n   * @function\n   * @memberof CarReader\n   * @instance\n   * @async\n   * @generator\n   * @returns {AsyncGenerator<Block>}\n   */\n  async * blocks () {\n    for (const block of this._blocks) {\n      yield block\n    }\n  }\n\n  /**\n   * Returns a `CIDIterator` (`AsyncIterable<CID>`) that iterates over all of\n   * the `CID`s contained within the CAR referenced by this reader.\n   *\n   * @function\n   * @memberof CarReader\n   * @instance\n   * @async\n   * @generator\n   * @returns {AsyncGenerator<CID>}\n   */\n  async * cids () {\n    for (const block of this._blocks) {\n      yield block.cid\n    }\n  }\n\n  /**\n   * Instantiate a {@link CarReader} from a `Uint8Array` blob. This performs a\n   * decode fully in memory and maintains the decoded state in memory for full\n   * access to the data via the `CarReader` API.\n   *\n   * @async\n   * @static\n   * @memberof CarReader\n   * @param {Uint8Array} bytes\n   * @returns {Promise<CarReader>}\n   */\n  static async fromBytes (bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array')\n    }\n    return decodeReaderComplete(bytesReader(bytes))\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n\n  /**\n   * Instantiate a {@link CarReader} from a `AsyncIterable<Uint8Array>`, such as\n   * a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\n   * This performs a decode fully in memory and maintains the decoded state in\n   * memory for full access to the data via the `CarReader` API.\n   *\n   * Care should be taken for large archives; this API may not be appropriate\n   * where memory is a concern or the archive is potentially larger than the\n   * amount of memory that the runtime can handle.\n   *\n   * @async\n   * @static\n   * @memberof CarReader\n   * @param {AsyncIterable<Uint8Array>} asyncIterable\n   * @returns {Promise<CarReader>}\n   */\n  static async fromIterable (asyncIterable) {\n    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n      throw new TypeError('fromIterable() requires an async iterable')\n    }\n    return decodeReaderComplete(asyncIterableReader(asyncIterable))\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n}\n\n/**\n * @private\n * @param {BytesReader} reader\n * @returns {Promise<CarReader>}\n */\nexport async function decodeReaderComplete (reader) {\n  const decoder = createDecoder(reader)\n  const header = await decoder.header()\n  const blocks = []\n  for await (const block of decoder.blocks()) {\n    blocks.push(block)\n  }\n\n  return new CarReader(header, blocks)\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n\nexport const __browser = true\n", "import {\n  asyncIterableReader,\n  bytesReader,\n  createDecoder\n} from './decoder.js'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').RootsReader} RootsReader\n * @typedef {import('./api').BlockIndex} BlockIndex\n * @typedef {import('./coding').BytesReader} BytesReader\n */\n\n/**\n * Provides an iterator over all of the `Block`s in a CAR, returning their CIDs\n * and byte-location information. Implements an `AsyncIterable<BlockIndex>`.\n * Where a `BlockIndex` is a\n * `{ cid:CID, length:number, offset:number, blockLength:number, blockOffset:number }`.\n *\n * As an implementer of `AsyncIterable`, this class can be used directly in a\n * `for await (const blockIndex of iterator) {}` loop. Where the `iterator` is\n * constructed using {@link CarIndexer.fromBytes} or\n * {@link CarIndexer.fromIterable}.\n *\n * An iteration can only be performce _once_ per instantiation.\n *\n * `CarIndexer` also implements the `RootsReader` interface and provides\n * the {@link CarIndexer.getRoots `getRoots()`} method.\n *\n * Load this class with either\n * `import { CarIndexer } from '@ipld/car/indexer'`\n * (`const { CarIndexer } = require('@ipld/car/indexer')`). Or\n * `import { CarIndexer } from '@ipld/car'`\n * (`const { CarIndexer } = require('@ipld/car')`). The former will likely\n * result in smaller bundle sizes where this is important.\n *\n * @name CarIndexer\n * @class\n * @implements {RootsReader}\n * @implements {AsyncIterable<BlockIndex>}\n * @property {number} version The version number of the CAR referenced by this\n * reader (should be `1`).\n */\nexport class CarIndexer {\n  /**\n   * @param {number} version\n   * @param {CID[]} roots\n   * @param {AsyncGenerator<BlockIndex>} iterator\n   */\n  constructor (version, roots, iterator) {\n    this._version = version\n    this._roots = roots\n    this._iterator = iterator\n  }\n\n  get version () {\n    return this._version\n  }\n\n  /**\n   * Get the list of roots defined by the CAR referenced by this indexer. May be\n   * zero or more `CID`s.\n   *\n   * @function\n   * @memberof CarIndexer\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n  async getRoots () {\n    return this._roots\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n\n  /**\n   * @returns {AsyncIterator<BlockIndex>}\n   */\n  [Symbol.asyncIterator] () {\n    return this._iterator\n  }\n\n  /**\n   * Instantiate a {@link CarIndexer} from a `Uint8Array` blob. Only the header\n   * is decoded initially, the remainder is processed and emitted via the\n   * iterator as it is consumed.\n   *\n   * @async\n   * @static\n   * @memberof CarIndexer\n   * @param {Uint8Array} bytes\n   * @returns {Promise<CarIndexer>}\n   */\n  static async fromBytes (bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array')\n    }\n    return decodeIndexerComplete(bytesReader(bytes))\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n\n  /**\n   * Instantiate a {@link CarIndexer} from a `AsyncIterable<Uint8Array>`,\n   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\n   * is decoded initially, the remainder is processed and emitted via the\n   * iterator as it is consumed.\n   *\n   * @async\n   * @static\n   * @memberof CarIndexer\n   * @param {AsyncIterable<Uint8Array>} asyncIterable\n   * @returns {Promise<CarIndexer>}\n   */\n  static async fromIterable (asyncIterable) {\n    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n      throw new TypeError('fromIterable() requires an async iterable')\n    }\n    return decodeIndexerComplete(asyncIterableReader(asyncIterable))\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n}\n\n/**\n * @private\n * @param {BytesReader} reader\n * @returns {Promise<CarIndexer>}\n */\nasync function decodeIndexerComplete (reader) {\n  const decoder = createDecoder(reader)\n  const { version, roots } = await decoder.header()\n\n  return new CarIndexer(version, roots, decoder.blocksIndex())\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n", "import {\n  asyncIterableReader,\n  bytesReader,\n  createDecoder\n} from './decoder.js'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').RootsReader} RootsReader\n * @typedef {import('./coding').BytesReader} BytesReader\n */\n\n/**\n * @class\n * @implements {RootsReader}\n * @property {number} version The version number of the CAR referenced by this reader (should be `1`).\n */\nexport class CarIteratorBase {\n  /**\n   * @param {number} version\n   * @param {CID[]} roots\n   * @param {AsyncIterable<Block>|void} iterable\n   */\n  constructor (version, roots, iterable) {\n    this._version = version\n    this._roots = roots\n    this._iterable = iterable\n    this._decoded = false\n  }\n\n  get version () {\n    return this._version\n  }\n\n  /**\n   * @returns {Promise<CID[]>}\n   */\n  async getRoots () {\n    return this._roots\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n}\n\n/**\n * Provides an iterator over all of the `Block`s in a CAR. Implements a\n * `BlockIterator` interface, or `AsyncIterable<Block>`. Where a `Block` is\n * a `{ cid:CID, bytes:Uint8Array }` pair.\n *\n * As an implementer of `AsyncIterable`, this class can be used directly in a\n * `for await (const block of iterator) {}` loop. Where the `iterator` is\n * constructed using {@link CarBlockiterator.fromBytes} or\n * {@link CarBlockiterator.fromIterable}.\n *\n * An iteration can only be performce _once_ per instantiation.\n *\n * `CarBlockIterator` also implements the `RootsReader` interface and provides\n * the {@link CarBlockiterator.getRoots `getRoots()`} method.\n *\n * Load this class with either\n * `import { CarBlockIterator } from '@ipld/car/iterator'`\n * (`const { CarBlockIterator } = require('@ipld/car/iterator')`). Or\n * `import { CarBlockIterator } from '@ipld/car'`\n * (`const { CarBlockIterator } = require('@ipld/car')`).\n *\n * @name CarBlockIterator\n * @class\n * @implements {RootsReader}\n * @implements {AsyncIterable<Block>}\n * @property {number} version The version number of the CAR referenced by this\n * iterator (should be `1`).\n */\nexport class CarBlockIterator extends CarIteratorBase {\n  // inherited method\n  /**\n   * Get the list of roots defined by the CAR referenced by this iterator. May be\n   * zero or more `CID`s.\n   *\n   * @function getRoots\n   * @memberof CarBlockIterator\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n\n  /**\n   * @returns {AsyncIterator<Block>}\n   */\n  [Symbol.asyncIterator] () {\n    if (this._decoded) {\n      throw new Error('Cannot decode more than once')\n    }\n    /* c8 ignore next 3 */\n    if (!this._iterable) {\n      throw new Error('Block iterable not found')\n    }\n    this._decoded = true\n    return this._iterable[Symbol.asyncIterator]()\n  }\n\n  /**\n   * Instantiate a {@link CarBlockIterator} from a `Uint8Array` blob. Rather\n   * than decoding the entire byte array prior to returning the iterator, as in\n   * {@link CarReader.fromBytes}, only the header is decoded and the remainder\n   * of the CAR is parsed as the `Block`s as yielded.\n   *\n   * @async\n   * @static\n   * @memberof CarBlockIterator\n   * @param {Uint8Array} bytes\n   * @returns {Promise<CarBlockIterator>}\n   */\n  static async fromBytes (bytes) {\n    const { version, roots, iterator } = await fromBytes(bytes)\n    return new CarBlockIterator(version, roots, iterator)\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n\n  /**\n   * Instantiate a {@link CarBlockIterator} from a `AsyncIterable<Uint8Array>`,\n   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\n   * Rather than decoding the entire byte array prior to returning the iterator,\n   * as in {@link CarReader.fromIterable}, only the header is decoded and the\n   * remainder of the CAR is parsed as the `Block`s as yielded.\n   *\n   * @async\n   * @static\n   * @param {AsyncIterable<Uint8Array>} asyncIterable\n   * @returns {Promise<CarBlockIterator>}\n   */\n  static async fromIterable (asyncIterable) {\n    const { version, roots, iterator } = await fromIterable(asyncIterable)\n    return new CarBlockIterator(version, roots, iterator)\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n}\n\n/**\n * Provides an iterator over all of the `CID`s in a CAR. Implements a\n * `CIDIterator` interface, or `AsyncIterable<CID>`. Similar to\n * {@link CarBlockIterator} but only yields the CIDs in the CAR.\n *\n * As an implementer of `AsyncIterable`, this class can be used directly in a\n * `for await (const cid of iterator) {}` loop. Where the `iterator` is\n * constructed using {@link CarCIDiterator.fromBytes} or\n * {@link CarCIDiterator.fromIterable}.\n *\n * An iteration can only be performce _once_ per instantiation.\n *\n * `CarCIDIterator` also implements the `RootsReader` interface and provides\n * the {@link CarCIDiterator.getRoots `getRoots()`} method.\n *\n * Load this class with either\n * `import { CarCIDIterator } from '@ipld/car/iterator'`\n * (`const { CarCIDIterator } = require('@ipld/car/iterator')`). Or\n * `import { CarCIDIterator } from '@ipld/car'`\n * (`const { CarCIDIterator } = require('@ipld/car')`).\n *\n * @name CarCIDIterator\n * @class\n * @implements {RootsReader}\n * @implements {AsyncIterable<CID>}\n * @property {number} version The version number of the CAR referenced by this\n * iterator (should be `1`).\n */\nexport class CarCIDIterator extends CarIteratorBase {\n  // inherited method\n  /**\n   * Get the list of roots defined by the CAR referenced by this iterator. May be\n   * zero or more `CID`s.\n   *\n   * @function getRoots\n   * @memberof CarCIDIterator\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n\n  /**\n   * @returns {AsyncIterator<CID>}\n   */\n  [Symbol.asyncIterator] () {\n    if (this._decoded) {\n      throw new Error('Cannot decode more than once')\n    }\n    /* c8 ignore next 3 */\n    if (!this._iterable) {\n      throw new Error('Block iterable not found')\n    }\n    this._decoded = true\n    const iterable = this._iterable[Symbol.asyncIterator]()\n    return {\n      async next () {\n        const next = await iterable.next()\n        if (next.done) {\n          return next\n        }\n        return { done: false, value: next.value.cid }\n        /* c8 ignore next 2 */\n        // Node.js 12 c8 bug\n      }\n    }\n  }\n\n  /**\n   * Instantiate a {@link CarCIDIterator} from a `Uint8Array` blob. Rather\n   * than decoding the entire byte array prior to returning the iterator, as in\n   * {@link CarReader.fromBytes}, only the header is decoded and the remainder\n   * of the CAR is parsed as the `CID`s as yielded.\n   *\n   * @async\n   * @static\n   * @memberof CarCIDIterator\n   * @param {Uint8Array} bytes\n   * @returns {Promise<CarCIDIterator>}\n   */\n  static async fromBytes (bytes) {\n    const { version, roots, iterator } = await fromBytes(bytes)\n    return new CarCIDIterator(version, roots, iterator)\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n\n  /**\n   * Instantiate a {@link CarCIDIterator} from a `AsyncIterable<Uint8Array>`,\n   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\n   * Rather than decoding the entire byte array prior to returning the iterator,\n   * as in {@link CarReader.fromIterable}, only the header is decoded and the\n   * remainder of the CAR is parsed as the `CID`s as yielded.\n   *\n   * @async\n   * @static\n   * @memberof CarCIDIterator\n   * @param {AsyncIterable<Uint8Array>} asyncIterable\n   * @returns {Promise<CarCIDIterator>}\n   */\n  static async fromIterable (asyncIterable) {\n    const { version, roots, iterator } = await fromIterable(asyncIterable)\n    return new CarCIDIterator(version, roots, iterator)\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}\n */\nasync function fromBytes (bytes) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new TypeError('fromBytes() requires a Uint8Array')\n  }\n  return decodeIterator(bytesReader(bytes))\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n\n/**\n * @param {AsyncIterable<Uint8Array>} asyncIterable\n * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}\n */\nasync function fromIterable (asyncIterable) {\n  if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n    throw new TypeError('fromIterable() requires an async iterable')\n  }\n  return decodeIterator(asyncIterableReader(asyncIterable))\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n\n/**\n * @private\n * @param {BytesReader} reader\n * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}\n */\nasync function decodeIterator (reader) {\n  const decoder = createDecoder(reader)\n  const { version, roots } = await decoder.header()\n  return { version, roots, iterator: decoder.blocks() }\n  /* c8 ignore next 2 */\n  // Node.js 12 c8 bug\n}\n", "import varint from 'varint'\nimport { encode as dagCborEncode } from '@ipld/dag-cbor'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api').Block} Block\n * @typedef {import('./coding').CarEncoder} CarEncoder\n * @typedef {import('./coding').IteratorChannel_Writer<Uint8Array>} IteratorChannel_Writer\n */\n\n/**\n * Create a header from an array of roots.\n *\n * @param {CID[]} roots\n * @returns {Uint8Array}\n */\nexport function createHeader (roots) {\n  const headerBytes = dagCborEncode({ version: 1, roots })\n  const varintBytes = varint.encode(headerBytes.length)\n  const header = new Uint8Array(varintBytes.length + headerBytes.length)\n  header.set(varintBytes, 0)\n  header.set(headerBytes, varintBytes.length)\n  return header\n}\n\n/**\n * @param {IteratorChannel_Writer} writer\n * @returns {CarEncoder}\n */\nfunction createEncoder (writer) {\n  // none of this is wrapped in a mutex, that needs to happen above this to\n  // avoid overwrites\n\n  return {\n    /**\n     * @param {CID[]} roots\n     * @returns {Promise<void>}\n     */\n    async setRoots (roots) {\n      const bytes = createHeader(roots)\n      await writer.write(bytes)\n    },\n\n    /**\n     * @param {Block} block\n     * @returns {Promise<void>}\n     */\n    async writeBlock (block) {\n      const { cid, bytes } = block\n      await writer.write(new Uint8Array(varint.encode(cid.bytes.length + bytes.length)))\n      await writer.write(cid.bytes)\n      if (bytes.length) {\n        // zero-length blocks are valid, but it'd be safer if we didn't write them\n        await writer.write(bytes)\n      }\n    },\n\n    /**\n     * @returns {Promise<void>}\n     */\n    async close () {\n      await writer.end()\n      /* c8 ignore next 2 */\n      // Node.js 12 c8 bug\n    }\n  }\n}\n\nexport { createEncoder }\n", "import { CID } from 'multiformats/cid'\nimport { createEncoder, createHeader } from './encoder.js'\nimport { create as iteratorChannel } from './iterator-channel.js'\nimport { bytesReader, readHeader } from './decoder.js'\n\n/**\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').BlockWriter} BlockWriter\n * @typedef {import('./api').WriterChannel} WriterChannel\n * @typedef {import('./coding').CarEncoder} CarEncoder\n * @typedef {import('./coding').IteratorChannel<Uint8Array>} IteratorChannel\n */\n\n/**\n * Provides a writer interface for the creation of CAR files.\n *\n * Creation of a `CarWriter` involves the instatiation of an input / output pair\n * in the form of a `WriterChannel`, which is a\n * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair. These two\n * components form what can be thought of as a stream-like interface. The\n * `writer` component (an instantiated `CarWriter`), has methods to\n * {@link CarWriter.put `put()`} new blocks and {@link CarWriter.put `close()`}\n * the writing operation (finalising the CAR archive). The `out` component is\n * an `AsyncIterable` that yields the bytes of the archive. This can be\n * redirected to a file or other sink. In Node.js, you can use the\n * [`Readable.from()`](https://nodejs.org/api/stream.html#stream_stream_readable_from_iterable_options)\n * API to convert this to a standard Node.js stream, or it can be directly fed\n * to a\n * [`stream.pipeline()`](https://nodejs.org/api/stream.html#stream_stream_pipeline_source_transforms_destination_callback).\n *\n * The channel will provide a form of backpressure. The `Promise` from a\n * `write()` won't resolve until the resulting data is drained from the `out`\n * iterable.\n *\n * It is also possible to ignore the `Promise` from `write()` calls and allow\n * the generated data to queue in memory. This should be avoided for large CAR\n * archives of course due to the memory costs and potential for memory overflow.\n *\n * Load this class with either\n * `import { CarWriter } from '@ipld/car/writer'`\n * (`const { CarWriter } = require('@ipld/car/writer')`). Or\n * `import { CarWriter } from '@ipld/car'`\n * (`const { CarWriter } = require('@ipld/car')`). The former will likely\n * result in smaller bundle sizes where this is important.\n *\n * @name CarWriter\n * @class\n * @implements {BlockWriter}\n */\nexport class CarWriter {\n  /**\n   * @param {CID[]} roots\n   * @param {CarEncoder} encoder\n   */\n  constructor (roots, encoder) {\n    this._encoder = encoder\n    /** @type {Promise<void>} */\n    this._mutex = encoder.setRoots(roots)\n    this._ended = false\n  }\n\n  /**\n   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.\n   *\n   * @function\n   * @memberof CarWriter\n   * @instance\n   * @async\n   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.\n   * @returns {Promise<void>} The returned promise will only resolve once the\n   * bytes this block generates are written to the `out` iterable.\n   */\n  async put (block) {\n    if (!(block.bytes instanceof Uint8Array) || !block.cid) {\n      throw new TypeError('Can only write {cid, bytes} objects')\n    }\n    if (this._ended) {\n      throw new Error('Already closed')\n    }\n    const cid = CID.asCID(block.cid)\n    if (!cid) {\n      throw new TypeError('Can only write {cid, bytes} objects')\n    }\n    this._mutex = this._mutex.then(() => this._encoder.writeBlock({ cid, bytes: block.bytes }))\n    return this._mutex\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n\n  /**\n   * Finalise the CAR archive and signal that the `out` iterable should end once\n   * any remaining bytes are written.\n   *\n   * @function\n   * @memberof CarWriter\n   * @instance\n   * @async\n   * @returns {Promise<void>}\n   */\n  async close () {\n    if (this._ended) {\n      throw new Error('Already closed')\n    }\n    await this._mutex\n    this._ended = true\n    return this._encoder.close()\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n\n  /**\n   * Create a new CAR writer \"channel\" which consists of a\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @param {CID[] | CID | void} roots\n   * @returns {WriterChannel} The channel takes the form of\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.\n   */\n  static create (roots) {\n    roots = toRoots(roots)\n    const { encoder, iterator } = encodeWriter()\n    const writer = new CarWriter(roots, encoder)\n    const out = new CarWriterOut(iterator)\n    return { writer, out }\n  }\n\n  /**\n   * Create a new CAR appender \"channel\" which consists of a\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.\n   * This appender does not consider roots and does not produce a CAR header.\n   * It is designed to append blocks to an _existing_ CAR archive. It is\n   * expected that `out` will be concatenated onto the end of an existing\n   * archive that already has a properly formatted header.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @returns {WriterChannel} The channel takes the form of\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.\n   */\n  static createAppender () {\n    const { encoder, iterator } = encodeWriter()\n    encoder.setRoots = () => Promise.resolve()\n    const writer = new CarWriter([], encoder)\n    const out = new CarWriterOut(iterator)\n    return { writer, out }\n  }\n\n  /**\n   * Update the list of roots in the header of an existing CAR as represented\n   * in a Uint8Array.\n   *\n   * This operation is an _overwrite_, the total length of the CAR will not be\n   * modified. A rejection will occur if the new header will not be the same\n   * length as the existing header, in which case the CAR will not be modified.\n   * It is the responsibility of the user to ensure that the roots being\n   * replaced encode as the same length as the new roots.\n   *\n   * The byte array passed in an argument will be modified and also returned\n   * upon successful modification.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @param {Uint8Array} bytes\n   * @param {CID[]} roots - A new list of roots to replace the existing list in\n   * the CAR header. The new header must take up the same number of bytes as the\n   * existing header, so the roots should collectively be the same byte length\n   * as the existing roots.\n   * @returns {Promise<Uint8Array>}\n   */\n  static async updateRootsInBytes (bytes, roots) {\n    const reader = bytesReader(bytes)\n    await readHeader(reader)\n    const newHeader = createHeader(roots)\n    if (Number(reader.pos) !== newHeader.length) {\n      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`)\n    }\n    bytes.set(newHeader, 0)\n    return bytes\n    /* c8 ignore next 2 */\n    // Node.js 12 c8 bug\n  }\n}\n\n/**\n * @class\n * @implements {AsyncIterable<Uint8Array>}\n */\nexport class CarWriterOut {\n  /**\n   * @param {AsyncIterator<Uint8Array>} iterator\n   */\n  constructor (iterator) {\n    this._iterator = iterator\n  }\n\n  [Symbol.asyncIterator] () {\n    if (this._iterating) {\n      throw new Error('Multiple iterator not supported')\n    }\n    this._iterating = true\n    return this._iterator\n  }\n}\n\nfunction encodeWriter () {\n  /** @type {IteratorChannel} */\n  const iw = iteratorChannel()\n  const { writer, iterator } = iw\n  const encoder = createEncoder(writer)\n  return { encoder, iterator }\n}\n\n/**\n * @private\n * @param {CID[] | CID | void} roots\n * @returns {CID[]}\n */\nfunction toRoots (roots) {\n  if (roots === undefined) {\n    return []\n  }\n\n  if (!Array.isArray(roots)) {\n    const cid = CID.asCID(roots)\n    if (!cid) {\n      throw new TypeError('roots must be a single CID or an array of CIDs')\n    }\n    return [cid]\n  }\n\n  const _roots = []\n  for (const root of roots) {\n    const _root = CID.asCID(root)\n    if (!_root) {\n      throw new TypeError('roots must be a single CID or an array of CIDs')\n    }\n    _roots.push(_root)\n  }\n  return _roots\n}\n\nexport const __browser = true\n", "import varint from 'varint'\nimport { Token, Type } from 'cborg'\nimport { tokensToLength } from 'cborg/length'\nimport * as CBOR from '@ipld/dag-cbor'\n\n/**\n * @typedef {import('./api').CID} CID\n * @typedef {import('./api').Block} Block\n * @typedef {import('./api').CarBufferWriter} Writer\n * @typedef {import('./api').CarBufferWriterOptions} Options\n * @typedef {import('./coding').CarEncoder} CarEncoder\n */\n\n/**\n * A simple CAR writer that writes to a pre-allocated buffer.\n *\n * @class\n * @name CarBufferWriter\n * @implements {Writer}\n */\nclass CarBufferWriter {\n  /**\n   * @param {Uint8Array} bytes\n   * @param {number} headerSize\n   */\n  constructor (bytes, headerSize) {\n    /** @readonly */\n    this.bytes = bytes\n    this.byteOffset = headerSize\n\n    /**\n     * @readonly\n     * @type {CID[]}\n     */\n    this.roots = []\n    this.headerSize = headerSize\n  }\n\n  /**\n   * Add a root to this writer, to be used to create a header when the CAR is\n   * finalized with {@link CarBufferWriter.close `close()`}\n   *\n   * @param {CID} root\n   * @param {{resize?:boolean}} [options]\n   * @returns {CarBufferWriter}\n   */\n  addRoot (root, options) {\n    addRoot(this, root, options)\n    return this\n  }\n\n  /**\n   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.\n   * Throws if there is not enough capacity.\n   *\n   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.\n   * @returns {CarBufferWriter}\n   */\n  write (block) {\n    addBlock(this, block)\n    return this\n  }\n\n  /**\n   * Finalize the CAR and return it as a `Uint8Array`.\n   *\n   * @param {object} [options]\n   * @param {boolean} [options.resize]\n   * @returns {Uint8Array}\n   */\n  close (options) {\n    return close(this, options)\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {CID} root\n * @param {{resize?:boolean}} [options]\n */\nexport const addRoot = (writer, root, options = {}) => {\n  const { resize = false } = options\n  const { bytes, headerSize, byteOffset, roots } = writer\n  writer.roots.push(root)\n  const size = headerLength(writer)\n  // If there is not enough space for the new root\n  if (size > headerSize) {\n    // Check if we root would fit if we were to resize the head.\n    if (size - headerSize + byteOffset < bytes.byteLength) {\n      // If resize is enabled resize head\n      if (resize) {\n        resizeHeader(writer, size)\n      // otherwise remove head and throw an error suggesting to resize\n      } else {\n        roots.pop()\n        throw new RangeError(`Header of size ${headerSize} has no capacity for new root ${root}.\n  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`)\n      }\n    // If head would not fit even with resize pop new root and throw error\n    } else {\n      roots.pop()\n      throw new RangeError(`Buffer has no capacity for a new root ${root}`)\n    }\n  }\n}\n\n/**\n * Calculates number of bytes required for storing given block in CAR. Useful in\n * estimating size of an `ArrayBuffer` for the `CarBufferWriter`.\n *\n * @name CarBufferWriter.blockLength(Block)\n * @param {Block} block\n * @returns {number}\n */\nexport const blockLength = ({ cid, bytes }) => {\n  const size = cid.bytes.byteLength + bytes.byteLength\n  return varint.encodingLength(size) + size\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {Block} block\n */\nexport const addBlock = (writer, { cid, bytes }) => {\n  const byteLength = cid.bytes.byteLength + bytes.byteLength\n  const size = varint.encode(byteLength)\n  if (writer.byteOffset + size.length + byteLength > writer.bytes.byteLength) {\n    throw new RangeError('Buffer has no capacity for this block')\n  } else {\n    writeBytes(writer, size)\n    writeBytes(writer, cid.bytes)\n    writeBytes(writer, bytes)\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {object} [options]\n * @param {boolean} [options.resize]\n */\nexport const close = (writer, options = {}) => {\n  const { resize = false } = options\n  const { roots, bytes, byteOffset, headerSize } = writer\n\n  const headerBytes = CBOR.encode({ version: 1, roots })\n  const varintBytes = varint.encode(headerBytes.length)\n\n  const size = varintBytes.length + headerBytes.byteLength\n  const offset = headerSize - size\n\n  // If header size estimate was accurate we just write header and return\n  // view into buffer.\n  if (offset === 0) {\n    writeHeader(writer, varintBytes, headerBytes)\n    return bytes.subarray(0, byteOffset)\n    // If header was overestimated and `{resize: true}` is passed resize header\n  } else if (resize) {\n    resizeHeader(writer, size)\n    writeHeader(writer, varintBytes, headerBytes)\n    return bytes.subarray(0, writer.byteOffset)\n  } else {\n    throw new RangeError(`Header size was overestimated.\nYou can use close({ resize: true }) to resize header`)\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {number} byteLength\n */\nexport const resizeHeader = (writer, byteLength) => {\n  const { bytes, headerSize } = writer\n  // Move data section to a new offset\n  bytes.set(bytes.subarray(headerSize, writer.byteOffset), byteLength)\n  // Update header size & byteOffset\n  writer.byteOffset += byteLength - headerSize\n  writer.headerSize = byteLength\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {number[]|Uint8Array} bytes\n */\n\nconst writeBytes = (writer, bytes) => {\n  writer.bytes.set(bytes, writer.byteOffset)\n  writer.byteOffset += bytes.length\n}\n/**\n * @param {{bytes:Uint8Array}} writer\n * @param {number[]} varint\n * @param {Uint8Array} header\n */\nconst writeHeader = ({ bytes }, varint, header) => {\n  bytes.set(varint)\n  bytes.set(header, varint.length)\n}\n\nconst headerPreludeTokens = [\n  new Token(Type.map, 2),\n  new Token(Type.string, 'version'),\n  new Token(Type.uint, 1),\n  new Token(Type.string, 'roots')\n]\n\nconst CID_TAG = new Token(Type.tag, 42)\n\n/**\n * Calculates header size given the array of byteLength for roots.\n *\n * @name CarBufferWriter.calculateHeaderLength(rootLengths)\n * @param {number[]} rootLengths\n * @returns {number}\n */\nexport const calculateHeaderLength = (rootLengths) => {\n  const tokens = [...headerPreludeTokens]\n  tokens.push(new Token(Type.array, rootLengths.length))\n  for (const rootLength of rootLengths) {\n    tokens.push(CID_TAG)\n    tokens.push(new Token(Type.bytes, { length: rootLength + 1 }))\n  }\n  const length = tokensToLength(tokens) // no options needed here because we have simple tokens\n  return varint.encodingLength(length) + length\n}\n\n/**\n * Calculates header size given the array of roots.\n *\n * @name CarBufferWriter.headerLength({ roots })\n * @param {object} options\n * @param {CID[]} options.roots\n * @returns {number}\n */\nexport const headerLength = ({ roots }) =>\n  calculateHeaderLength(roots.map(cid => cid.bytes.byteLength))\n\n/**\n * Estimates header size given a count of the roots and the expected byte length\n * of the root CIDs. The default length works for a standard CIDv1 with a\n * single-byte multihash code, such as SHA2-256 (i.e. the most common CIDv1).\n *\n * @name CarBufferWriter.estimateHeaderLength(rootCount[, rootByteLength])\n * @param {number} rootCount\n * @param {number} [rootByteLength]\n * @returns {number}\n */\nexport const estimateHeaderLength = (rootCount, rootByteLength = 36) =>\n  calculateHeaderLength(new Array(rootCount).fill(rootByteLength))\n\n/**\n * Creates synchronous CAR writer that can be used to encode blocks into a given\n * buffer. Optionally you could pass `byteOffset` and `byteLength` to specify a\n * range inside buffer to write into. If car file is going to have `roots` you\n * need to either pass them under `options.roots` (from which header size will\n * be calculated) or provide `options.headerSize` to allocate required space\n * in the buffer. You may also provide known `roots` and `headerSize` to\n * allocate space for the roots that may not be known ahead of time.\n *\n * Note: Incorrect `headerSize` may lead to copying bytes inside a buffer\n * which will have a negative impact on performance.\n *\n * @name CarBufferWriter.createWriter(buffer[, options])\n * @param {ArrayBuffer} buffer\n * @param {object} [options]\n * @param {CID[]} [options.roots]\n * @param {number} [options.byteOffset]\n * @param {number} [options.byteLength]\n * @param {number} [options.headerSize]\n * @returns {CarBufferWriter}\n */\nexport const createWriter = (buffer, options = {}) => {\n  const {\n    roots = [],\n    byteOffset = 0,\n    byteLength = buffer.byteLength,\n    headerSize = headerLength({ roots })\n  } = options\n  const bytes = new Uint8Array(buffer, byteOffset, byteLength)\n\n  const writer = new CarBufferWriter(bytes, headerSize)\n  for (const root of roots) {\n    writer.addRoot(root)\n  }\n\n  return writer\n}\n", "const typeofs = [\n  'string',\n  'number',\n  'bigint',\n  'symbol'\n];\nconst objectTypeNames = [\n  'Function',\n  'Generator',\n  'AsyncGenerator',\n  'GeneratorFunction',\n  'AsyncGeneratorFunction',\n  'AsyncFunction',\n  'Observable',\n  'Array',\n  'Buffer',\n  'Object',\n  'RegExp',\n  'Date',\n  'Error',\n  'Map',\n  'Set',\n  'WeakMap',\n  'WeakSet',\n  'ArrayBuffer',\n  'SharedArrayBuffer',\n  'DataView',\n  'Promise',\n  'URL',\n  'HTMLElement',\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Uint16Array',\n  'Int32Array',\n  'Uint32Array',\n  'Float32Array',\n  'Float64Array',\n  'BigInt64Array',\n  'BigUint64Array'\n];\nexport function is(value) {\n  if (value === null) {\n    return 'null';\n  }\n  if (value === undefined) {\n    return 'undefined';\n  }\n  if (value === true || value === false) {\n    return 'boolean';\n  }\n  const typeOf = typeof value;\n  if (typeofs.includes(typeOf)) {\n    return typeOf;\n  }\n  if (typeOf === 'function') {\n    return 'Function';\n  }\n  if (Array.isArray(value)) {\n    return 'Array';\n  }\n  if (isBuffer(value)) {\n    return 'Buffer';\n  }\n  const objectType = getObjectType(value);\n  if (objectType) {\n    return objectType;\n  }\n  return 'Object';\n}\nfunction isBuffer(value) {\n  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);\n}\nfunction getObjectType(value) {\n  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);\n  if (objectTypeNames.includes(objectTypeName)) {\n    return objectTypeName;\n  }\n  return undefined;\n}", "class Type {\n  constructor(major, name, terminal) {\n    this.major = major;\n    this.majorEncoded = major << 5;\n    this.name = name;\n    this.terminal = terminal;\n  }\n  toString() {\n    return `Type[${ this.major }].${ this.name }`;\n  }\n  compare(typ) {\n    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;\n  }\n}\nType.uint = new Type(0, 'uint', true);\nType.negint = new Type(1, 'negint', true);\nType.bytes = new Type(2, 'bytes', true);\nType.string = new Type(3, 'string', true);\nType.array = new Type(4, 'array', false);\nType.map = new Type(5, 'map', false);\nType.tag = new Type(6, 'tag', false);\nType.float = new Type(7, 'float', true);\nType.false = new Type(7, 'false', true);\nType.true = new Type(7, 'true', true);\nType.null = new Type(7, 'null', true);\nType.undefined = new Type(7, 'undefined', true);\nType.break = new Type(7, 'break', true);\nclass Token {\n  constructor(type, value, encodedLength) {\n    this.type = type;\n    this.value = value;\n    this.encodedLength = encodedLength;\n    this.encodedBytes = undefined;\n    this.byteValue = undefined;\n  }\n  toString() {\n    return `Token[${ this.type }].${ this.value }`;\n  }\n}\nexport {\n  Type,\n  Token\n};", "export const useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === 'function';\nconst textDecoder = new TextDecoder();\nconst textEncoder = new TextEncoder();\nfunction isBuffer(buf) {\n  return useBuffer && globalThis.Buffer.isBuffer(buf);\n}\nexport function asU8A(buf) {\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf);\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf;\n}\nexport const toString = useBuffer ? (bytes, start, end) => {\n  return end - start > 64 ? globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8') : utf8Slice(bytes, start, end);\n} : (bytes, start, end) => {\n  return end - start > 64 ? textDecoder.decode(bytes.subarray(start, end)) : utf8Slice(bytes, start, end);\n};\nexport const fromString = useBuffer ? string => {\n  return string.length > 64 ? globalThis.Buffer.from(string) : utf8ToBytes(string);\n} : string => {\n  return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string);\n};\nexport const fromArray = arr => {\n  return Uint8Array.from(arr);\n};\nexport const slice = useBuffer ? (bytes, start, end) => {\n  if (isBuffer(bytes)) {\n    return new Uint8Array(bytes.subarray(start, end));\n  }\n  return bytes.slice(start, end);\n} : (bytes, start, end) => {\n  return bytes.slice(start, end);\n};\nexport const concat = useBuffer ? (chunks, length) => {\n  chunks = chunks.map(c => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));\n  return asU8A(globalThis.Buffer.concat(chunks, length));\n} : (chunks, length) => {\n  const out = new Uint8Array(length);\n  let off = 0;\n  for (let b of chunks) {\n    if (off + b.length > out.length) {\n      b = b.subarray(0, out.length - off);\n    }\n    out.set(b, off);\n    off += b.length;\n  }\n  return out;\n};\nexport const alloc = useBuffer ? size => {\n  return globalThis.Buffer.allocUnsafe(size);\n} : size => {\n  return new Uint8Array(size);\n};\nexport const toHex = useBuffer ? d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  return globalThis.Buffer.from(toBytes(d)).toString('hex');\n} : d => {\n  if (typeof d === 'string') {\n    return d;\n  }\n  return Array.prototype.reduce.call(toBytes(d), (p, c) => `${ p }${ c.toString(16).padStart(2, '0') }`, '');\n};\nexport const fromHex = useBuffer ? hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  return globalThis.Buffer.from(hex, 'hex');\n} : hex => {\n  if (hex instanceof Uint8Array) {\n    return hex;\n  }\n  if (!hex.length) {\n    return new Uint8Array(0);\n  }\n  return new Uint8Array(hex.split('').map((c, i, d) => i % 2 === 0 ? `0x${ c }${ d[i + 1] }` : '').filter(Boolean).map(e => parseInt(e, 16)));\n};\nfunction toBytes(obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj;\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj);\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n}\nexport function compare(b1, b2) {\n  if (isBuffer(b1) && isBuffer(b2)) {\n    return b1.compare(b2);\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue;\n    }\n    return b1[i] < b2[i] ? -1 : 1;\n  }\n  return 0;\n}\nfunction utf8ToBytes(string, units = Infinity) {\n  let codePoint;\n  const length = string.length;\n  let leadSurrogate = null;\n  const bytes = [];\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i);\n    if (codePoint > 55295 && codePoint < 57344) {\n      if (!leadSurrogate) {\n        if (codePoint > 56319) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n          continue;\n        } else if (i + 1 === length) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n          continue;\n        }\n        leadSurrogate = codePoint;\n        continue;\n      }\n      if (codePoint < 56320) {\n        if ((units -= 3) > -1)\n          bytes.push(239, 191, 189);\n        leadSurrogate = codePoint;\n        continue;\n      }\n      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n    } else if (leadSurrogate) {\n      if ((units -= 3) > -1)\n        bytes.push(239, 191, 189);\n    }\n    leadSurrogate = null;\n    if (codePoint < 128) {\n      if ((units -= 1) < 0)\n        break;\n      bytes.push(codePoint);\n    } else if (codePoint < 2048) {\n      if ((units -= 2) < 0)\n        break;\n      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n    } else if (codePoint < 65536) {\n      if ((units -= 3) < 0)\n        break;\n      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else if (codePoint < 1114112) {\n      if ((units -= 4) < 0)\n        break;\n      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n    } else {\n      throw new Error('Invalid code point');\n    }\n  }\n  return bytes;\n}\nfunction utf8Slice(buf, offset, end) {\n  const res = [];\n  while (offset < end) {\n    const firstByte = buf[offset];\n    let codePoint = null;\n    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint;\n      switch (bytesPerSequence) {\n      case 1:\n        if (firstByte < 128) {\n          codePoint = firstByte;\n        }\n        break;\n      case 2:\n        secondByte = buf[offset + 1];\n        if ((secondByte & 192) === 128) {\n          tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n          if (tempCodePoint > 127) {\n            codePoint = tempCodePoint;\n          }\n        }\n        break;\n      case 3:\n        secondByte = buf[offset + 1];\n        thirdByte = buf[offset + 2];\n        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n          tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n          if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n            codePoint = tempCodePoint;\n          }\n        }\n        break;\n      case 4:\n        secondByte = buf[offset + 1];\n        thirdByte = buf[offset + 2];\n        fourthByte = buf[offset + 3];\n        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n          tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n          if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n            codePoint = tempCodePoint;\n          }\n        }\n      }\n    }\n    if (codePoint === null) {\n      codePoint = 65533;\n      bytesPerSequence = 1;\n    } else if (codePoint > 65535) {\n      codePoint -= 65536;\n      res.push(codePoint >>> 10 & 1023 | 55296);\n      codePoint = 56320 | codePoint & 1023;\n    }\n    res.push(codePoint);\n    offset += bytesPerSequence;\n  }\n  return decodeCodePointsArray(res);\n}\nconst MAX_ARGUMENTS_LENGTH = 4096;\nexport function decodeCodePointsArray(codePoints) {\n  const len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints);\n  }\n  let res = '';\n  let i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n  }\n  return res;\n}", "import {\n  alloc,\n  concat,\n  slice\n} from './byte-utils.js';\nconst defaultChunkSize = 256;\nexport class Bl {\n  constructor(chunkSize = defaultChunkSize) {\n    this.chunkSize = chunkSize;\n    this.cursor = 0;\n    this.maxCursor = -1;\n    this.chunks = [];\n    this._initReuseChunk = null;\n  }\n  reset() {\n    this.cursor = 0;\n    this.maxCursor = -1;\n    if (this.chunks.length) {\n      this.chunks = [];\n    }\n    if (this._initReuseChunk !== null) {\n      this.chunks.push(this._initReuseChunk);\n      this.maxCursor = this._initReuseChunk.length - 1;\n    }\n  }\n  push(bytes) {\n    let topChunk = this.chunks[this.chunks.length - 1];\n    const newMax = this.cursor + bytes.length;\n    if (newMax <= this.maxCursor + 1) {\n      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;\n      topChunk.set(bytes, chunkPos);\n    } else {\n      if (topChunk) {\n        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;\n        if (chunkPos < topChunk.length) {\n          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);\n          this.maxCursor = this.cursor - 1;\n        }\n      }\n      if (bytes.length < 64 && bytes.length < this.chunkSize) {\n        topChunk = alloc(this.chunkSize);\n        this.chunks.push(topChunk);\n        this.maxCursor += topChunk.length;\n        if (this._initReuseChunk === null) {\n          this._initReuseChunk = topChunk;\n        }\n        topChunk.set(bytes, 0);\n      } else {\n        this.chunks.push(bytes);\n        this.maxCursor += bytes.length;\n      }\n    }\n    this.cursor += bytes.length;\n  }\n  toBytes(reset = false) {\n    let byts;\n    if (this.chunks.length === 1) {\n      const chunk = this.chunks[0];\n      if (reset && this.cursor > chunk.length / 2) {\n        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);\n        this._initReuseChunk = null;\n        this.chunks = [];\n      } else {\n        byts = slice(chunk, 0, this.cursor);\n      }\n    } else {\n      byts = concat(this.chunks, this.cursor);\n    }\n    if (reset) {\n      this.reset();\n    }\n    return byts;\n  }\n}", "const decodeErrPrefix = 'CBOR decode error:';\nconst encodeErrPrefix = 'CBOR encode error:';\nconst uintMinorPrefixBytes = [];\nuintMinorPrefixBytes[23] = 1;\nuintMinorPrefixBytes[24] = 2;\nuintMinorPrefixBytes[25] = 3;\nuintMinorPrefixBytes[26] = 5;\nuintMinorPrefixBytes[27] = 9;\nfunction assertEnoughData(data, pos, need) {\n  if (data.length - pos < need) {\n    throw new Error(`${ decodeErrPrefix } not enough data for type`);\n  }\n}\nexport {\n  decodeErrPrefix,\n  encodeErrPrefix,\n  uintMinorPrefixBytes,\n  assertEnoughData\n};", "import {\n  Token,\n  Type\n} from './token.js';\nimport {\n  decodeErrPrefix,\n  assertEnoughData\n} from './common.js';\nexport const uintBoundaries = [\n  24,\n  256,\n  65536,\n  4294967296,\n  BigInt('18446744073709551616')\n];\nexport function readUint8(data, offset, options) {\n  assertEnoughData(data, offset, 1);\n  const value = data[offset];\n  if (options.strict === true && value < uintBoundaries[0]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\nexport function readUint16(data, offset, options) {\n  assertEnoughData(data, offset, 2);\n  const value = data[offset] << 8 | data[offset + 1];\n  if (options.strict === true && value < uintBoundaries[1]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\nexport function readUint32(data, offset, options) {\n  assertEnoughData(data, offset, 4);\n  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];\n  if (options.strict === true && value < uintBoundaries[2]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  return value;\n}\nexport function readUint64(data, offset, options) {\n  assertEnoughData(data, offset, 8);\n  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];\n  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];\n  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);\n  if (options.strict === true && value < uintBoundaries[3]) {\n    throw new Error(`${ decodeErrPrefix } integer encoded in more bytes than necessary (strict decode)`);\n  }\n  if (value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value);\n  }\n  if (options.allowBigInt === true) {\n    return value;\n  }\n  throw new Error(`${ decodeErrPrefix } integers outside of the safe integer range are not supported`);\n}\nexport function decodeUint8(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);\n}\nexport function decodeUint16(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);\n}\nexport function decodeUint32(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);\n}\nexport function decodeUint64(data, pos, _minor, options) {\n  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);\n}\nexport function encodeUint(buf, token) {\n  return encodeUintValue(buf, 0, token.value);\n}\nexport function encodeUintValue(buf, major, uint) {\n  if (uint < uintBoundaries[0]) {\n    const nuint = Number(uint);\n    buf.push([major | nuint]);\n  } else if (uint < uintBoundaries[1]) {\n    const nuint = Number(uint);\n    buf.push([\n      major | 24,\n      nuint\n    ]);\n  } else if (uint < uintBoundaries[2]) {\n    const nuint = Number(uint);\n    buf.push([\n      major | 25,\n      nuint >>> 8,\n      nuint & 255\n    ]);\n  } else if (uint < uintBoundaries[3]) {\n    const nuint = Number(uint);\n    buf.push([\n      major | 26,\n      nuint >>> 24 & 255,\n      nuint >>> 16 & 255,\n      nuint >>> 8 & 255,\n      nuint & 255\n    ]);\n  } else {\n    const buint = BigInt(uint);\n    if (buint < uintBoundaries[4]) {\n      const set = [\n        major | 27,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0\n      ];\n      let lo = Number(buint & BigInt(4294967295));\n      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));\n      set[8] = lo & 255;\n      lo = lo >> 8;\n      set[7] = lo & 255;\n      lo = lo >> 8;\n      set[6] = lo & 255;\n      lo = lo >> 8;\n      set[5] = lo & 255;\n      set[4] = hi & 255;\n      hi = hi >> 8;\n      set[3] = hi & 255;\n      hi = hi >> 8;\n      set[2] = hi & 255;\n      hi = hi >> 8;\n      set[1] = hi & 255;\n      buf.push(set);\n    } else {\n      throw new Error(`${ decodeErrPrefix } encountered BigInt larger than allowable range`);\n    }\n  }\n}\nencodeUint.encodedSize = function encodedSize(token) {\n  return encodeUintValue.encodedSize(token.value);\n};\nencodeUintValue.encodedSize = function encodedSize(uint) {\n  if (uint < uintBoundaries[0]) {\n    return 1;\n  }\n  if (uint < uintBoundaries[1]) {\n    return 2;\n  }\n  if (uint < uintBoundaries[2]) {\n    return 3;\n  }\n  if (uint < uintBoundaries[3]) {\n    return 5;\n  }\n  return 9;\n};\nencodeUint.compareTokens = function compareTokens(tok1, tok2) {\n  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;\n};", "import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\nexport function decodeNegint8(data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint8(data, pos + 1, options), 2);\n}\nexport function decodeNegint16(data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint16(data, pos + 1, options), 3);\n}\nexport function decodeNegint32(data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint32(data, pos + 1, options), 5);\n}\nconst neg1b = BigInt(-1);\nconst pos1b = BigInt(1);\nexport function decodeNegint64(data, pos, _minor, options) {\n  const int = uint.readUint64(data, pos + 1, options);\n  if (typeof int !== 'bigint') {\n    const value = -1 - int;\n    if (value >= Number.MIN_SAFE_INTEGER) {\n      return new Token(Type.negint, value, 9);\n    }\n  }\n  if (options.allowBigInt !== true) {\n    throw new Error(`${ decodeErrPrefix } integers outside of the safe integer range are not supported`);\n  }\n  return new Token(Type.negint, neg1b - BigInt(int), 9);\n}\nexport function encodeNegint(buf, token) {\n  const negint = token.value;\n  const unsigned = typeof negint === 'bigint' ? negint * neg1b - pos1b : negint * -1 - 1;\n  uint.encodeUintValue(buf, token.type.majorEncoded, unsigned);\n}\nencodeNegint.encodedSize = function encodedSize(token) {\n  const negint = token.value;\n  const unsigned = typeof negint === 'bigint' ? negint * neg1b - pos1b : negint * -1 - 1;\n  if (unsigned < uint.uintBoundaries[0]) {\n    return 1;\n  }\n  if (unsigned < uint.uintBoundaries[1]) {\n    return 2;\n  }\n  if (unsigned < uint.uintBoundaries[2]) {\n    return 3;\n  }\n  if (unsigned < uint.uintBoundaries[3]) {\n    return 5;\n  }\n  return 9;\n};\nencodeNegint.compareTokens = function compareTokens(tok1, tok2) {\n  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;\n};", "import {\n  Token,\n  Type\n} from './token.js';\nimport {\n  assertEnoughData,\n  decodeErrPrefix\n} from './common.js';\nimport * as uint from './0uint.js';\nimport {\n  compare,\n  fromString,\n  slice\n} from './byte-utils.js';\nfunction toToken(data, pos, prefix, length) {\n  assertEnoughData(data, pos, prefix + length);\n  const buf = slice(data, pos + prefix, pos + prefix + length);\n  return new Token(Type.bytes, buf, prefix + length);\n}\nexport function decodeBytesCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeBytes8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeBytes16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeBytes32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeBytes64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer bytes lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nfunction tokenBytes(token) {\n  if (token.encodedBytes === undefined) {\n    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value;\n  }\n  return token.encodedBytes;\n}\nexport function encodeBytes(buf, token) {\n  const bytes = tokenBytes(token);\n  uint.encodeUintValue(buf, token.type.majorEncoded, bytes.length);\n  buf.push(bytes);\n}\nencodeBytes.encodedSize = function encodedSize(token) {\n  const bytes = tokenBytes(token);\n  return uint.encodeUintValue.encodedSize(bytes.length) + bytes.length;\n};\nencodeBytes.compareTokens = function compareTokens(tok1, tok2) {\n  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));\n};\nexport function compareBytes(b1, b2) {\n  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);\n}", "import {\n  Token,\n  Type\n} from './token.js';\nimport {\n  assertEnoughData,\n  decodeErrPrefix\n} from './common.js';\nimport * as uint from './0uint.js';\nimport { encodeBytes } from './2bytes.js';\nimport {\n  toString,\n  slice\n} from './byte-utils.js';\nfunction toToken(data, pos, prefix, length, options) {\n  const totLength = prefix + length;\n  assertEnoughData(data, pos, totLength);\n  const tok = new Token(Type.string, toString(data, pos + prefix, pos + totLength), totLength);\n  if (options.retainStringBytes === true) {\n    tok.byteValue = slice(data, pos + prefix, pos + totLength);\n  }\n  return tok;\n}\nexport function decodeStringCompact(data, pos, minor, options) {\n  return toToken(data, pos, 1, minor, options);\n}\nexport function decodeString8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options), options);\n}\nexport function decodeString16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options), options);\n}\nexport function decodeString32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options), options);\n}\nexport function decodeString64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer string lengths not supported`);\n  }\n  return toToken(data, pos, 9, l, options);\n}\nexport const encodeString = encodeBytes;", "import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\nfunction toToken(_data, _pos, prefix, length) {\n  return new Token(Type.array, length, prefix);\n}\nexport function decodeArrayCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeArray8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeArray16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeArray32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeArray64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer array lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nexport function decodeArrayIndefinite(data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${ decodeErrPrefix } indefinite length items not allowed`);\n  }\n  return toToken(data, pos, 1, Infinity);\n}\nexport function encodeArray(buf, token) {\n  uint.encodeUintValue(buf, Type.array.majorEncoded, token.value);\n}\nencodeArray.compareTokens = uint.encodeUint.compareTokens;\nencodeArray.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};", "import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport { decodeErrPrefix } from './common.js';\nfunction toToken(_data, _pos, prefix, length) {\n  return new Token(Type.map, length, prefix);\n}\nexport function decodeMapCompact(data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor);\n}\nexport function decodeMap8(data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options));\n}\nexport function decodeMap16(data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options));\n}\nexport function decodeMap32(data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options));\n}\nexport function decodeMap64(data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options);\n  if (typeof l === 'bigint') {\n    throw new Error(`${ decodeErrPrefix } 64-bit integer map lengths not supported`);\n  }\n  return toToken(data, pos, 9, l);\n}\nexport function decodeMapIndefinite(data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${ decodeErrPrefix } indefinite length items not allowed`);\n  }\n  return toToken(data, pos, 1, Infinity);\n}\nexport function encodeMap(buf, token) {\n  uint.encodeUintValue(buf, Type.map.majorEncoded, token.value);\n}\nencodeMap.compareTokens = uint.encodeUint.compareTokens;\nencodeMap.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};", "import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nexport function decodeTagCompact(_data, _pos, minor, _options) {\n  return new Token(Type.tag, minor, 1);\n}\nexport function decodeTag8(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint8(data, pos + 1, options), 2);\n}\nexport function decodeTag16(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint16(data, pos + 1, options), 3);\n}\nexport function decodeTag32(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint32(data, pos + 1, options), 5);\n}\nexport function decodeTag64(data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint64(data, pos + 1, options), 9);\n}\nexport function encodeTag(buf, token) {\n  uint.encodeUintValue(buf, Type.tag.majorEncoded, token.value);\n}\nencodeTag.compareTokens = uint.encodeUint.compareTokens;\nencodeTag.encodedSize = function encodedSize(token) {\n  return uint.encodeUintValue.encodedSize(token.value);\n};", "import {\n  Token,\n  Type\n} from './token.js';\nimport { decodeErrPrefix } from './common.js';\nimport { encodeUint } from './0uint.js';\nconst MINOR_FALSE = 20;\nconst MINOR_TRUE = 21;\nconst MINOR_NULL = 22;\nconst MINOR_UNDEFINED = 23;\nexport function decodeUndefined(_data, _pos, _minor, options) {\n  if (options.allowUndefined === false) {\n    throw new Error(`${ decodeErrPrefix } undefined values are not supported`);\n  } else if (options.coerceUndefinedToNull === true) {\n    return new Token(Type.null, null, 1);\n  }\n  return new Token(Type.undefined, undefined, 1);\n}\nexport function decodeBreak(_data, _pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${ decodeErrPrefix } indefinite length items not allowed`);\n  }\n  return new Token(Type.break, undefined, 1);\n}\nfunction createToken(value, bytes, options) {\n  if (options) {\n    if (options.allowNaN === false && Number.isNaN(value)) {\n      throw new Error(`${ decodeErrPrefix } NaN values are not supported`);\n    }\n    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {\n      throw new Error(`${ decodeErrPrefix } Infinity values are not supported`);\n    }\n  }\n  return new Token(Type.float, value, bytes);\n}\nexport function decodeFloat16(data, pos, _minor, options) {\n  return createToken(readFloat16(data, pos + 1), 3, options);\n}\nexport function decodeFloat32(data, pos, _minor, options) {\n  return createToken(readFloat32(data, pos + 1), 5, options);\n}\nexport function decodeFloat64(data, pos, _minor, options) {\n  return createToken(readFloat64(data, pos + 1), 9, options);\n}\nexport function encodeFloat(buf, token, options) {\n  const float = token.value;\n  if (float === false) {\n    buf.push([Type.float.majorEncoded | MINOR_FALSE]);\n  } else if (float === true) {\n    buf.push([Type.float.majorEncoded | MINOR_TRUE]);\n  } else if (float === null) {\n    buf.push([Type.float.majorEncoded | MINOR_NULL]);\n  } else if (float === undefined) {\n    buf.push([Type.float.majorEncoded | MINOR_UNDEFINED]);\n  } else {\n    let decoded;\n    let success = false;\n    if (!options || options.float64 !== true) {\n      encodeFloat16(float);\n      decoded = readFloat16(ui8a, 1);\n      if (float === decoded || Number.isNaN(float)) {\n        ui8a[0] = 249;\n        buf.push(ui8a.slice(0, 3));\n        success = true;\n      } else {\n        encodeFloat32(float);\n        decoded = readFloat32(ui8a, 1);\n        if (float === decoded) {\n          ui8a[0] = 250;\n          buf.push(ui8a.slice(0, 5));\n          success = true;\n        }\n      }\n    }\n    if (!success) {\n      encodeFloat64(float);\n      decoded = readFloat64(ui8a, 1);\n      ui8a[0] = 251;\n      buf.push(ui8a.slice(0, 9));\n    }\n  }\n}\nencodeFloat.encodedSize = function encodedSize(token, options) {\n  const float = token.value;\n  if (float === false || float === true || float === null || float === undefined) {\n    return 1;\n  }\n  if (!options || options.float64 !== true) {\n    encodeFloat16(float);\n    let decoded = readFloat16(ui8a, 1);\n    if (float === decoded || Number.isNaN(float)) {\n      return 3;\n    }\n    encodeFloat32(float);\n    decoded = readFloat32(ui8a, 1);\n    if (float === decoded) {\n      return 5;\n    }\n  }\n  return 9;\n};\nconst buffer = new ArrayBuffer(9);\nconst dataView = new DataView(buffer, 1);\nconst ui8a = new Uint8Array(buffer, 0);\nfunction encodeFloat16(inp) {\n  if (inp === Infinity) {\n    dataView.setUint16(0, 31744, false);\n  } else if (inp === -Infinity) {\n    dataView.setUint16(0, 64512, false);\n  } else if (Number.isNaN(inp)) {\n    dataView.setUint16(0, 32256, false);\n  } else {\n    dataView.setFloat32(0, inp);\n    const valu32 = dataView.getUint32(0);\n    const exponent = (valu32 & 2139095040) >> 23;\n    const mantissa = valu32 & 8388607;\n    if (exponent === 255) {\n      dataView.setUint16(0, 31744, false);\n    } else if (exponent === 0) {\n      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);\n    } else {\n      const logicalExponent = exponent - 127;\n      if (logicalExponent < -24) {\n        dataView.setUint16(0, 0);\n      } else if (logicalExponent < -14) {\n        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);\n      } else {\n        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);\n      }\n    }\n  }\n}\nfunction readFloat16(ui8a, pos) {\n  if (ui8a.length - pos < 2) {\n    throw new Error(`${ decodeErrPrefix } not enough data for float16`);\n  }\n  const half = (ui8a[pos] << 8) + ui8a[pos + 1];\n  if (half === 31744) {\n    return Infinity;\n  }\n  if (half === 64512) {\n    return -Infinity;\n  }\n  if (half === 32256) {\n    return NaN;\n  }\n  const exp = half >> 10 & 31;\n  const mant = half & 1023;\n  let val;\n  if (exp === 0) {\n    val = mant * 2 ** -24;\n  } else if (exp !== 31) {\n    val = (mant + 1024) * 2 ** (exp - 25);\n  } else {\n    val = mant === 0 ? Infinity : NaN;\n  }\n  return half & 32768 ? -val : val;\n}\nfunction encodeFloat32(inp) {\n  dataView.setFloat32(0, inp, false);\n}\nfunction readFloat32(ui8a, pos) {\n  if (ui8a.length - pos < 4) {\n    throw new Error(`${ decodeErrPrefix } not enough data for float32`);\n  }\n  const offset = (ui8a.byteOffset || 0) + pos;\n  return new DataView(ui8a.buffer, offset, 4).getFloat32(0, false);\n}\nfunction encodeFloat64(inp) {\n  dataView.setFloat64(0, inp, false);\n}\nfunction readFloat64(ui8a, pos) {\n  if (ui8a.length - pos < 8) {\n    throw new Error(`${ decodeErrPrefix } not enough data for float64`);\n  }\n  const offset = (ui8a.byteOffset || 0) + pos;\n  return new DataView(ui8a.buffer, offset, 8).getFloat64(0, false);\n}\nencodeFloat.compareTokens = encodeUint.compareTokens;", "import {\n  Token,\n  Type\n} from './token.js';\nimport * as uint from './0uint.js';\nimport * as negint from './1negint.js';\nimport * as bytes from './2bytes.js';\nimport * as string from './3string.js';\nimport * as array from './4array.js';\nimport * as map from './5map.js';\nimport * as tag from './6tag.js';\nimport * as float from './7float.js';\nimport { decodeErrPrefix } from './common.js';\nimport { fromArray } from './byte-utils.js';\nfunction invalidMinor(data, pos, minor) {\n  throw new Error(`${ decodeErrPrefix } encountered invalid minor (${ minor }) for major ${ data[pos] >>> 5 }`);\n}\nfunction errorer(msg) {\n  return () => {\n    throw new Error(`${ decodeErrPrefix } ${ msg }`);\n  };\n}\nexport const jump = [];\nfor (let i = 0; i <= 23; i++) {\n  jump[i] = invalidMinor;\n}\njump[24] = uint.decodeUint8;\njump[25] = uint.decodeUint16;\njump[26] = uint.decodeUint32;\njump[27] = uint.decodeUint64;\njump[28] = invalidMinor;\njump[29] = invalidMinor;\njump[30] = invalidMinor;\njump[31] = invalidMinor;\nfor (let i = 32; i <= 55; i++) {\n  jump[i] = invalidMinor;\n}\njump[56] = negint.decodeNegint8;\njump[57] = negint.decodeNegint16;\njump[58] = negint.decodeNegint32;\njump[59] = negint.decodeNegint64;\njump[60] = invalidMinor;\njump[61] = invalidMinor;\njump[62] = invalidMinor;\njump[63] = invalidMinor;\nfor (let i = 64; i <= 87; i++) {\n  jump[i] = bytes.decodeBytesCompact;\n}\njump[88] = bytes.decodeBytes8;\njump[89] = bytes.decodeBytes16;\njump[90] = bytes.decodeBytes32;\njump[91] = bytes.decodeBytes64;\njump[92] = invalidMinor;\njump[93] = invalidMinor;\njump[94] = invalidMinor;\njump[95] = errorer('indefinite length bytes/strings are not supported');\nfor (let i = 96; i <= 119; i++) {\n  jump[i] = string.decodeStringCompact;\n}\njump[120] = string.decodeString8;\njump[121] = string.decodeString16;\njump[122] = string.decodeString32;\njump[123] = string.decodeString64;\njump[124] = invalidMinor;\njump[125] = invalidMinor;\njump[126] = invalidMinor;\njump[127] = errorer('indefinite length bytes/strings are not supported');\nfor (let i = 128; i <= 151; i++) {\n  jump[i] = array.decodeArrayCompact;\n}\njump[152] = array.decodeArray8;\njump[153] = array.decodeArray16;\njump[154] = array.decodeArray32;\njump[155] = array.decodeArray64;\njump[156] = invalidMinor;\njump[157] = invalidMinor;\njump[158] = invalidMinor;\njump[159] = array.decodeArrayIndefinite;\nfor (let i = 160; i <= 183; i++) {\n  jump[i] = map.decodeMapCompact;\n}\njump[184] = map.decodeMap8;\njump[185] = map.decodeMap16;\njump[186] = map.decodeMap32;\njump[187] = map.decodeMap64;\njump[188] = invalidMinor;\njump[189] = invalidMinor;\njump[190] = invalidMinor;\njump[191] = map.decodeMapIndefinite;\nfor (let i = 192; i <= 215; i++) {\n  jump[i] = tag.decodeTagCompact;\n}\njump[216] = tag.decodeTag8;\njump[217] = tag.decodeTag16;\njump[218] = tag.decodeTag32;\njump[219] = tag.decodeTag64;\njump[220] = invalidMinor;\njump[221] = invalidMinor;\njump[222] = invalidMinor;\njump[223] = invalidMinor;\nfor (let i = 224; i <= 243; i++) {\n  jump[i] = errorer('simple values are not supported');\n}\njump[244] = invalidMinor;\njump[245] = invalidMinor;\njump[246] = invalidMinor;\njump[247] = float.decodeUndefined;\njump[248] = errorer('simple values are not supported');\njump[249] = float.decodeFloat16;\njump[250] = float.decodeFloat32;\njump[251] = float.decodeFloat64;\njump[252] = invalidMinor;\njump[253] = invalidMinor;\njump[254] = invalidMinor;\njump[255] = float.decodeBreak;\nexport const quick = [];\nfor (let i = 0; i < 24; i++) {\n  quick[i] = new Token(Type.uint, i, 1);\n}\nfor (let i = -1; i >= -24; i--) {\n  quick[31 - i] = new Token(Type.negint, i, 1);\n}\nquick[64] = new Token(Type.bytes, new Uint8Array(0), 1);\nquick[96] = new Token(Type.string, '', 1);\nquick[128] = new Token(Type.array, 0, 1);\nquick[160] = new Token(Type.map, 0, 1);\nquick[244] = new Token(Type.false, false, 1);\nquick[245] = new Token(Type.true, true, 1);\nquick[246] = new Token(Type.null, null, 1);\nexport function quickEncodeToken(token) {\n  switch (token.type) {\n  case Type.false:\n    return fromArray([244]);\n  case Type.true:\n    return fromArray([245]);\n  case Type.null:\n    return fromArray([246]);\n  case Type.bytes:\n    if (!token.value.length) {\n      return fromArray([64]);\n    }\n    return;\n  case Type.string:\n    if (token.value === '') {\n      return fromArray([96]);\n    }\n    return;\n  case Type.array:\n    if (token.value === 0) {\n      return fromArray([128]);\n    }\n    return;\n  case Type.map:\n    if (token.value === 0) {\n      return fromArray([160]);\n    }\n    return;\n  case Type.uint:\n    if (token.value < 24) {\n      return fromArray([Number(token.value)]);\n    }\n    return;\n  case Type.negint:\n    if (token.value >= -24) {\n      return fromArray([31 - Number(token.value)]);\n    }\n  }\n}", "import { is } from './is.js';\nimport {\n  Token,\n  Type\n} from './token.js';\nimport { Bl } from './bl.js';\nimport { encodeErrPrefix } from './common.js';\nimport { quickEncodeToken } from './jump.js';\nimport { asU8A } from './byte-utils.js';\nimport { encodeUint } from './0uint.js';\nimport { encodeNegint } from './1negint.js';\nimport { encodeBytes } from './2bytes.js';\nimport { encodeString } from './3string.js';\nimport { encodeArray } from './4array.js';\nimport { encodeMap } from './5map.js';\nimport { encodeTag } from './6tag.js';\nimport { encodeFloat } from './7float.js';\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n};\nexport function makeCborEncoders() {\n  const encoders = [];\n  encoders[Type.uint.major] = encodeUint;\n  encoders[Type.negint.major] = encodeNegint;\n  encoders[Type.bytes.major] = encodeBytes;\n  encoders[Type.string.major] = encodeString;\n  encoders[Type.array.major] = encodeArray;\n  encoders[Type.map.major] = encodeMap;\n  encoders[Type.tag.major] = encodeTag;\n  encoders[Type.float.major] = encodeFloat;\n  return encoders;\n}\nconst cborEncoders = makeCborEncoders();\nconst buf = new Bl();\nclass Ref {\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n  includes(obj) {\n    let p = this;\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent);\n    return false;\n  }\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${ encodeErrPrefix } object contains circular references`);\n    }\n    return new Ref(obj, stack);\n  }\n}\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n};\nconst typeEncoders = {\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj);\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj);\n  },\n  string(obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj);\n  },\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj));\n  },\n  DataView(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyArray,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyArray;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.array, obj.length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.array, obj.length),\n      entries\n    ];\n  },\n  Object(obj, typ, options, refStack) {\n    const isMap = typ !== 'Object';\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyMap,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyMap;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ];\n    }\n    sortMapEntries(entries, options);\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.map, length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.map, length),\n      entries\n    ];\n  }\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${ typ }Array`] = typeEncoders.DataView;\n}\nfunction objectToTokens(obj, options = {}, refStack) {\n  const typ = is(obj);\n  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n  const typeEncoder = typeEncoders[typ];\n  if (!typeEncoder) {\n    throw new Error(`${ encodeErrPrefix } unsupported type: ${ typ }`);\n  }\n  return typeEncoder(obj, typ, options, refStack);\n}\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\nfunction mapSorter(e1, e2) {\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n  const major = keyToken1.type.major;\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n  return tcmp;\n}\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n    if (quickBytes) {\n      return quickBytes;\n    }\n    const encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new Bl(size);\n      encoder(buf, tokens, options);\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${ tokens } was wrong`);\n      }\n      return asU8A(buf.chunks[0]);\n    }\n  }\n  buf.reset();\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\nexport {\n  objectToTokens,\n  encode,\n  encodeCustom,\n  Ref\n};", "import { decodeErrPrefix } from './common.js';\nimport { Type } from './token.js';\nimport {\n  jump,\n  quick\n} from './jump.js';\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n};\nclass Tokeniser {\n  constructor(data, options = {}) {\n    this.pos = 0;\n    this.data = data;\n    this.options = options;\n  }\n  done() {\n    return this.pos >= this.data.length;\n  }\n  next() {\n    const byt = this.data[this.pos];\n    let token = quick[byt];\n    if (token === undefined) {\n      const decoder = jump[byt];\n      if (!decoder) {\n        throw new Error(`${ decodeErrPrefix } no decoder for major type ${ byt >>> 5 } (byte 0x${ byt.toString(16).padStart(2, '0') })`);\n      }\n      const minor = byt & 31;\n      token = decoder(this.data, this.pos, minor, this.options);\n    }\n    this.pos += token.encodedLength;\n    return token;\n  }\n}\nconst DONE = Symbol.for('DONE');\nconst BREAK = Symbol.for('BREAK');\nfunction tokenToArray(token, tokeniser, options) {\n  const arr = [];\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options);\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        break;\n      }\n      throw new Error(`${ decodeErrPrefix } got unexpected break to lengthed array`);\n    }\n    if (value === DONE) {\n      throw new Error(`${ decodeErrPrefix } found array but not enough entries (got ${ i }, expected ${ token.value })`);\n    }\n    arr[i] = value;\n  }\n  return arr;\n}\nfunction tokenToMap(token, tokeniser, options) {\n  const useMaps = options.useMaps === true;\n  const obj = useMaps ? undefined : {};\n  const m = useMaps ? new Map() : undefined;\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options);\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        break;\n      }\n      throw new Error(`${ decodeErrPrefix } got unexpected break to lengthed map`);\n    }\n    if (key === DONE) {\n      throw new Error(`${ decodeErrPrefix } found map but not enough entries (got ${ i } [no key], expected ${ token.value })`);\n    }\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${ decodeErrPrefix } non-string keys not supported (got ${ typeof key })`);\n    }\n    if (options.rejectDuplicateMapKeys === true) {\n      if (useMaps && m.has(key) || !useMaps && key in obj) {\n        throw new Error(`${ decodeErrPrefix } found repeat map key \"${ key }\"`);\n      }\n    }\n    const value = tokensToObject(tokeniser, options);\n    if (value === DONE) {\n      throw new Error(`${ decodeErrPrefix } found map but not enough entries (got ${ i } [no value], expected ${ token.value })`);\n    }\n    if (useMaps) {\n      m.set(key, value);\n    } else {\n      obj[key] = value;\n    }\n  }\n  return useMaps ? m : obj;\n}\nfunction tokensToObject(tokeniser, options) {\n  if (tokeniser.done()) {\n    return DONE;\n  }\n  const token = tokeniser.next();\n  if (token.type === Type.break) {\n    return BREAK;\n  }\n  if (token.type.terminal) {\n    return token.value;\n  }\n  if (token.type === Type.array) {\n    return tokenToArray(token, tokeniser, options);\n  }\n  if (token.type === Type.map) {\n    return tokenToMap(token, tokeniser, options);\n  }\n  if (token.type === Type.tag) {\n    if (options.tags && typeof options.tags[token.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options);\n      return options.tags[token.value](tagged);\n    }\n    throw new Error(`${ decodeErrPrefix } tag not supported (${ token.value })`);\n  }\n  throw new Error('unsupported');\n}\nfunction decode(data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${ decodeErrPrefix } data to decode must be a Uint8Array`);\n  }\n  options = Object.assign({}, defaultDecodeOptions, options);\n  const tokeniser = options.tokenizer || new Tokeniser(data, options);\n  const decoded = tokensToObject(tokeniser, options);\n  if (decoded === DONE) {\n    throw new Error(`${ decodeErrPrefix } did not find any content to decode`);\n  }\n  if (decoded === BREAK) {\n    throw new Error(`${ decodeErrPrefix } got unexpected break`);\n  }\n  if (!tokeniser.done()) {\n    throw new Error(`${ decodeErrPrefix } too many terminals, data makes no sense`);\n  }\n  return decoded;\n}\nexport {\n  Tokeniser,\n  tokensToObject,\n  decode\n};", "import {\n  makeCborEncoders,\n  objectToTokens\n} from './encode.js';\nimport { quickEncodeToken } from './jump.js';\nconst cborEncoders = makeCborEncoders();\nconst defaultEncodeOptions = {\n  float64: false,\n  quickEncodeToken\n};\nexport function encodedLength(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  options.mapSorter = undefined;\n  const tokens = objectToTokens(data, options);\n  return tokensToLength(tokens, cborEncoders, options);\n}\nexport function tokensToLength(tokens, encoders = cborEncoders, options = defaultEncodeOptions) {\n  if (Array.isArray(tokens)) {\n    let len = 0;\n    for (const token of tokens) {\n      len += tokensToLength(token, encoders, options);\n    }\n    return len;\n  } else {\n    const encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize === undefined || typeof encoder.encodedSize !== 'function') {\n      throw new Error(`Encoder for ${ tokens.type.name } does not have an encodedSize()`);\n    }\n    return encoder.encodedSize(tokens, options);\n  }\n}", "import * as Digest from './digest.js'\n\n/**\n * @template {string} Name\n * @template {number} Code\n * @param {object} options\n * @param {Name} options.name\n * @param {Code} options.code\n * @param {(input: Uint8Array) => Await<Uint8Array>} options.encode\n */\nexport const from = ({ name, code, encode }) => new Hasher(name, code, encode)\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n *\n * @template {string} Name\n * @template {number} Code\n * @class\n * @implements {MultihashHasher<Code>}\n */\nexport class Hasher {\n  /**\n   *\n   * @param {Name} name\n   * @param {Code} code\n   * @param {(input: Uint8Array) => Await<Uint8Array>} encode\n   */\n  constructor (name, code, encode) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n  }\n\n  /**\n   * @param {Uint8Array} input\n   * @returns {Await<Digest.Digest<Code, number>>}\n   */\n  digest (input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n      return result instanceof Uint8Array\n        ? Digest.create(this.code, result)\n        /* c8 ignore next 1 */\n        : result.then(digest => Digest.create(this.code, digest))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n\n/**\n * @template {number} Alg\n * @typedef {import('./interface.js').MultihashHasher} MultihashHasher\n */\n\n/**\n * @template T\n * @typedef {Promise<T>|T} Await\n */\n", "import { bytes as binary, CID } from './index.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\nfunction readonly ({ enumerable = true, configurable = false } = {}) {\n  return { enumerable, configurable, writable: false }\n}\n\n/**\n * @param {[string|number, string]} path\n * @param {any} value\n * @returns {Iterable<[string, CID]>}\n */\nfunction * linksWithin (path, value) {\n  if (value != null && typeof value === 'object') {\n    if (Array.isArray(value)) {\n      for (const [index, element] of value.entries()) {\n        const elementPath = [...path, index]\n        const cid = CID.asCID(element)\n        if (cid) {\n          yield [elementPath.join('/'), cid]\n        } else if (typeof element === 'object') {\n          yield * links(element, elementPath)\n        }\n      }\n    } else {\n      const cid = CID.asCID(value)\n      if (cid) {\n        yield [path.join('/'), cid]\n      } else {\n        yield * links(value, path)\n      }\n    }\n  }\n}\n\n/**\n * @template T\n * @param {T} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\nfunction * links (source, base) {\n  if (source == null || source instanceof Uint8Array) {\n    return\n  }\n  const cid = CID.asCID(source)\n  if (cid) {\n    yield [base.join('/'), cid]\n  }\n  for (const [key, value] of Object.entries(source)) {\n    const path = /** @type {[string|number, string]} */ ([...base, key])\n    yield * linksWithin(path, value)\n  }\n}\n\n/**\n * @param {[string|number, string]} path\n * @param {any} value\n * @returns {Iterable<string>}\n */\nfunction * treeWithin (path, value) {\n  if (Array.isArray(value)) {\n    for (const [index, element] of value.entries()) {\n      const elementPath = [...path, index]\n      yield elementPath.join('/')\n      if (typeof element === 'object' && !CID.asCID(element)) {\n        yield * tree(element, elementPath)\n      }\n    }\n  } else {\n    yield * tree(value, path)\n  }\n}\n\n/**\n * @template T\n * @param {T} source\n * @param {Array<string|number>} base\n * @returns {Iterable<string>}\n */\nfunction * tree (source, base) {\n  if (source == null || typeof source !== 'object') {\n    return\n  }\n  for (const [key, value] of Object.entries(source)) {\n    const path = /** @type {[string|number, string]} */ ([...base, key])\n    yield path.join('/')\n    if (value != null && !(value instanceof Uint8Array) && typeof value === 'object' && !CID.asCID(value)) {\n      yield * treeWithin(path, value)\n    }\n  }\n}\n\n/**\n *\n * @template T\n * @param {T} source\n * @param {string[]} path\n * @returns {API.BlockCursorView<unknown>}\n */\nfunction get (source, path) {\n  let node = /** @type {Record<string, any>} */(source)\n  for (const [index, key] of path.entries()) {\n    node = node[key]\n    if (node == null) {\n      throw new Error(`Object has no property at ${path.slice(0, index + 1).map(part => `[${JSON.stringify(part)}]`).join('')}`)\n    }\n    const cid = CID.asCID(node)\n    if (cid) {\n      return { value: cid, remaining: path.slice(index + 1).join('/') }\n    }\n  }\n  return { value: node }\n}\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} C - multicodec code corresponding to codec used to encode the block\n * @template {number} A - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template {API.Version} V - CID version\n * @implements {API.BlockView<T, C, A, V>}\n */\nclass Block {\n  /**\n   * @param {object} options\n   * @param {CID<T, C, A, V>} options.cid\n   * @param {API.ByteView<T>} options.bytes\n   * @param {T} options.value\n   */\n  constructor ({ cid, bytes, value }) {\n    if (!cid || !bytes || typeof value === 'undefined') { throw new Error('Missing required argument') }\n\n    this.cid = cid\n    this.bytes = bytes\n    this.value = value\n    this.asBlock = this\n\n    // Mark all the properties immutable\n    Object.defineProperties(this, {\n      cid: readonly(),\n      bytes: readonly(),\n      value: readonly(),\n      asBlock: readonly()\n    })\n  }\n\n  links () {\n    return links(this.value, [])\n  }\n\n  tree () {\n    return tree(this.value, [])\n  }\n\n  /**\n   *\n   * @param {string} [path]\n   * @returns {API.BlockCursorView<unknown>}\n   */\n  get (path = '/') {\n    return get(this.value, path.split('/').filter(Boolean))\n  }\n}\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @param {object} options\n * @param {T} options.value\n * @param {API.BlockEncoder<Code, T>} options.codec\n * @param {API.MultihashHasher<Alg>} options.hasher\n * @returns {Promise<API.BlockView<T, Code, Alg>>}\n */\nasync function encode ({ value, codec, hasher }) {\n  if (typeof value === 'undefined') throw new Error('Missing required argument \"value\"')\n  if (!codec || !hasher) throw new Error('Missing required argument: codec or hasher')\n\n  const bytes = codec.encode(value)\n  const hash = await hasher.digest(bytes)\n  /** @type {CID<T, Code, Alg, 1>} */\n  const cid = CID.create(\n    1,\n    codec.code,\n    hash\n  )\n\n  return new Block({ value, bytes, cid })\n}\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @param {object} options\n * @param {API.ByteView<T>} options.bytes\n * @param {API.BlockDecoder<Code, T>} options.codec\n * @param {API.MultihashHasher<Alg>} options.hasher\n * @returns {Promise<API.BlockView<T, Code, Alg>>}\n */\nasync function decode ({ bytes, codec, hasher }) {\n  if (!bytes) throw new Error('Missing required argument \"bytes\"')\n  if (!codec || !hasher) throw new Error('Missing required argument: codec or hasher')\n\n  const value = codec.decode(bytes)\n  const hash = await hasher.digest(bytes)\n  /** @type {CID<T, Code, Alg, 1>} */\n  const cid = CID.create(1, codec.code, hash)\n\n  return new Block({ value, bytes, cid })\n}\n\n/**\n * @typedef {object} RequiredCreateOptions\n * @property {CID} options.cid\n */\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template {API.Version} V - CID version\n * @param {{ cid: API.Link<T, Code, Alg, V>, value:T, codec?: API.BlockDecoder<Code, T>, bytes: API.ByteView<T> }|{cid:API.Link<T, Code, Alg, V>, bytes:API.ByteView<T>, value?:void, codec:API.BlockDecoder<Code, T>}} options\n * @returns {API.BlockView<T, Code, Alg, V>}\n */\nfunction createUnsafe ({ bytes, cid, value: maybeValue, codec }) {\n  const value = maybeValue !== undefined\n    ? maybeValue\n    : (codec && codec.decode(bytes))\n\n  if (value === undefined) throw new Error('Missing required argument, must either provide \"value\" or \"codec\"')\n\n  return new Block({\n    // eslint-disable-next-line object-shorthand\n    cid: /** @type {CID<T, Code, Alg, V>} */ (cid),\n    bytes,\n    value\n  })\n}\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template {API.Version} V - CID version\n * @param {object} options\n * @param {API.Link<T, Code, Alg, V>} options.cid\n * @param {API.ByteView<T>} options.bytes\n * @param {API.BlockDecoder<Code, T>} options.codec\n * @param {API.MultihashHasher<Alg>} options.hasher\n * @returns {Promise<API.BlockView<T, Code, Alg, V>>}\n */\nasync function create ({ bytes, cid, hasher, codec }) {\n  if (!bytes) throw new Error('Missing required argument \"bytes\"')\n  if (!hasher) throw new Error('Missing required argument \"hasher\"')\n  const value = codec.decode(bytes)\n  const hash = await hasher.digest(bytes)\n  if (!binary.equals(cid.multihash.bytes, hash.bytes)) {\n    throw new Error('CID hash does not match bytes')\n  }\n\n  return createUnsafe({\n    bytes,\n    cid,\n    value,\n    codec\n  })\n}\n\nexport { encode, decode, create, createUnsafe, Block }\n", "/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n", "// @ts-check\n\nimport { coerce } from '../bytes.js'\n\n/**\n * @template T\n * @typedef {import('./interface.js').ByteView<T>} ByteView\n */\n\nexport const name = 'raw'\nexport const code = 0x55\n\n/**\n * @param {Uint8Array} node\n * @returns {ByteView<Uint8Array>}\n */\nexport const encode = (node) => coerce(node)\n\n/**\n * @param {ByteView<Uint8Array>} data\n * @returns {Uint8Array}\n */\nexport const decode = (data) => coerce(data)\n", "import { CID } from 'multiformats'\nimport { Block, encode, decode } from 'multiformats/block'\nimport { sha256 as hasher } from 'multiformats/hashes/sha2'\nimport * as raw from 'multiformats/codecs/raw'\nimport * as CBW from '@ipld/car/buffer-writer'\nimport * as codec from '@ipld/dag-cbor'\nimport { CarReader } from '@ipld/car'\n\nimport { AnyBlock, AnyCarHeader, AnyLink, CarMakeable } from './types'\n// import { Transaction } from './transaction'\n\nexport async function encodeCarFile(roots: AnyLink[], t: CarMakeable): Promise<AnyBlock> {\n  let size = 0\n  const headerSize = CBW.headerLength({ roots } as { roots: CID<unknown, number, number, 1>[]})\n  size += headerSize\n  for (const { cid, bytes } of t.entries()) {\n    size += CBW.blockLength({ cid, bytes } as Block<unknown, number, number, 1>)\n  }\n  const buffer = new Uint8Array(size)\n  const writer = CBW.createWriter(buffer, { headerSize })\n\n  for (const r of roots) {\n    writer.addRoot(r as CID<unknown, number, number, 1>)\n  }\n\n  for (const { cid, bytes } of t.entries()) {\n    writer.write({ cid, bytes } as Block<unknown, number, number, 1>)\n  }\n  writer.close()\n  return await encode({ value: writer.bytes, hasher, codec: raw })\n}\n\nexport async function encodeCarHeader(fp: AnyCarHeader) {\n  return (await encode({\n    value: { fp },\n    hasher,\n    codec\n  })) as AnyBlock\n}\n\nexport async function parseCarFile(reader: CarReader): Promise<AnyCarHeader> {\n  const roots = await reader.getRoots()\n  const header = await reader.get(roots[0])\n  if (!header) throw new Error('missing header block')\n  const { value } = await decode({ bytes: header.bytes, hasher, codec })\n  // @ts-ignore\n  if (value && value.fp === undefined) throw new Error('missing fp')\n  const { fp } = value as { fp: AnyCarHeader }\n  return fp\n}\n", "// from https://github.com/mikeal/encrypted-block\nimport { CID } from 'multiformats'\nimport type { AnyLink } from './types'\nimport { crypto, randomBytes } from './crypto-web'\n\nconst enc32 = (value: number) => {\n  value = +value\n  const buff = new Uint8Array(4)\n  buff[3] = (value >>> 24)\n  buff[2] = (value >>> 16)\n  buff[1] = (value >>> 8)\n  buff[0] = (value & 0xff)\n  return buff\n}\n\nconst readUInt32LE = (buffer: Uint8Array) => {\n  const offset = buffer.byteLength - 4\n  return ((buffer[offset]) |\n    (buffer[offset + 1] << 8) |\n    (buffer[offset + 2] << 16)) +\n    (buffer[offset + 3] * 0x1000000)\n}\n\nconst concat = (buffers: Array<ArrayBuffer | Uint8Array>) => {\n  const uint8Arrays = buffers.map(b => b instanceof ArrayBuffer ? new Uint8Array(b) : b)\n  const totalLength = uint8Arrays.reduce((sum, arr) => sum + arr.length, 0)\n  const result = new Uint8Array(totalLength)\n\n  let offset = 0\n  for (const arr of uint8Arrays) {\n    result.set(arr, offset)\n    offset += arr.length\n  }\n\n  return result\n}\n\nconst encode = ({ iv, bytes }: { iv: Uint8Array, bytes: Uint8Array }) => concat([iv, bytes])\nconst decode = (bytes: Uint8Array) => {\n  const iv = bytes.subarray(0, 12)\n  bytes = bytes.slice(12)\n  return { iv, bytes }\n}\n\nconst code = 0x300000 + 1337\n\nasync function subtleKey(key: ArrayBuffer) {\n  return await crypto!.subtle.importKey(\n    'raw', // raw or jwk\n    key, // raw data\n    'AES-GCM',\n    false, // extractable\n    ['encrypt', 'decrypt']\n  )\n}\n\nconst decrypt = async ({ key, value }:\n  {\n    key: ArrayBuffer, value: { bytes: Uint8Array, iv: Uint8Array }\n  }): Promise<{ cid: AnyLink, bytes: Uint8Array }> => {\n  let { bytes, iv } = value\n  const cryKey = await subtleKey(key)\n  const deBytes = await crypto!.subtle.decrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n      tagLength: 128\n    },\n    cryKey,\n    bytes\n  )\n  bytes = new Uint8Array(deBytes)\n  const len = readUInt32LE(bytes.subarray(0, 4))\n  const cid = CID.decode(bytes.subarray(4, 4 + len))\n  bytes = bytes.subarray(4 + len)\n  return { cid, bytes }\n}\nconst encrypt = async ({ key, cid, bytes }: { key: ArrayBuffer, cid: AnyLink, bytes: Uint8Array }) => {\n  const len = enc32(cid.bytes.byteLength)\n  const iv = randomBytes(12)\n  const msg = concat([len, cid.bytes, bytes])\n  try {\n    const cryKey = await subtleKey(key)\n    const deBytes = await crypto!.subtle.encrypt(\n      {\n        name: 'AES-GCM',\n        iv,\n        tagLength: 128\n      },\n      cryKey,\n      msg\n    )\n    bytes = new Uint8Array(deBytes)\n  } catch (e) {\n    console.log('ee', e)\n    throw e\n  }\n  return { value: { bytes, iv } }\n}\n\nconst cryptoFn = (key: Uint8Array) => {\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n  return { encrypt: opts => encrypt({ key, ...opts }), decrypt: opts => decrypt({ key, ...opts }) }\n}\n\nconst name = 'jchris@encrypted-block:aes-gcm'\n\nexport { encode, decode, code, name, encrypt, decrypt, cryptoFn as crypto }\n", "export function getCrypto() {\n  try {\n    if (crypto && crypto.subtle) {\n      return crypto\n    } else {\n      return new Crypto()\n    }\n  } catch (e) {\n    return null\n  }\n}\nconst gotCrypto = getCrypto()\n\nexport { gotCrypto as crypto }\n\nexport function randomBytes(size: number) {\n  const bytes = new Uint8Array(size)\n  if (size > 0) {\n    crypto!.getRandomValues(bytes)\n  }\n  return bytes\n}\n", "const readUInt32LE = buffer => {\n  const offset = buffer.byteLength - 4;\n  return (buffer[offset] | buffer[offset + 1] << 8 | buffer[offset + 2] << 16) + buffer[offset + 3] * 16777216;\n};\nconst MAX_UINT32 = 4294967295;\nconst bf = factor => {\n  const threshold = Math.floor(MAX_UINT32 / factor);\n  return async entry => {\n    const identity = await entry.identity();\n    if (typeof identity !== 'number') {\n      throw new Error('Identity must be a number');\n    }\n    if (identity <= threshold) {\n      return true;\n    }\n    return false;\n  };\n};\nconst enc32 = value => {\n  value = +value;\n  const buff = new Uint8Array(4);\n  buff[3] = value >>> 24;\n  buff[2] = value >>> 16;\n  buff[1] = value >>> 8;\n  buff[0] = value & 255;\n  return buff;\n};\nconst simpleCompare = (a, b) => {\n  if (a === b)\n    return 0;\n  if (a > b)\n    return 1;\n  return -1;\n};\nconst binaryCompare = (b1, b2) => {\n  for (let i = 0; i < b1.byteLength; i++) {\n    if (b2.byteLength === i)\n      return 1;\n    const c1 = b1[i];\n    const c2 = b2[i];\n    if (c1 === c2)\n      continue;\n    if (c1 > c2)\n      return 1;\n    else\n      return -1;\n  }\n  if (b2.byteLength > b1.byteLength)\n    return -1;\n  return 0;\n};\nclass CIDCounter {\n  constructor() {\n    this._cids = new Set();\n  }\n  add(node) {\n    if (!node.address) {\n      throw new Error('Cannot add node without address');\n    }\n    if (node.address.then) {\n      const p = node.address.then(cid => this._cids.add(cid.toString()));\n      this._cids.add(p);\n      p.then(() => this._cids.delete(p));\n    } else {\n      this._cids.add(node.address.toString());\n    }\n  }\n  async all() {\n    await Promise.all([...this._cids]);\n    return this._cids;\n  }\n}\nexport {\n  readUInt32LE,\n  enc32,\n  bf,\n  binaryCompare,\n  simpleCompare,\n  CIDCounter\n};", "import { encode as multiformatEncode } from 'multiformats/block';\nimport { CIDCounter } from './utils.js';\nclass Entry {\n  constructor({key, address}, opts = {}) {\n    this.key = key;\n    this.address = address;\n    this.codec = opts.codec;\n    this.hasher = opts.hasher;\n  }\n  get isEntry() {\n    return true;\n  }\n}\nclass EntryList {\n  constructor({entries, closed}) {\n    if (typeof closed !== 'boolean')\n      throw new Error('Missing required argument \"closed\"');\n    this.entries = entries;\n    this.closed = closed;\n    this.startKey = entries[0].key;\n  }\n  find(key, compare) {\n    const {entries} = this;\n    for (let i = entries.length - 1; i > -1; i--) {\n      const entry = entries[i];\n      const comp = compare(key, entry.key);\n      if (comp > -1) {\n        return [\n          i,\n          entry\n        ];\n      }\n    }\n    return null;\n  }\n  findMany(keys, compare, sorted = false, strict = false) {\n    const {entries} = this;\n    const results = new Map();\n    if (!sorted) {\n      keys = keys.sort(compare);\n    } else {\n      keys = [...keys];\n    }\n    for (let i = entries.length - 1; i > -1; i--) {\n      if (!keys.length)\n        break;\n      const entry = entries[i];\n      const found = [];\n      while (keys.length) {\n        let key = keys[keys.length - 1];\n        key = key.key ? key.key : key;\n        const comp = compare(key, entry.key);\n        if (!strict) {\n          if (comp > -1) {\n            found.push(keys.pop());\n          } else {\n            break;\n          }\n        } else {\n          if (comp === 0) {\n            found.push(keys.pop());\n          } else if (comp > 0) {\n            keys.pop();\n          } else {\n            break;\n          }\n        }\n      }\n      if (found.length) {\n        results.set(i, [\n          entry,\n          found\n        ]);\n      }\n    }\n    return results;\n  }\n  findRange(start, end, compare) {\n    const {entries} = this;\n    let last;\n    let first = 0;\n    for (let i = entries.length - 1; i > -1; i--) {\n      const entry = entries[i];\n      const comp = compare(end, entry.key);\n      if (comp > 0) {\n        last = i;\n        break;\n      }\n    }\n    for (let i = 0; i < entries.length; i++) {\n      const entry = entries[i];\n      const comp = compare(start, entry.key);\n      if (comp === 0) {\n        first = i;\n        break;\n      } else if (comp < 0) {\n        break;\n      }\n      first = i;\n    }\n    return {\n      first,\n      last,\n      entries: entries.slice(first, last + 1)\n    };\n  }\n}\nconst stringKey = key => typeof key === 'string' ? key : JSON.stringify(key);\nfunction sortBulk(bulk, opts) {\n  return bulk.sort(({key: a}, {key: b}) => opts.compare(a, b));\n}\nasync function filterLeftmostInserts(first, bulk, compare) {\n  const inserts = [];\n  for (const b of bulk) {\n    const {key, del} = b;\n    if (compare(key, first) < 0) {\n      if (!del)\n        inserts.push(b);\n    } else {\n      break;\n    }\n  }\n  return inserts;\n}\nasync function generateNewLeaves(inserts, opts, {chunker, compare}) {\n  return await Node.from({\n    entries: inserts.map(insert => new opts.LeafEntryClass(insert, opts)).sort((a, b) => compare(a.key, b.key)),\n    chunker,\n    NodeClass: opts.LeafClass,\n    distance: 0,\n    opts\n  });\n}\nasync function generateBranchEntries(that, newLeaves, results, opts) {\n  return await Promise.all(newLeaves.map(async node => {\n    const block = await node.encode();\n    results.blocks.push({\n      block,\n      node\n    });\n    that.cache.set(node);\n    const newBranchEntry = new opts.BranchEntryClass({\n      key: node.key,\n      address: await node.address\n    }, opts);\n    return newBranchEntry;\n  }));\n}\nasync function processRoot(that, results, bulk, nodeOptions) {\n  const root = results.root;\n  results.blocks.push({\n    block: await root.encode(),\n    node: root\n  });\n  that.cache.set(root);\n  const opts = nodeOptions.opts;\n  const distance = root.distance;\n  const first = root.entryList.startKey;\n  const inserts = await filterLeftmostInserts(first, bulk, that.compare);\n  if (inserts.length) {\n    const newLeaves = await generateNewLeaves(inserts, opts, that);\n    const branchEntries = await generateBranchEntries(that, newLeaves, results, opts);\n    const firstRootEntry = new opts.BranchEntryClass({\n      key: root.entryList.startKey,\n      address: await root.address\n    }, opts);\n    const newBranchEntries = [\n      firstRootEntry,\n      ...branchEntries\n    ].sort(({key: a}, {key: b}) => opts.compare(a, b));\n    let newBranches = await Node.from({\n      ...nodeOptions,\n      entries: newBranchEntries,\n      chunker: that.chunker,\n      NodeClass: opts.BranchClass,\n      distance: distance + 1\n    });\n    let allBranches = [...newBranches];\n    while (newBranches.length > 1) {\n      const newBranchEntries = await Promise.all(newBranches.map(async l => new opts.BranchEntryClass({\n        key: l.key,\n        address: await l.address\n      }, opts)));\n      newBranches = await Node.from({\n        ...nodeOptions,\n        entries: newBranchEntries.sort(({key: a}, {key: b}) => opts.compare(a, b)),\n        chunker: that.chunker,\n        NodeClass: opts.BranchClass,\n        distance: distance + 1\n      });\n      allBranches = [\n        ...allBranches,\n        ...newBranches\n      ];\n    }\n    await Promise.all(allBranches.map(async m => {\n      const block = await m.encode();\n      that.cache.set(m);\n      results.blocks.push({\n        block,\n        node: m\n      });\n    }));\n    results.root = newBranches[0];\n    results.nodes = [\n      ...results.nodes,\n      ...allBranches\n    ];\n  }\n}\nclass Node {\n  constructor({entryList, chunker, distance, getNode, compare, cache}) {\n    this.entryList = entryList;\n    this.chunker = chunker;\n    this.distance = distance;\n    this.getNode = getNode;\n    this.compare = compare;\n    this.cache = cache;\n  }\n  get closed() {\n    return this.entryList.closed;\n  }\n  get key() {\n    return this.entryList.startKey;\n  }\n  async getEntry(key, cids = new CIDCounter()) {\n    const result = await this._getEntry(key, cids);\n    return {\n      result,\n      cids\n    };\n  }\n  async _getEntry(key, cids) {\n    cids.add(this);\n    let node = this;\n    while (!node.isLeaf) {\n      const result = node.entryList.find(key, this.compare);\n      if (result === null)\n        throw new Error('Not found');\n      const [, entry] = result;\n      node = await this.getNode(await entry.address);\n      cids.add(node);\n    }\n    const result = node.entryList.find(key, this.compare);\n    if (result === null || result[1].key.toString() !== key.toString())\n      throw new Error('Not found');\n    const [, entry] = result;\n    return entry;\n  }\n  async getAllEntries(cids = new CIDCounter()) {\n    const result = await this._getAllEntries(cids);\n    return {\n      result,\n      cids\n    };\n  }\n  _getAllEntries(cids) {\n    cids.add(this);\n    if (this.isLeaf) {\n      return this.entryList.entries;\n    } else {\n      const {entries} = this.entryList;\n      const mapper = async entry => this.getNode(await entry.address).then(node => node._getAllEntries(cids)).catch(async err => {\n        throw err;\n      });\n      return Promise.all(entries.map(mapper)).then(results => results.flat());\n    }\n  }\n  async *vis(cids = new Set()) {\n    const renderNodeLabel = async node => {\n      if (node.isLeaf) {\n        const entries = node.entryList.entries.map(e => `[${ e.key },${ JSON.stringify(e.value).replace(/\"/g, '\\'') }]`).join(', ');\n        return `Leaf [${ entries }]`;\n      } else {\n        const entries = node.entryList.entries.map(e => `[${ e.key }]`).join(', ');\n        return `Branch [${ entries }]`;\n      }\n    };\n    const shortCid = cid => cid.toString().slice(0, 4) + cid.toString().slice(-4);\n    const visit = async function* (node, parentId, cids) {\n      const nodeId = await node.address;\n      if (!cids.has(nodeId)) {\n        cids.add(nodeId);\n        const nodeLabel = await renderNodeLabel(node);\n        yield `  node [shape=ellipse fontname=\"Courier\"]; ${ shortCid(nodeId) } [label=\"${ nodeLabel }\"];`;\n        yield `  ${ shortCid(parentId) } -> ${ shortCid(nodeId) };`;\n        for (const entry of node.entryList.entries) {\n          if (entry.address) {\n            const entryId = await entry.address;\n            try {\n              const childNode = await node.getNode(entryId);\n              yield* await visit(childNode, nodeId, cids);\n            } catch (err) {\n              yield `  ${ shortCid(nodeId) } -> ${ shortCid(entryId) };`;\n              yield `  node [shape=ellipse fontname=\"Courier\"]; ${ shortCid(entryId) } [label=\"Error: ${ err.message }\"];`;\n            }\n          }\n        }\n      }\n    };\n    yield 'digraph tree {';\n    yield '  node [shape=ellipse fontname=\"Courier\"]; rootnode;';\n    for await (const line of visit(this, 'rootnode', cids)) {\n      yield line;\n    }\n    yield '}';\n  }\n  async getEntries(keys, sorted = false, cids = new CIDCounter()) {\n    const result = await this._getEntries(keys, sorted, cids);\n    return {\n      result,\n      cids\n    };\n  }\n  async _getEntries(keys, sorted, cids) {\n    cids.add(this);\n    if (!sorted)\n      keys = keys.sort(this.compare);\n    const results = this.entryList.findMany(keys, this.compare, true, this.isLeaf);\n    if (this.isLeaf) {\n      return [...results.values()].map(([entry]) => entry);\n    }\n    let entries = [];\n    for (const [entry, keys] of [...results.values()].reverse()) {\n      const p = this.getNode(await entry.address);\n      entries.push(p.then(node => node._getEntries(keys.reverse(), true, cids)));\n    }\n    entries = await Promise.all(entries);\n    return entries.flat();\n  }\n  async getRangeEntries(start, end, cids = new CIDCounter()) {\n    const result = await this._getRangeEntries(start, end, cids);\n    return {\n      result,\n      cids\n    };\n  }\n  _getRangeEntries(start, end, cids) {\n    cids.add(this);\n    const {entries} = this.entryList.findRange(start, end, this.compare);\n    if (this.isLeaf) {\n      return entries.filter(entry => {\n        const s = this.compare(start, entry.key);\n        const e = this.compare(end, entry.key);\n        if (s <= 0 && e >= 0)\n          return true;\n        return false;\n      });\n    }\n    if (!entries.length)\n      return [];\n    const thenRange = async entry => this.getNode(await entry.address).then(node => node._getRangeEntries(start, end, cids));\n    const results = [thenRange(entries.shift())];\n    if (!entries.length)\n      return results[0];\n    const last = thenRange(entries.pop());\n    while (entries.length) {\n      const thenAll = async entry => this.getNode(await entry.address).then(async node => node._getAllEntries(cids));\n      results.push(thenAll(entries.shift()));\n    }\n    results.push(last);\n    return Promise.all(results).then(results => results.flat());\n  }\n  async transaction(bulk, opts = {}) {\n    opts = {\n      codec: this.codec,\n      hasher: this.hasher,\n      getNode: this.getNode,\n      compare: this.compare,\n      cache: this.cache,\n      ...opts\n    };\n    const nodeOptions = {\n      chunker: this.chunker,\n      opts\n    };\n    const results = this.entryList.findMany(bulk, opts.compare, true, this.isLeaf);\n    if (this.isLeaf) {\n      return await this.transactionLeaf(bulk, opts, nodeOptions, results);\n    } else {\n      return await this.transactionBranch(bulk, opts, nodeOptions, results);\n    }\n  }\n  async transactionLeaf(bulk, opts, nodeOptions, results) {\n    const {LeafClass, LeafEntryClass} = opts;\n    const {entries, previous} = this.processLeafEntries(bulk, results, LeafEntryClass, opts);\n    const _opts = {\n      ...nodeOptions,\n      entries,\n      NodeClass: LeafClass,\n      distance: 0\n    };\n    const nodes = await Node.from(_opts);\n    return {\n      nodes,\n      previous,\n      blocks: await Promise.all(nodes.map(async n => {\n        const block = await n.encode();\n        this.cache.set(n);\n        return {\n          block,\n          node: n\n        };\n      })),\n      distance: 0\n    };\n  }\n  processLeafEntries(bulk, results, LeafEntryClass, opts) {\n    const previous = [];\n    let entries = [];\n    const changes = {};\n    const deletes = new Map();\n    for (const {key, del, value} of bulk) {\n      const skey = stringKey(key);\n      if (del) {\n        if (typeof changes[skey] === 'undefined')\n          deletes.set(skey, null);\n      } else {\n        changes[skey] = {\n          key,\n          value\n        };\n        deletes.delete(skey);\n      }\n    }\n    entries = [...this.entryList.entries];\n    for (const [i, [entry]] of results) {\n      previous.push(entry);\n      const skey = stringKey(entry.key);\n      if (deletes.has(skey)) {\n        deletes.set(skey, i);\n      } else {\n        entries[i] = new LeafEntryClass(changes[skey], opts);\n        delete changes[skey];\n      }\n    }\n    let count = 0;\n    for (const [, i] of deletes) {\n      if (i !== null)\n        entries.splice(i - count++, 1);\n    }\n    const appends = Object.values(changes).map(obj => new LeafEntryClass(obj, opts));\n    entries = entries.concat(appends).sort(({key: a}, {key: b}) => opts.compare(a, b));\n    return {\n      entries,\n      previous\n    };\n  }\n  async transactionBranch(bulk, opts, nodeOptions, results) {\n    const {BranchClass, BranchEntryClass} = opts;\n    let distance = 0;\n    for (const [i, [entry, keys]] of results) {\n      const p = this.getNode(await entry.address).then(node => node.transaction(keys.reverse(), {\n        ...opts,\n        sorted: true\n      })).then(r => ({\n        entry,\n        keys,\n        distance,\n        ...r\n      }));\n      results.set(i, p);\n    }\n    let entries = [...this.entryList.entries];\n    const final = {\n      previous: [],\n      blocks: [],\n      nodes: []\n    };\n    for (const [i, p] of results) {\n      const {\n        nodes,\n        previous,\n        blocks,\n        distance: _distance\n      } = await p;\n      distance = _distance;\n      entries[i] = nodes;\n      if (previous.length)\n        final.previous = final.previous.concat(previous);\n      if (blocks.length)\n        final.blocks = final.blocks.concat(blocks);\n      if (nodes.length)\n        final.nodes = final.nodes.concat(nodes);\n    }\n    entries = entries.flat();\n    const newEntries = await this.handlePrepend(entries, opts, nodeOptions, final, distance);\n    distance++;\n    const toEntry = async branch => {\n      if (branch.isEntry)\n        return branch;\n      const block = await branch.encode();\n      final.blocks.push({\n        block,\n        node: branch\n      });\n      this.cache.set(branch);\n      return new BranchEntryClass(branch, opts);\n    };\n    entries = await Promise.all(newEntries.map(toEntry));\n    const _opts = {\n      ...nodeOptions,\n      entries,\n      NodeClass: BranchClass,\n      distance\n    };\n    const newNodes = await Node.from(_opts);\n    await Promise.all(newNodes.map(async n => {\n      const block = await n.encode();\n      final.blocks.push({\n        block,\n        node: n\n      });\n      this.cache.set(n);\n    }));\n    final.nodes = newNodes;\n    return {\n      ...final,\n      distance\n    };\n  }\n  async handlePrepend(entries, opts, nodeOptions, final, distance) {\n    const {BranchClass, LeafClass} = opts;\n    let newEntries = [];\n    let prepend = null;\n    for (const entry of entries) {\n      if (prepend) {\n        const mergeEntries = await this.mergeFirstLeftEntries(entry, prepend, nodeOptions, final, distance);\n        prepend = null;\n        const NodeClass = !mergeEntries[0].address ? LeafClass : BranchClass;\n        const _opts = {\n          ...nodeOptions,\n          entries: mergeEntries.sort(({key: a}, {key: b}) => opts.compare(a, b)),\n          NodeClass,\n          distance: distance\n        };\n        const nodes = await Node.from(_opts);\n        if (!nodes[nodes.length - 1].closed) {\n          prepend = nodes.pop();\n        }\n        if (nodes.length) {\n          newEntries = newEntries.concat(nodes);\n        }\n      } else {\n        if (!entry.isEntry && !entry.closed) {\n          prepend = entry;\n        } else {\n          newEntries.push(entry);\n        }\n      }\n    }\n    if (prepend) {\n      newEntries.push(prepend);\n    }\n    return newEntries;\n  }\n  async getNodeFirstFromBlocks(blocks, addr) {\n    for (const {block, node} of blocks) {\n      if (await block.cid === addr)\n        return node;\n    }\n    return await this.getNode(addr);\n  }\n  async mergeFirstLeftEntries(entry, prepend, nodeOptions, final, distance) {\n    const opts = nodeOptions.opts;\n    const {LeafClass, BranchClass, BranchEntryClass} = opts;\n    if (entry.isEntry) {\n      const addr = await entry.address;\n      entry = await this.getNodeFirstFromBlocks(final.blocks, addr);\n    }\n    const es = entry.entryList.entries;\n    if (!es.length)\n      throw new Error('unreachable no entries');\n    const basicMerge = (entries1, entries2) => {\n      return entries1.concat(entries2);\n    };\n    const processNodesAndCreateEntries = async (nodes, final, opts) => {\n      return await Promise.all(nodes.map(async l => {\n        final.blocks.push({\n          block: await l.encode(),\n          node: l\n        });\n        this.cache.set(l);\n        return new BranchEntryClass({\n          key: l.key,\n          address: await l.address\n        }, opts);\n      }));\n    };\n    if (es[0].constructor.name === prepend.entryList.entries[0].constructor.name) {\n      return await basicMerge(prepend.entryList.entries, es);\n    } else {\n      const leftEntry = es.shift();\n      if (!leftEntry)\n        throw new Error('unreachable no left entry');\n      if (!leftEntry.address)\n        throw new Error('unreachable existing leaf, no leftEntry.address');\n      const mergeLeftEntries = await this.mergeFirstLeftEntries(leftEntry, prepend, nodeOptions, final, distance - 1);\n      const esf = es.shift();\n      if (!esf) {\n        return mergeLeftEntries;\n      }\n      if (!esf.address)\n        throw new Error('unreachable existing leaf, no esf.address');\n      const oldFront = await this.getNodeFirstFromBlocks(final.blocks, await esf.address);\n      if (!oldFront.entryList.entries[0].address) {\n        const leftLeafEntries = await basicMerge(mergeLeftEntries, oldFront.entryList.entries);\n        const leftLeafNodes = await Node.from({\n          ...nodeOptions,\n          entries: leftLeafEntries.sort(({key: a}, {key: b}) => opts.compare(a, b)),\n          NodeClass: LeafClass,\n          distance\n        });\n        const leftBranches = await processNodesAndCreateEntries(leftLeafNodes, final, opts);\n        return await basicMerge(leftBranches, es);\n      } else {\n        if (mergeLeftEntries[0].address) {\n          return mergeLeftEntries.concat(oldFront.entryList.entries);\n        } else {\n          const mergeLeftNodes = await Node.from({\n            ...nodeOptions,\n            entries: mergeLeftEntries.sort(({key: a}, {key: b}) => opts.compare(a, b)),\n            NodeClass: LeafClass,\n            distance\n          });\n          const mergeLeftBranchEntries = await processNodesAndCreateEntries(mergeLeftNodes, final, opts);\n          const newFirstNodes = await Node.from({\n            ...nodeOptions,\n            entries: [\n              ...oldFront.entryList.entries,\n              ...mergeLeftBranchEntries,\n              ...es\n            ].sort(({key: a}, {key: b}) => opts.compare(a, b)),\n            NodeClass: BranchClass,\n            distance\n          });\n          const newBranchEntries = await processNodesAndCreateEntries(newFirstNodes, final, opts);\n          return newBranchEntries;\n        }\n      }\n    }\n  }\n  async bulk(bulk, opts = {}, isRoot = true) {\n    const {BranchClass} = opts;\n    opts = {\n      codec: this.codec,\n      hasher: this.hasher,\n      getNode: this.getNode,\n      compare: this.compare,\n      cache: this.cache,\n      ...opts\n    };\n    if (!opts.sorted) {\n      bulk = sortBulk(bulk, opts);\n      opts.sorted = true;\n    }\n    const nodeOptions = {\n      chunker: this.chunker,\n      opts\n    };\n    const results = await this.transaction(bulk, opts);\n    while (results.nodes.length > 1) {\n      const newDistance = results.nodes[0].distance + 1;\n      const branchEntries = await Promise.all(results.nodes.map(async node => {\n        const block = await node.encode();\n        results.blocks.push({\n          block,\n          node\n        });\n        this.cache.set(node);\n        return new opts.BranchEntryClass(node, opts);\n      }));\n      const newNodes = await Node.from({\n        ...nodeOptions,\n        entries: branchEntries,\n        NodeClass: BranchClass,\n        distance: newDistance\n      });\n      await Promise.all(newNodes.map(async node => {\n        const block = await node.encode();\n        this.cache.set(node);\n        results.blocks.push({\n          block,\n          node\n        });\n      }));\n      results.nodes = newNodes;\n    }\n    results.root = results.nodes[0];\n    if (isRoot && results.root) {\n      await processRoot(this, results, bulk, nodeOptions);\n    }\n    results.blocks = results.blocks.map(({block}) => block);\n    return results;\n  }\n  static async from({entries, chunker, NodeClass, distance, opts}) {\n    if (!entries.every(entry => entry.constructor.name === entries[0].constructor.name))\n      throw new Error('all entries must be of the same type');\n    const parts = [];\n    let chunk = [];\n    for (const entry of entries) {\n      chunk.push(entry);\n      if (await chunker(entry, distance)) {\n        parts.push(new EntryList({\n          entries: chunk,\n          closed: true\n        }));\n        chunk = [];\n      }\n    }\n    if (chunk.length) {\n      parts.push(new EntryList({\n        entries: chunk,\n        closed: false\n      }));\n    }\n    return parts.map(entryList => new NodeClass({\n      entryList,\n      chunker,\n      distance,\n      ...opts\n    }));\n  }\n}\nclass IPLDNode extends Node {\n  constructor({codec, hasher, block, ...opts}) {\n    super(opts);\n    this.codec = codec;\n    this.hasher = hasher;\n    if (!block) {\n      this.block = this.encode();\n      this.address = this.block.then(block => block.cid);\n    } else {\n      this.block = block;\n      this.address = block.cid;\n    }\n  }\n  async get(key) {\n    const {\n      result: entry,\n      cids\n    } = await this.getEntry(key);\n    return {\n      result: entry.key,\n      cids\n    };\n  }\n  async encode() {\n    if (this.block)\n      return this.block;\n    const value = await this.encodeNode();\n    const opts = {\n      codec: this.codec,\n      hasher: this.hasher,\n      value\n    };\n    this.block = await multiformatEncode(opts);\n    return this.block;\n  }\n}\nclass IPLDBranch extends IPLDNode {\n  async encodeNode() {\n    const {entries} = this.entryList;\n    const mapper = async entry => {\n      if (!entry.address)\n        throw new Error('entry.address required');\n      return [\n        entry.key,\n        await entry.address\n      ];\n    };\n    const list = await Promise.all(entries.map(mapper));\n    return {\n      branch: [\n        this.distance,\n        list\n      ],\n      closed: this.closed\n    };\n  }\n  get isBranch() {\n    return true;\n  }\n}\nclass IPLDLeaf extends IPLDNode {\n  async encodeNode() {\n    const list = await Promise.all(this.entryList.entries.map(async entry => await entry.encodeNode()));\n    return {\n      leaf: list,\n      closed: this.closed\n    };\n  }\n  get isLeaf() {\n    return true;\n  }\n}\nconst create = async function* (obj) {\n  let {LeafClass, LeafEntryClass, BranchClass, BranchEntryClass, list, chunker, compare, ...opts} = obj;\n  list = list.map(value => new LeafEntryClass(value, opts));\n  opts.compare = compare;\n  let nodes = await Node.from({\n    entries: list,\n    chunker,\n    NodeClass: LeafClass,\n    distance: 0,\n    opts\n  });\n  yield* nodes;\n  let distance = 1;\n  while (nodes.length > 1) {\n    const mapper = async node => new BranchEntryClass({\n      key: node.key,\n      address: await node.address\n    }, opts);\n    const entries = await Promise.all(nodes.map(mapper));\n    nodes = await Node.from({\n      entries,\n      chunker,\n      NodeClass: BranchClass,\n      distance,\n      opts\n    });\n    yield* nodes;\n    distance++;\n  }\n};\nexport {\n  Node,\n  Entry,\n  EntryList,\n  IPLDNode,\n  IPLDLeaf,\n  IPLDBranch,\n  create\n};", "import {\n  Entry,\n  EntryList,\n  IPLDLeaf,\n  IPLDBranch,\n  create as baseCreate\n} from './base.js';\nimport {\n  readUInt32LE,\n  binaryCompare\n} from './utils.js';\nconst compare = ({bytes: a}, {bytes: b}) => binaryCompare(a, b);\nclass CIDEntry extends Entry {\n  constructor(cid) {\n    super({\n      address: cid,\n      key: cid\n    });\n    this.cid = cid;\n  }\n  encodeNode() {\n    return this.cid;\n  }\n  identity() {\n    const buffer = this.cid.multihash.bytes;\n    return readUInt32LE(buffer);\n  }\n}\nclass CIDNodeEntry extends Entry {\n  async identity() {\n    const {\n      multihash: {bytes}\n    } = await this.address;\n    return readUInt32LE(bytes);\n  }\n}\nclass CIDSetBranch extends IPLDBranch {\n}\nclass CIDSetLeaf extends IPLDLeaf {\n}\nconst createGetNode = (get, cache, chunker, codec, hasher) => {\n  const decoder = block => {\n    const {value} = block;\n    const opts = {\n      chunker,\n      cache,\n      block,\n      getNode,\n      codec,\n      hasher,\n      compare\n    };\n    let entries;\n    let CLS;\n    if (value.leaf) {\n      entries = value.leaf.map(cid => new CIDEntry(cid));\n      CLS = CIDSetLeaf;\n    } else if (value.branch) {\n      const [distance, _entries] = value.branch;\n      opts.distance = distance;\n      entries = _entries.map(([key, address]) => new CIDNodeEntry({\n        key,\n        address\n      }));\n      CLS = CIDSetBranch;\n    } else {\n      throw new Error('Unknown block data, does not match schema');\n    }\n    const entryList = new EntryList({\n      entries,\n      closed: value.closed\n    });\n    const node = new CLS({\n      entryList,\n      ...opts\n    });\n    cache.set(node);\n    return node;\n  };\n  const getNode = cid => {\n    if (cache.has(cid))\n      return cache.get(cid);\n    return get(cid).then(block => decoder(block));\n  };\n  return getNode;\n};\nconst create = ({get, cache, chunker, list, codec, hasher, sorted}) => {\n  if (!sorted)\n    list = list.sort(compare);\n  const getNode = createGetNode(get, cache, chunker, codec, hasher);\n  const opts = {\n    list,\n    codec,\n    hasher,\n    chunker,\n    getNode,\n    sorted,\n    compare,\n    cache,\n    LeafClass: CIDSetLeaf,\n    LeafEntryClass: CIDEntry,\n    BranchClass: CIDSetBranch,\n    BranchEntryClass: CIDNodeEntry\n  };\n  return baseCreate(opts);\n};\nconst load = ({cid, get, cache, chunker, codec, hasher, ...opts}) => {\n  const getNode = createGetNode(get, cache, chunker, codec, hasher, opts);\n  return getNode(cid);\n};\nexport {\n  create,\n  load\n};", "import * as codec from './encrypted-block.js'\nimport * as dagcbor from '@ipld/dag-cbor'\n// @ts-ignore\nimport { create, load } from 'prolly-trees/cid-set'\nimport { CID } from 'multiformats'\nimport { encode, decode, create as mfCreate } from 'multiformats/block'\nimport type { AnyBlock, AnyDecodedBlock, AnyLink } from './types.js'\nimport type { MultihashHasher, ToString } from 'multiformats'\n\nconst encrypt = async function * ({\n  get, cids, hasher,\n  key, cache, chunker, root\n}:\n  {\n    get: (cid: AnyLink) => Promise<AnyBlock | undefined>,\n    key: ArrayBuffer, cids: AnyLink[], hasher: MultihashHasher<number>\n    chunker: (bytes: Uint8Array) => AsyncGenerator<Uint8Array>,\n    cache: (cid: AnyLink) => Promise<AnyBlock>,\n    root: AnyLink\n  }): AsyncGenerator<any, void, unknown> {\n  const set = new Set<ToString<AnyLink>>()\n  let eroot\n  for (const cid of cids) {\n    const unencrypted = await get(cid)\n    if (!unencrypted) throw new Error('missing cid: ' + cid.toString())\n    const encrypted = await codec.encrypt({ ...unencrypted, key })\n    const block = await encode({ ...encrypted, codec, hasher })\n    yield block\n    set.add(block.cid.toString())\n    if (unencrypted.cid.equals(root)) eroot = block.cid\n  }\n  if (!eroot) throw new Error('cids does not include root')\n  const list = [...set].map(s => CID.parse(s))\n  let last\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n  for await (const node of create({ list, get, cache, chunker, hasher, codec: dagcbor })) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const block = await node.block as AnyBlock\n    yield block\n    last = block\n  }\n  if (!last) throw new Error('missing last block')\n  const head = [eroot, last.cid]\n  const block = await encode({ value: head, codec: dagcbor, hasher })\n  yield block\n}\n\nconst decrypt = async function * ({ root, get, key, cache, chunker, hasher }: {\n  root: AnyLink,\n  get: (cid: AnyLink) => Promise<AnyBlock | undefined>,\n  key: ArrayBuffer,\n  cache: (cid: AnyLink) => Promise<AnyBlock>,\n  chunker: (bytes: Uint8Array) => AsyncGenerator<Uint8Array>,\n  hasher: MultihashHasher<number>\n}): AsyncGenerator<AnyBlock, void, undefined> {\n  const getWithDecode = async (cid: AnyLink) => get(cid).then(async (block) => {\n    if (!block) return\n    const decoded = await decode({ ...block, codec: dagcbor, hasher })\n    return decoded\n  })\n  const getWithDecrypt = async (cid: AnyLink) => get(cid).then(async (block) => {\n    if (!block) return\n    const decoded = await decode({ ...block, codec, hasher })\n    return decoded\n  })\n  const decodedRoot = await getWithDecode(root)\n  if (!decodedRoot) throw new Error('missing root')\n  if (!decodedRoot.bytes) throw new Error('missing bytes')\n  const { value: [eroot, tree] } = decodedRoot as { value: [AnyLink, AnyLink] }\n  const rootBlock = await get(eroot) as AnyDecodedBlock\n  if (!rootBlock) throw new Error('missing root block')\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\n  const cidset = await load({ cid: tree, get: getWithDecode, cache, chunker, codec, hasher })\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n  const { result: nodes } = await cidset.getAllEntries() as { result: { cid: CID }[] }\n  const unwrap = async (eblock: AnyDecodedBlock | undefined) => {\n    if (!eblock) throw new Error('missing block')\n    if (!eblock.value) { eblock = await decode({ ...eblock, codec, hasher }) as AnyDecodedBlock }\n    const { bytes, cid } = await codec.decrypt({ ...eblock, key }).catch(e => {\n      throw e\n    })\n    const block = await mfCreate({ cid, bytes, hasher, codec })\n    return block\n  }\n  const promises = []\n  for (const { cid } of nodes) {\n    if (!rootBlock.cid.equals(cid)) promises.push(getWithDecrypt(cid).then(unwrap))\n  }\n  yield * promises\n  yield unwrap(rootBlock)\n}\nexport {\n  encrypt,\n  decrypt\n}\n", "const nocache = {\n  has: () => false,\n  get: () => {\n    throw new Error('Cannot ask for entries from nocache');\n  },\n  set: () => {\n  }\n};\nconst toKey = key => key.asCID === key ? key.toString() : JSON.stringify(key);\nconst global = {\n  blocks: {},\n  has: key => !!global.blocks[toKey(key)],\n  set: async node => {\n    let key = node.address;\n    if (key.then)\n      key = await key;\n    key = toKey(key);\n    if (!global.blocks[key])\n      global.blocks[key] = node;\n  },\n  get: key => {\n    key = toKey(key);\n    if (typeof global.blocks[key] === 'undefined')\n      throw new Error('Not found');\n    return global.blocks[key];\n  }\n};\nexport {\n  nocache,\n  global\n};", "import type { CarReader } from '@ipld/car'\n\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { encrypt, decrypt } from './crypto-ipld'\n// @ts-ignore\nimport { bf } from 'prolly-trees/utils'\n// @ts-ignore\nimport { nocache as cache } from 'prolly-trees/cache'\nimport { encodeCarFile } from './loader-helpers' // Import the existing function\nimport type { AnyBlock, CarMakeable, AnyLink, BlockFetcher } from './types'\nimport { MemoryBlockstore } from '@alanshaw/pail/block'\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\nconst chunker = bf(30)\n\nfunction hexStringToUint8Array(hexString: string) {\n  const length = hexString.length\n  const uint8Array = new Uint8Array(length / 2)\n  for (let i = 0; i < length; i += 2) {\n    uint8Array[i / 2] = parseInt(hexString.substring(i, i + 2), 16)\n  }\n  return uint8Array\n}\n\nexport async function encryptedEncodeCarFile(\n  key: string,\n  rootCid: AnyLink,\n  t: CarMakeable\n): Promise<AnyBlock> {\n  const encryptionKeyUint8 = hexStringToUint8Array(key)\n  const encryptionKey = encryptionKeyUint8.buffer.slice(0, encryptionKeyUint8.byteLength)\n  const encryptedBlocks = new MemoryBlockstore()\n  const cidsToEncrypt = [] as AnyLink[]\n  for (const { cid } of t.entries()) {\n    cidsToEncrypt.push(cid)\n    const g = await t.get(cid)\n    if (!g) throw new Error('missing cid block')\n  }\n  let last: AnyBlock | null = null\n  for await (const block of encrypt({\n    cids: cidsToEncrypt,\n    get: t.get.bind(t),\n    key: encryptionKey,\n    hasher: sha256,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    chunker,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    cache,\n    root: rootCid\n  }) as AsyncGenerator<AnyBlock, void, unknown>) {\n    await encryptedBlocks.put(block.cid, block.bytes)\n    last = block\n  }\n  if (!last) throw new Error('no blocks encrypted')\n  const encryptedCar = await encodeCarFile([last.cid], encryptedBlocks)\n  return encryptedCar\n}\n\nexport async function decodeEncryptedCar(key: string, reader: CarReader) {\n  const roots = await reader.getRoots()\n  const root = roots[0]\n  return await decodeCarBlocks(root, reader.get.bind(reader), key)\n}\nasync function decodeCarBlocks(\n  root: AnyLink,\n  get: (cid: any) => Promise<AnyBlock | undefined>,\n  keyMaterial: string\n): Promise<{ blocks: MemoryBlockstore; root: AnyLink }> {\n  const decryptionKeyUint8 = hexStringToUint8Array(keyMaterial)\n  const decryptionKey = decryptionKeyUint8.buffer.slice(0, decryptionKeyUint8.byteLength)\n\n  const decryptedBlocks = new MemoryBlockstore()\n  let last: AnyBlock | null = null\n  for await (const block of decrypt({\n    root,\n    get,\n    key: decryptionKey,\n    hasher: sha256,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    chunker,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    cache\n  })) {\n    await decryptedBlocks.put(block.cid, block.bytes)\n    last = block\n  }\n  if (!last) throw new Error('no blocks decrypted')\n  return { blocks: decryptedBlocks, root: last.cid }\n}\n", "import { Type } from '../token.js';\nimport { encodeCustom } from '../encode.js';\nimport { encodeErrPrefix } from '../common.js';\nimport {\n  asU8A,\n  fromString\n} from '../byte-utils.js';\nclass JSONEncoder extends Array {\n  constructor() {\n    super();\n    this.inRecursive = [];\n  }\n  prefix(buf) {\n    const recurs = this.inRecursive[this.inRecursive.length - 1];\n    if (recurs) {\n      if (recurs.type === Type.array) {\n        recurs.elements++;\n        if (recurs.elements !== 1) {\n          buf.push([44]);\n        }\n      }\n      if (recurs.type === Type.map) {\n        recurs.elements++;\n        if (recurs.elements !== 1) {\n          if (recurs.elements % 2 === 1) {\n            buf.push([44]);\n          } else {\n            buf.push([58]);\n          }\n        }\n      }\n    }\n  }\n  [Type.uint.major](buf, token) {\n    this.prefix(buf);\n    const is = String(token.value);\n    const isa = [];\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n    }\n    buf.push(isa);\n  }\n  [Type.negint.major](buf, token) {\n    this[Type.uint.major](buf, token);\n  }\n  [Type.bytes.major](_buf, _token) {\n    throw new Error(`${ encodeErrPrefix } unsupported type: Uint8Array`);\n  }\n  [Type.string.major](buf, token) {\n    this.prefix(buf);\n    const byts = fromString(JSON.stringify(token.value));\n    buf.push(byts.length > 32 ? asU8A(byts) : byts);\n  }\n  [Type.array.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: Type.array,\n      elements: 0\n    });\n    buf.push([91]);\n  }\n  [Type.map.major](buf, _token) {\n    this.prefix(buf);\n    this.inRecursive.push({\n      type: Type.map,\n      elements: 0\n    });\n    buf.push([123]);\n  }\n  [Type.tag.major](_buf, _token) {\n  }\n  [Type.float.major](buf, token) {\n    if (token.type.name === 'break') {\n      const recurs = this.inRecursive.pop();\n      if (recurs) {\n        if (recurs.type === Type.array) {\n          buf.push([93]);\n        } else if (recurs.type === Type.map) {\n          buf.push([125]);\n        } else {\n          throw new Error('Unexpected recursive type; this should not happen!');\n        }\n        return;\n      }\n      throw new Error('Unexpected break; this should not happen!');\n    }\n    if (token.value === undefined) {\n      throw new Error(`${ encodeErrPrefix } unsupported type: undefined`);\n    }\n    this.prefix(buf);\n    if (token.type.name === 'true') {\n      buf.push([\n        116,\n        114,\n        117,\n        101\n      ]);\n      return;\n    } else if (token.type.name === 'false') {\n      buf.push([\n        102,\n        97,\n        108,\n        115,\n        101\n      ]);\n      return;\n    } else if (token.type.name === 'null') {\n      buf.push([\n        110,\n        117,\n        108,\n        108\n      ]);\n      return;\n    }\n    const is = String(token.value);\n    const isa = [];\n    let dp = false;\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i);\n      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) {\n        dp = true;\n      }\n    }\n    if (!dp) {\n      isa.push(46);\n      isa.push(48);\n    }\n    buf.push(isa);\n  }\n}\nfunction mapSorter(e1, e2) {\n  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {\n    throw new Error(`${ encodeErrPrefix } complex map keys are not supported`);\n  }\n  const keyToken1 = e1[0];\n  const keyToken2 = e2[0];\n  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {\n    throw new Error(`${ encodeErrPrefix } non-string map keys are not supported`);\n  }\n  if (keyToken1 < keyToken2) {\n    return -1;\n  }\n  if (keyToken1 > keyToken2) {\n    return 1;\n  }\n  throw new Error(`${ encodeErrPrefix } unexpected duplicate map keys, this is not supported`);\n}\nconst defaultEncodeOptions = {\n  addBreakTokens: true,\n  mapSorter\n};\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, new JSONEncoder(), options);\n}\nexport {\n  encode\n};", "import { decode as _decode } from '../decode.js';\nimport {\n  Token,\n  Type\n} from '../token.js';\nimport { decodeCodePointsArray } from '../byte-utils.js';\nimport { decodeErrPrefix } from '../common.js';\nclass Tokenizer {\n  constructor(data, options = {}) {\n    this.pos = 0;\n    this.data = data;\n    this.options = options;\n    this.modeStack = ['value'];\n    this.lastToken = '';\n  }\n  done() {\n    return this.pos >= this.data.length;\n  }\n  ch() {\n    return this.data[this.pos];\n  }\n  currentMode() {\n    return this.modeStack[this.modeStack.length - 1];\n  }\n  skipWhitespace() {\n    let c = this.ch();\n    while (c === 32 || c === 9 || c === 13 || c === 10) {\n      c = this.data[++this.pos];\n    }\n  }\n  expect(str) {\n    if (this.data.length - this.pos < str.length) {\n      throw new Error(`${ decodeErrPrefix } unexpected end of input at position ${ this.pos }`);\n    }\n    for (let i = 0; i < str.length; i++) {\n      if (this.data[this.pos++] !== str[i]) {\n        throw new Error(`${ decodeErrPrefix } unexpected token at position ${ this.pos }, expected to find '${ String.fromCharCode(...str) }'`);\n      }\n    }\n  }\n  parseNumber() {\n    const startPos = this.pos;\n    let negative = false;\n    let float = false;\n    const swallow = chars => {\n      while (!this.done()) {\n        const ch = this.ch();\n        if (chars.includes(ch)) {\n          this.pos++;\n        } else {\n          break;\n        }\n      }\n    };\n    if (this.ch() === 45) {\n      negative = true;\n      this.pos++;\n    }\n    if (this.ch() === 48) {\n      this.pos++;\n      if (this.ch() === 46) {\n        this.pos++;\n        float = true;\n      } else {\n        return new Token(Type.uint, 0, this.pos - startPos);\n      }\n    }\n    swallow([\n      48,\n      49,\n      50,\n      51,\n      52,\n      53,\n      54,\n      55,\n      56,\n      57\n    ]);\n    if (negative && this.pos === startPos + 1) {\n      throw new Error(`${ decodeErrPrefix } unexpected token at position ${ this.pos }`);\n    }\n    if (!this.done() && this.ch() === 46) {\n      if (float) {\n        throw new Error(`${ decodeErrPrefix } unexpected token at position ${ this.pos }`);\n      }\n      float = true;\n      this.pos++;\n      swallow([\n        48,\n        49,\n        50,\n        51,\n        52,\n        53,\n        54,\n        55,\n        56,\n        57\n      ]);\n    }\n    if (!this.done() && (this.ch() === 101 || this.ch() === 69)) {\n      float = true;\n      this.pos++;\n      if (!this.done() && (this.ch() === 43 || this.ch() === 45)) {\n        this.pos++;\n      }\n      swallow([\n        48,\n        49,\n        50,\n        51,\n        52,\n        53,\n        54,\n        55,\n        56,\n        57\n      ]);\n    }\n    const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this.pos));\n    const num = parseFloat(numStr);\n    if (float) {\n      return new Token(Type.float, num, this.pos - startPos);\n    }\n    if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {\n      return new Token(num >= 0 ? Type.uint : Type.negint, num, this.pos - startPos);\n    }\n    return new Token(num >= 0 ? Type.uint : Type.negint, BigInt(numStr), this.pos - startPos);\n  }\n  parseString() {\n    if (this.ch() !== 34) {\n      throw new Error(`${ decodeErrPrefix } unexpected character at position ${ this.pos }; this shouldn't happen`);\n    }\n    this.pos++;\n    for (let i = this.pos, l = 0; i < this.data.length && l < 65536; i++, l++) {\n      const ch = this.data[i];\n      if (ch === 92 || ch < 32 || ch >= 128) {\n        break;\n      }\n      if (ch === 34) {\n        const str = String.fromCharCode.apply(null, this.data.subarray(this.pos, i));\n        this.pos = i + 1;\n        return new Token(Type.string, str, l);\n      }\n    }\n    const startPos = this.pos;\n    const chars = [];\n    const readu4 = () => {\n      if (this.pos + 4 >= this.data.length) {\n        throw new Error(`${ decodeErrPrefix } unexpected end of unicode escape sequence at position ${ this.pos }`);\n      }\n      let u4 = 0;\n      for (let i = 0; i < 4; i++) {\n        let ch = this.ch();\n        if (ch >= 48 && ch <= 57) {\n          ch -= 48;\n        } else if (ch >= 97 && ch <= 102) {\n          ch = ch - 97 + 10;\n        } else if (ch >= 65 && ch <= 70) {\n          ch = ch - 65 + 10;\n        } else {\n          throw new Error(`${ decodeErrPrefix } unexpected unicode escape character at position ${ this.pos }`);\n        }\n        u4 = u4 * 16 + ch;\n        this.pos++;\n      }\n      return u4;\n    };\n    const readUtf8Char = () => {\n      const firstByte = this.ch();\n      let codePoint = null;\n      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n      if (this.pos + bytesPerSequence > this.data.length) {\n        throw new Error(`${ decodeErrPrefix } unexpected unicode sequence at position ${ this.pos }`);\n      }\n      let secondByte, thirdByte, fourthByte, tempCodePoint;\n      switch (bytesPerSequence) {\n      case 1:\n        if (firstByte < 128) {\n          codePoint = firstByte;\n        }\n        break;\n      case 2:\n        secondByte = this.data[this.pos + 1];\n        if ((secondByte & 192) === 128) {\n          tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n          if (tempCodePoint > 127) {\n            codePoint = tempCodePoint;\n          }\n        }\n        break;\n      case 3:\n        secondByte = this.data[this.pos + 1];\n        thirdByte = this.data[this.pos + 2];\n        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n          tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n          if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n            codePoint = tempCodePoint;\n          }\n        }\n        break;\n      case 4:\n        secondByte = this.data[this.pos + 1];\n        thirdByte = this.data[this.pos + 2];\n        fourthByte = this.data[this.pos + 3];\n        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n          tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n          if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n            codePoint = tempCodePoint;\n          }\n        }\n      }\n      if (codePoint === null) {\n        codePoint = 65533;\n        bytesPerSequence = 1;\n      } else if (codePoint > 65535) {\n        codePoint -= 65536;\n        chars.push(codePoint >>> 10 & 1023 | 55296);\n        codePoint = 56320 | codePoint & 1023;\n      }\n      chars.push(codePoint);\n      this.pos += bytesPerSequence;\n    };\n    while (!this.done()) {\n      const ch = this.ch();\n      let ch1;\n      switch (ch) {\n      case 92:\n        this.pos++;\n        if (this.done()) {\n          throw new Error(`${ decodeErrPrefix } unexpected string termination at position ${ this.pos }`);\n        }\n        ch1 = this.ch();\n        this.pos++;\n        switch (ch1) {\n        case 34:\n        case 39:\n        case 92:\n        case 47:\n          chars.push(ch1);\n          break;\n        case 98:\n          chars.push(8);\n          break;\n        case 116:\n          chars.push(9);\n          break;\n        case 110:\n          chars.push(10);\n          break;\n        case 102:\n          chars.push(12);\n          break;\n        case 114:\n          chars.push(13);\n          break;\n        case 117:\n          chars.push(readu4());\n          break;\n        default:\n          throw new Error(`${ decodeErrPrefix } unexpected string escape character at position ${ this.pos }`);\n        }\n        break;\n      case 34:\n        this.pos++;\n        return new Token(Type.string, decodeCodePointsArray(chars), this.pos - startPos);\n      default:\n        if (ch < 32) {\n          throw new Error(`${ decodeErrPrefix } invalid control character at position ${ this.pos }`);\n        } else if (ch < 128) {\n          chars.push(ch);\n          this.pos++;\n        } else {\n          readUtf8Char();\n        }\n      }\n    }\n    throw new Error(`${ decodeErrPrefix } unexpected end of string at position ${ this.pos }`);\n  }\n  parseValue() {\n    switch (this.ch()) {\n    case 123:\n      this.modeStack.push('obj-start');\n      this.pos++;\n      return new Token(Type.map, Infinity, 1);\n    case 91:\n      this.modeStack.push('array-start');\n      this.pos++;\n      return new Token(Type.array, Infinity, 1);\n    case 34: {\n        return this.parseString();\n      }\n    case 110:\n      this.expect([\n        110,\n        117,\n        108,\n        108\n      ]);\n      return new Token(Type.null, null, 4);\n    case 102:\n      this.expect([\n        102,\n        97,\n        108,\n        115,\n        101\n      ]);\n      return new Token(Type.false, false, 5);\n    case 116:\n      this.expect([\n        116,\n        114,\n        117,\n        101\n      ]);\n      return new Token(Type.true, true, 4);\n    case 45:\n    case 48:\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      return this.parseNumber();\n    default:\n      throw new Error(`${ decodeErrPrefix } unexpected character at position ${ this.pos }`);\n    }\n  }\n  next() {\n    this.skipWhitespace();\n    switch (this.currentMode()) {\n    case 'value':\n      this.modeStack.pop();\n      return this.parseValue();\n    case 'array-value': {\n        this.modeStack.pop();\n        if (this.ch() === 93) {\n          this.pos++;\n          this.skipWhitespace();\n          return new Token(Type.break, undefined, 1);\n        }\n        if (this.ch() !== 44) {\n          throw new Error(`${ decodeErrPrefix } unexpected character at position ${ this.pos }, was expecting array delimiter but found '${ String.fromCharCode(this.ch()) }'`);\n        }\n        this.pos++;\n        this.modeStack.push('array-value');\n        this.skipWhitespace();\n        return this.parseValue();\n      }\n    case 'array-start': {\n        this.modeStack.pop();\n        if (this.ch() === 93) {\n          this.pos++;\n          this.skipWhitespace();\n          return new Token(Type.break, undefined, 1);\n        }\n        this.modeStack.push('array-value');\n        this.skipWhitespace();\n        return this.parseValue();\n      }\n    case 'obj-key':\n      if (this.ch() === 125) {\n        this.modeStack.pop();\n        this.pos++;\n        this.skipWhitespace();\n        return new Token(Type.break, undefined, 1);\n      }\n      if (this.ch() !== 44) {\n        throw new Error(`${ decodeErrPrefix } unexpected character at position ${ this.pos }, was expecting object delimiter but found '${ String.fromCharCode(this.ch()) }'`);\n      }\n      this.pos++;\n      this.skipWhitespace();\n    case 'obj-start': {\n        this.modeStack.pop();\n        if (this.ch() === 125) {\n          this.pos++;\n          this.skipWhitespace();\n          return new Token(Type.break, undefined, 1);\n        }\n        const token = this.parseString();\n        this.skipWhitespace();\n        if (this.ch() !== 58) {\n          throw new Error(`${ decodeErrPrefix } unexpected character at position ${ this.pos }, was expecting key/value delimiter ':' but found '${ String.fromCharCode(this.ch()) }'`);\n        }\n        this.pos++;\n        this.modeStack.push('obj-value');\n        return token;\n      }\n    case 'obj-value': {\n        this.modeStack.pop();\n        this.modeStack.push('obj-key');\n        this.skipWhitespace();\n        return this.parseValue();\n      }\n    default:\n      throw new Error(`${ decodeErrPrefix } unexpected parse state at position ${ this.pos }; this shouldn't happen`);\n    }\n  }\n}\nfunction decode(data, options) {\n  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options);\n  return _decode(data, options);\n}\nexport {\n  decode,\n  Tokenizer\n};", "// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n", "/* eslint max-depth: [\"error\", 7] */\nimport { Token, Type } from 'cborg'\nimport * as cborgJson from 'cborg/json'\nimport { CID } from 'multiformats'\nimport { base64 } from 'multiformats/bases/base64'\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n/**\n * @template T\n * @typedef {import('multiformats').ToString<T>} ToString\n */\n/**\n * @typedef {import('cborg/interface').DecodeTokenizer} DecodeTokenizer\n */\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal. Encoding a CID means replacing it with a `{\"/\":\"<CidString>}`\n * object as per the DAG-JSON spec.\n *\n * @param {any} obj\n * @returns {Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const cidString = cid.toString()\n\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.string, cidString, cidString.length), // value\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n/**\n * bytesEncoder will receive all Uint8Arrays (and friends) during encode, it\n * needs to replace it with a `{\"/\":{\"bytes\":\"Base64ByteString\"}}` object as\n * per the DAG-JSON spec.\n *\n * @param {Uint8Array} bytes\n * @returns {Token[]|null}\n */\nfunction bytesEncoder (bytes) {\n  const bytesString = base64.encode(bytes).slice(1) // no mbase prefix\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.map, Infinity, 1), // value\n    new Token(Type.string, 'bytes', 5), // inner key\n    new Token(Type.string, bytesString, bytesString.length), // inner value\n    new Token(Type.break, undefined, 1),\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n/**\n * taBytesEncoder wraps bytesEncoder() but for the more exotic typed arrays so\n * that we access the underlying ArrayBuffer data\n *\n * @param {Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|Uint8ClampedArray|BigInt64Array|BigUint64Array} obj\n * @returns {Token[]|null}\n */\nfunction taBytesEncoder (obj) {\n  return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n}\n\n/**\n * abBytesEncoder wraps bytesEncoder() but for plain ArrayBuffers\n *\n * @param {ArrayBuffer} ab\n * @returns {Token[]|null}\n */\nfunction abBytesEncoder (ab) {\n  return bytesEncoder(new Uint8Array(ab))\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null // process with standard number encoder\n}\n\nconst encodeOptions = {\n  typeEncoders: {\n    Object: cidEncoder,\n    Buffer: bytesEncoder,\n    Uint8Array: bytesEncoder,\n    Int8Array: taBytesEncoder,\n    Uint16Array: taBytesEncoder,\n    Int16Array: taBytesEncoder,\n    Uint32Array: taBytesEncoder,\n    Int32Array: taBytesEncoder,\n    Float32Array: taBytesEncoder,\n    Float64Array: taBytesEncoder,\n    Uint8ClampedArray: taBytesEncoder,\n    BigInt64Array: taBytesEncoder,\n    BigUint64Array: taBytesEncoder,\n    DataView: taBytesEncoder,\n    ArrayBuffer: abBytesEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass DagJsonTokenizer extends cborgJson.Tokenizer {\n  /**\n   * @param {Uint8Array} data\n   * @param {object} [options]\n   */\n  constructor (data, options) {\n    super(data, options)\n    /** @type {Token[]} */\n    this.tokenBuffer = []\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  done () {\n    return this.tokenBuffer.length === 0 && super.done()\n  }\n\n  /**\n   * @returns {Token}\n   */\n  _next () {\n    if (this.tokenBuffer.length > 0) {\n      // @ts-ignore https://github.com/Microsoft/TypeScript/issues/30406\n      return this.tokenBuffer.pop()\n    }\n    return super.next()\n  }\n\n  /**\n   * Implements rules outlined in https://github.com/ipld/specs/pull/356\n   *\n   * @returns {Token}\n   */\n  next () {\n    const token = this._next()\n\n    if (token.type === Type.map) {\n      const keyToken = this._next()\n      if (keyToken.type === Type.string && keyToken.value === '/') {\n        const valueToken = this._next()\n        if (valueToken.type === Type.string) { // *must* be a CID\n          const breakToken = this._next() // swallow the end-of-map token\n          if (breakToken.type !== Type.break) {\n            throw new Error('Invalid encoded CID form')\n          }\n          this.tokenBuffer.push(valueToken) // CID.parse will pick this up after our tag token\n          return new Token(Type.tag, 42, 0)\n        }\n        if (valueToken.type === Type.map) {\n          const innerKeyToken = this._next()\n          if (innerKeyToken.type === Type.string && innerKeyToken.value === 'bytes') {\n            const innerValueToken = this._next()\n            if (innerValueToken.type === Type.string) { // *must* be Bytes\n              for (let i = 0; i < 2; i++) {\n                const breakToken = this._next() // swallow two end-of-map tokens\n                if (breakToken.type !== Type.break) {\n                  throw new Error('Invalid encoded Bytes form')\n                }\n              }\n              const bytes = base64.decode(`m${innerValueToken.value}`)\n              return new Token(Type.bytes, bytes, innerValueToken.value.length)\n            }\n            this.tokenBuffer.push(innerValueToken) // bail\n          }\n          this.tokenBuffer.push(innerKeyToken) // bail\n        }\n        this.tokenBuffer.push(valueToken) // bail\n      }\n      this.tokenBuffer.push(keyToken) // bail\n    }\n    return token\n  }\n}\n\nconst decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\n\n// we're going to get TAG(42)STRING(\"bafy...\") from the tokenizer so we only need\n// to deal with the STRING(\"bafy...\") at this point\ndecodeOptions.tags[42] = CID.parse\n\nexport const name = 'dag-json'\nexport const code = 0x0129\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborgJson.encode(node, encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => {\n  // the tokenizer is stateful so we need a single instance of it\n  const options = Object.assign(decodeOptions, { tokenizer: new DagJsonTokenizer(data, decodeOptions) })\n  return cborgJson.decode(data, options)\n}\n\n/**\n * @template T\n * @param {T} node\n * @returns {ToString<T>}\n */\nexport const format = (node) => utf8Decoder.decode(encode(node))\nexport { format as stringify }\nconst utf8Decoder = new TextDecoder()\n\n/**\n * @template T\n * @param {ToString<T>} data\n * @returns {T}\n */\nexport const parse = (data) => decode(utf8Encoder.encode(data))\nconst utf8Encoder = new TextEncoder()\n", "const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n", "import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n", "export const PACKAGE_VERSION = \"0.15.1\";\n", "import { format, parse, ToString } from '@ipld/dag-json'\nimport { AnyBlock, AnyLink, DbMeta } from './types'\n\nimport { PACKAGE_VERSION } from './version'\nimport type { Loader } from './loader'\nconst match = PACKAGE_VERSION.match(/^([^.]*\\.[^.]*)/)\nif (!match) throw new Error('invalid version: ' + PACKAGE_VERSION)\nexport const STORAGE_VERSION = match[0]\n\nabstract class VersionedStore {\n  STORAGE_VERSION: string = STORAGE_VERSION\n  name: string\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nexport abstract class MetaStore extends VersionedStore {\n  tag: string = 'header-base'\n\n  makeHeader({ car, key }: DbMeta): ToString<DbMeta> {\n    const encoded = format({ car, key } as DbMeta)\n    return encoded\n  }\n\n  parseHeader(headerData: ToString<DbMeta>): DbMeta {\n    const got = parse<DbMeta>(headerData)\n    return got\n  }\n\n  abstract load(branch?: string): Promise<DbMeta[] | null>\n  abstract save(dbMeta: DbMeta, branch?: string): Promise<DbMeta[] | null>\n}\n\ntype DataSaveOpts = {\n  public?: boolean\n}\n\nexport abstract class DataStore {\n  tag: string = 'car-base'\n\n  STORAGE_VERSION: string = STORAGE_VERSION\n  name: string\n  constructor(name: string) {\n    this.name = name\n  }\n\n  abstract load(cid: AnyLink): Promise<AnyBlock>\n  abstract save(car: AnyBlock, opts?: DataSaveOpts): Promise<void | AnyLink>\n  abstract remove(cid: AnyLink): Promise<void>\n}\n", "type QueueFunction = () => Promise<void>;\n\nexport class CommitQueue<T = void> {\n  private queue: QueueFunction[] = [];\n  private processing = false;\n\n  async enqueue(fn: () => Promise<T>): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      const queueFn = async () => {\n        try {\n          resolve(await fn());\n        } catch (e) {\n          reject(e);\n        } finally {\n          this.processing = false;\n          this.processNext();\n        }\n      };\n      this.queue.push(queueFn);\n      if (!this.processing) {\n        this.processNext();\n      }\n    });\n  }\n\n  private processNext() {\n    if (this.queue.length > 0 && !this.processing) {\n      this.processing = true;\n      const queueFn = this.queue.shift();\n      if (queueFn) {\n        queueFn();\n      }\n    }\n  }\n}\n", "import pLimit from 'p-limit';\nimport { AnyLink, CommitOpts, DbMeta } from './types';\nimport { cidListIncludes, type Loader } from './loader';\nimport { DbLoader } from './loaders';\nimport { STORAGE_VERSION } from './store';\nimport { CommitQueue } from './commit-queue'\n\n\nexport type WALState = {\n  operations: DbMeta[];\n  noLoaderOps: DbMeta[];\n  fileOperations: { cid: AnyLink; public: boolean; }[];\n};\n\nexport abstract class RemoteWAL {\n  tag: string = 'rwal-base';\n\n  STORAGE_VERSION: string = STORAGE_VERSION;\n  loader: Loader;\n  ready: Promise<void>;\n\n  walState: WALState = { operations: [], noLoaderOps: [], fileOperations: [] };\n  processing: Promise<void> | undefined = undefined;\n  private processQueue = new CommitQueue<void>();\n\n  constructor(loader: Loader) {\n    this.loader = loader;\n    this.ready = (async () => {\n      const walState = await this.load().catch(e => {\n        console.error('error loading wal', e);\n        return null;\n      });\n      this.walState.operations = walState?.operations || [];\n      this.walState.fileOperations = walState?.fileOperations || [];\n    })();\n  }\n\n  async enqueue(dbMeta: DbMeta, opts: CommitOpts) {\n    await this.ready;\n    if (opts.noLoader) {\n      this.walState.noLoaderOps.push(dbMeta);\n    } else {\n      this.walState.operations.push(dbMeta);\n    }\n    await this.save(this.walState);\n    void this._process()\n  }\n\n  async enqueueFile(fileCid: AnyLink, publicFile = false) {\n    await this.ready;\n    this.walState.fileOperations.push({ cid: fileCid, public: publicFile });\n    // await this.save(this.walState)\n  }\n\n  async _process() {\n    await this.ready;\n    if (!this.loader.remoteCarStore) return;\n    await this.processQueue.enqueue(async () => {\n      await this._doProcess();\n      if (this.walState.operations.length ||\n        this.walState.fileOperations.length ||\n        this.walState.noLoaderOps.length) {\n        setTimeout(() => void this._process(), 0);\n      }\n    });\n  }\n\n  async _doProcess() {\n    if (!this.loader.remoteCarStore) return;\n    const rmlp = (async () => {\n      const operations = [...this.walState.operations];\n      const fileOperations = [...this.walState.fileOperations];\n      const uploads: Promise<void | AnyLink>[] = [];\n      const noLoaderOps = [...this.walState.noLoaderOps];\n      const limit = pLimit(5);\n\n      if (operations.length + fileOperations.length + noLoaderOps.length === 0) return;\n\n      for (const dbMeta of noLoaderOps) {\n        const uploadP = limit(async () => {\n          const car = await this.loader.carStore!.load(dbMeta.car).catch(() => null)\n          if (!car) {\n            if (cidListIncludes(this.loader.carLog, dbMeta.car))\n              throw new Error(`missing car ${dbMeta.car.toString()}`)\n          } else {\n            await this.loader.remoteCarStore!.save(car)\n          }\n          this.walState.noLoaderOps = this.walState.noLoaderOps.filter(op => op !== dbMeta)\n        })\n        uploads.push(uploadP)\n      }\n\n      for (const dbMeta of operations) {\n        const uploadP = limit(async () => {\n          const car = await this.loader.carStore!.load(dbMeta.car).catch(() => null)\n          if (!car) {\n            if (cidListIncludes(this.loader.carLog, dbMeta.car))\n              throw new Error(`missing car ${dbMeta.car.toString()}`)\n          } else {\n            await this.loader.remoteCarStore!.save(car)\n          }\n          this.walState.operations = this.walState.operations.filter(op => op !== dbMeta)\n        })\n        uploads.push(uploadP)\n      }\n\n      if (fileOperations.length) {\n        const dbLoader = this.loader as DbLoader;\n        for (const { cid: fileCid, public: publicFile } of fileOperations) {\n          const uploadP = limit(async () => {\n            const fileBlock = await dbLoader.fileStore!.load(fileCid); // .catch(() => false)\n            await dbLoader.remoteFileStore?.save(fileBlock, { public: publicFile });\n            this.walState.fileOperations = this.walState.fileOperations.filter(op => op.cid !== fileCid);\n          });\n          uploads.push(uploadP);\n        }\n      }\n\n      try {\n        const res = await Promise.allSettled(uploads);\n        const errors = res.filter(r => r.status === 'rejected') as PromiseRejectedResult[];\n        if (errors.length) {\n          console.error('error uploading', JSON.stringify(errors));\n          throw errors[0].reason;\n        }\n        if (operations.length) {\n          const lastOp = operations[operations.length - 1];\n          // console.log('saving remote meta', lastOp.car.toString())\n          await this.loader.remoteMetaStore?.save(lastOp).catch((e: Error) => {\n            console.error('error saving remote meta', e);\n            this.walState.operations.push(lastOp);\n            throw e;\n          });\n        }\n      } finally {\n        await this.save(this.walState);\n      }\n    })();\n    this.loader.remoteMetaLoading = rmlp;\n    await rmlp;\n  }\n\n  abstract load(branch?: string): Promise<WALState | null>;\n  abstract save(state: WALState, branch?: string): Promise<void>;\n}\n", "/* eslint-disable import/first */\nimport { format, parse, ToString } from '@ipld/dag-json'\nimport { openDB, IDBPDatabase } from 'idb'\nimport { AnyBlock, AnyLink, DbMeta } from './types'\nimport { DataStore as DataStoreBase, MetaStore as MetaStoreBase } from './store'\nimport { RemoteWAL as RemoteWALBase, WALState } from './remote-wal'\n\n// ts-unused-exports:disable-next-line\nexport class DataStore extends DataStoreBase {\n  tag: string = 'car-browser-idb'\n  idb: IDBPDatabase<unknown> | null = null\n\n  async _withDB(dbWorkFun: (arg0: any) => any) {\n    if (!this.idb) {\n      const dbName = `fp.${this.STORAGE_VERSION}.${this.name}`\n      this.idb = await openDB(dbName, 1, {\n        upgrade(db): void {\n          db.createObjectStore('cars')\n        }\n      })\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return await dbWorkFun(this.idb)\n  }\n\n  async load(cid: AnyLink): Promise<AnyBlock> {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return await this._withDB(async (db: IDBPDatabase<unknown>) => {\n      const tx = db.transaction(['cars'], 'readonly')\n      const bytes = (await tx.objectStore('cars').get(cid.toString())) as Uint8Array\n      if (!bytes) throw new Error(`missing idb block ${cid.toString()}`)\n      return { cid, bytes }\n    })\n  }\n\n  async save(car: AnyBlock): Promise<void> {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return await this._withDB(async (db: IDBPDatabase<unknown>) => {\n      const tx = db.transaction(['cars'], 'readwrite')\n      await tx.objectStore('cars').put(car.bytes, car.cid.toString())\n      return await tx.done\n    })\n  }\n\n  async remove(cid: AnyLink): Promise<void> {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return await this._withDB(async (db: IDBPDatabase<unknown>) => {\n      const tx = db.transaction(['cars'], 'readwrite')\n      await tx.objectStore('cars').delete(cid.toString())\n      return await tx.done\n    })\n  }\n}\n\n// ts-unused-exports:disable-next-line\n\nexport class RemoteWAL extends RemoteWALBase {\n  tag: string = 'wal-browser-ls'\n\n  headerKey(branch: string) {\n    // remove 'public' on next storage version bump\n    return `fp.${this.STORAGE_VERSION}.wal.${this.loader.name}.${branch}`\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async load(branch = 'main'): Promise<WALState | null> {\n    try {\n      const bytesString = localStorage.getItem(this.headerKey(branch))\n      if (!bytesString) return null\n      return parse<WALState>(bytesString)\n    } catch (e) {\n      return null\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async save(state: WALState, branch = 'main'): Promise<void> {\n    try {\n      const encoded: ToString<WALState> = format(state)\n      localStorage.setItem(this.headerKey(branch), encoded)\n    } catch (e) {\n      console.error('error saving wal', e)\n      throw e\n    }\n  }\n}\n\n// ts-unused-exports:disable-next-line\nexport class MetaStore extends MetaStoreBase {\n  tag: string = 'header-browser-ls'\n\n  headerKey(branch: string) {\n    return `fp.${this.STORAGE_VERSION}.meta.${this.name}.${branch}`\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async load(branch: string = 'main'): Promise<DbMeta[] | null> {\n    try {\n      const bytesString = localStorage.getItem(this.headerKey(branch))\n      if (!bytesString) return null\n      // browser assumes a single writer process\n      // to support concurrent updates to the same database across multiple tabs\n      // we need to implement the same kind of mvcc.crdt solution as in store-fs and connect-s3\n      return [this.parseHeader(bytesString)]\n    } catch (e) {\n      return null\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async save(meta: DbMeta, branch: string = 'main') {\n    try {\n      const headerKey = this.headerKey(branch)\n      const bytes = this.makeHeader(meta)\n      localStorage.setItem(headerKey, bytes)\n      return null\n    } catch (e) {\n      return null\n    }\n  }\n}\n", "import pLimit from 'p-limit'\nimport { CarReader } from '@ipld/car'\nimport { encodeCarFile, encodeCarHeader, parseCarFile } from './loader-helpers'\nimport { decodeEncryptedCar, encryptedEncodeCarFile } from './encrypt-helpers'\nimport { getCrypto, randomBytes } from './crypto-web'\n\nimport { DataStore, MetaStore, RemoteWAL } from './store-browser'\nimport { DataStore as AbstractDataStore, MetaStore as AbstractMetaStore } from './store'\n\nimport { CID } from 'multiformats'\nimport type { Transaction } from './transaction'\nimport type {\n  AnyBlock, AnyCarHeader, AnyLink, BulkResult,\n  CarLoaderHeader,\n  CommitOpts,\n  DbCarHeader,\n  DbMeta, FileCarHeader, FileResult, FireproofOptions\n} from './types'\n// import type { Connection } from './connection'\nimport { isFileResult, type DbLoader, type IndexerResult } from './loaders'\nimport { CommitQueue } from './commit-queue'\n\n\n\n\n// ts-unused-exports:disable-next-line\nexport function cidListIncludes(list: AnyLink[], cid: AnyLink) {\n  return list.some(c => c.equals(cid))\n}\nexport function uniqueCids(list: AnyLink[], remove: Set<string> = new Set()): AnyLink[] {\n  const byString = new Map<string, AnyLink>()\n  for (const cid of list) {\n    if (remove.has(cid.toString())) continue\n    byString.set(cid.toString(), cid)\n  }\n  return [...byString.values()]\n}\n\n// ts-unused-exports:disable-next-line\nexport function toHexString(byteArray: Uint8Array) {\n  return Array.from(byteArray)\n    .map(byte => byte.toString(16).padStart(2, '0'))\n    .join('')\n}\n\nabstract class AbstractRemoteMetaStore extends AbstractMetaStore {\n  abstract handleByteHeads(byteHeads: Uint8Array[], branch?: string): Promise<DbMeta[]>\n}\n\nexport abstract class Loader {\n  name: string\n  opts: FireproofOptions = {}\n  commitQueue = new CommitQueue<AnyLink>()\n  isCompacting = false\n  isWriting = false\n\n  remoteMetaLoading: Promise<void> | undefined\n  remoteMetaStore: AbstractRemoteMetaStore | undefined\n  remoteCarStore: AbstractDataStore | undefined\n  remoteWAL: RemoteWAL\n  metaStore: MetaStore\n  carStore: DataStore\n  carLog: AnyLink[] = []\n  carReaders: Map<string, Promise<CarReader>> = new Map()\n  ready: Promise<void>\n  key: string | undefined\n  keyId: string | undefined\n  seenCompacted: Set<string> = new Set()\n\n  private getBlockCache: Map<string, AnyBlock> = new Map()\n  private seenMeta: Set<string> = new Set()\n\n  static defaultHeader: AnyCarHeader\n  abstract defaultHeader: AnyCarHeader\n\n  constructor(name: string, opts?: FireproofOptions) {\n    this.name = name\n    this.opts = opts || this.opts\n    this.metaStore = new MetaStore(this.name)\n    this.carStore = new DataStore(this.name)\n    this.remoteWAL = new RemoteWAL(this)\n    this.ready = Promise.resolve().then(async () => {\n      if (!this.metaStore || !this.carStore || !this.remoteWAL)\n        throw new Error('stores not initialized')\n      const metas = this.opts.meta ? [this.opts.meta] : await this.metaStore.load('main')\n      if (metas) {\n        await this.handleDbMetasFromStore(metas)\n      }\n    })\n  }\n\n  async snapToCar(carCid: AnyLink | string) {\n    await this.ready\n    if (typeof carCid === 'string') {\n      carCid = CID.parse(carCid)\n    }\n    const carHeader = await this.loadCarHeaderFromMeta({ car: carCid, key: this.key || null })\n    this.carLog = [carCid, ...carHeader.cars]\n    await this.getMoreReaders(carHeader.cars)\n    await this._applyCarHeader(carHeader, true)\n  }\n\n  async _readyForMerge() {}\n  async _setWaitForWrite(_writing: () => Promise<void>) {}\n\n  async handleDbMetasFromStore(metas: DbMeta[]): Promise<void> {    \n    for (const meta of metas) {\n      const writingFn = async () => {\n        this.isWriting = true\n        await this.mergeDbMetaIntoClock(meta)\n        this.isWriting = false\n      }\n      this._setWaitForWrite(writingFn)\n      await writingFn()\n    }\n  }\n\n  async mergeDbMetaIntoClock(meta: DbMeta): Promise<void> {\n    const ld = this as unknown as DbLoader\n    await ld.compacting\n    if (this.isCompacting) {\n      throw new Error('cannot merge while compacting')\n    }\n    if (this.seenMeta.has(meta.car.toString())) return\n    this.seenMeta.add(meta.car.toString())\n\n    if (meta.key) {\n      await this.setKey(meta.key)\n    }\n    if (cidListIncludes(this.carLog, meta.car)) {\n      return\n    }\n    const carHeader = (await this.loadCarHeaderFromMeta(meta)) as DbCarHeader\n    // fetch other cars down the compact log?\n    // todo we should use a CID set for the compacted cids (how to expire?)\n    // console.log('merge carHeader', carHeader.head.length, carHeader.head.toString(), meta.car.toString())\n    carHeader.compact.map(c => c.toString()).forEach(this.seenCompacted.add, this.seenCompacted)\n    await this.getMoreReaders(carHeader.cars)\n    this.carLog = [...uniqueCids([meta.car, ...this.carLog, ...carHeader.cars], this.seenCompacted)]\n    await this._applyCarHeader(carHeader)\n  }\n\n  protected async ingestKeyFromMeta(meta: DbMeta): Promise<void> {\n    const { key } = meta\n    if (key) {\n      await this.setKey(key)\n    }\n  }\n\n  async loadCarHeaderFromMeta({ car: cid }: DbMeta): Promise<CarLoaderHeader> {\n    const reader = await this.loadCar(cid)\n    return (await parseCarFile(reader)) as CarLoaderHeader\n  }\n\n  protected abstract _applyCarHeader(_carHeader: CarLoaderHeader, snap?: boolean): Promise<void>\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async _getKey() {\n    if (this.key) return this.key\n    // generate a random key\n    if (!this.opts.public) {\n      if (getCrypto()) {\n        await this.setKey(toHexString(randomBytes(32)))\n      } else {\n        console.warn('missing crypto module, using public mode')\n      }\n    }\n    return this.key\n  }\n\n  async commit(\n    t: Transaction,\n    done: IndexerResult | BulkResult | FileResult,\n    opts: CommitOpts = { noLoader: false, compact: false }\n  ): Promise<AnyLink> {\n    return this.commitQueue.enqueue(() => this._commitInternal(t, done, opts))\n  }\n\n  async _commitInternal(\n    t: Transaction,\n    done: IndexerResult | BulkResult | FileResult,\n    opts: CommitOpts = { noLoader: false, compact: false }\n  ): Promise<AnyLink> {\n    await this.ready\n    const fp = this.makeCarHeader(done, this.carLog, !!opts.compact)\n    let roots: AnyLink[] = []\n    // @ts-ignore\n    if (fp.files) {\n      // @ts-ignore\n      roots = fp.files as AnyLink[]\n    } else {\n      const header = await encodeCarHeader(fp)\n      await t.put(header.cid, header.bytes)\n      roots = [header.cid]\n      // const got = await t.get(header.cid)\n      // if (!got) throw new Error('missing header block: '+header.cid.toString())\n    }\n\n    const theKey = opts.public ? null : await this._getKey()\n    const { cid, bytes } = theKey\n      ? await encryptedEncodeCarFile(theKey, roots[0], t)\n      : await encodeCarFile(roots, t)\n\n    if (isFileResult(done)) {\n      // move to the db loader?\n      const dbLoader = this as unknown as DbLoader\n      await dbLoader.fileStore!.save({ cid, bytes })\n      await this.remoteWAL!.enqueueFile(cid, opts.public)\n      return cid\n    }\n    // console.log('saving car', cid.toString())\n    await this.carStore!.save({ cid, bytes })\n\n    const newDbMeta = { car: cid, key: theKey || null } as DbMeta\n    await this.remoteWAL!.enqueue(newDbMeta, opts)\n\n    await this.metaStore!.save(newDbMeta)\n\n    if (opts.compact) {\n      const fpCar = fp as CarLoaderHeader\n      fpCar.compact.map(c => c.toString()).forEach(this.seenCompacted.add, this.seenCompacted)\n      this.carLog = [...uniqueCids([cid, ...this.carLog], this.seenCompacted)]\n      setTimeout(async () => {\n        if (this.remoteMetaLoading) await this.remoteMetaLoading\n        for (const cid of fpCar.compact) {\n          await this.carStore!.remove(cid)\n        } // todo instead we should have no delay, but delete previous compaction's old files\n      }, 5000)\n    } else {\n      this.carLog.unshift(cid)\n    }\n    return cid\n  }\n\n  async flushCars() {\n    await this.ready\n    // for each cid in car log, make a dbMeta\n    for (const cid of this.carLog) {\n      const dbMeta = { car: cid, key: this.key || null } as DbMeta\n      await this.remoteWAL!.enqueue(dbMeta, { public: false })\n    }\n  }\n\n  async *entries(): AsyncIterableIterator<AnyBlock> {\n    await this.ready\n    for (const cid of this.carLog) {\n      const reader = await this.loadCar(cid)\n      if (!reader) throw new Error(`missing car reader ${cid.toString()}`)\n      for await (const block of reader.blocks()) {\n        yield block\n      }\n    }\n  }\n\n  async getBlock(cid: AnyLink): Promise<AnyBlock | undefined> {\n    await this.ready\n    const sCid = cid.toString()\n    if (this.getBlockCache.has(sCid)) return this.getBlockCache.get(sCid)\n    const got = await Promise.any(\n      this.carLog.map(async carCid => {\n        const reader = await this.loadCar(carCid)\n        if (!reader) {\n          throw new Error(`missing car reader ${carCid.toString()}`)\n        }\n        const block = await reader.get(cid as CID)\n        if (block) {\n          return block\n        }\n        throw new Error(`block not in reader: ${cid.toString()}`)\n      })\n    ).catch(() => undefined)\n    if (got) {\n      this.getBlockCache.set(sCid, got)\n    }\n    return got\n  }\n\n  protected abstract makeCarHeader(\n    _result: BulkResult | IndexerResult | FileResult,\n    _cars: AnyLink[],\n    _compact: boolean\n  ): AnyCarHeader | FileCarHeader\n\n  protected async loadCar(cid: AnyLink): Promise<CarReader> {\n    if (!this.carStore) throw new Error('car store not initialized')\n    return await this.storesLoadCar(cid, this.carStore, this.remoteCarStore)\n  }\n\n  protected async storesLoadCar(\n    cid: AnyLink,\n    local: AbstractDataStore,\n    remote?: AbstractDataStore,\n    publicFiles?: boolean\n  ): Promise<CarReader> {\n    const cidString = cid.toString()\n    if (!this.carReaders.has(cidString)) {\n      this.carReaders.set(\n        cidString,\n        (async () => {\n          let loadedCar: AnyBlock | null = null\n          try {\n            loadedCar = await local.load(cid)\n          } catch (e) {\n            if (remote) {\n              const remoteCar = await remote.load(cid)\n              if (remoteCar) {\n                // todo test for this\n                await local.save(remoteCar)\n                loadedCar = remoteCar\n              }\n            }\n          }\n          if (!loadedCar) throw new Error(`missing car file ${cidString}`)\n          const rawReader = await CarReader.fromBytes(loadedCar.bytes)\n          const readerP = publicFiles\n            ? Promise.resolve(rawReader)\n            : this.ensureDecryptedReader(rawReader)\n          this.carReaders.set(cidString, readerP)\n          return readerP\n        })().catch(e => {\n          this.carReaders.delete(cidString)\n          throw e\n        })\n      )\n    }\n    return this.carReaders.get(cidString) as Promise<CarReader>\n  }\n\n  protected async ensureDecryptedReader(reader: CarReader) {\n    const theKey = await this._getKey()\n    if (!theKey) return reader\n    const { blocks, root } = await decodeEncryptedCar(theKey, reader)\n    return {\n      getRoots: () => [root],\n      get: blocks.get.bind(blocks),\n      blocks: blocks.entries.bind(blocks)\n    } as unknown as CarReader\n  }\n\n  protected async setKey(key: string) {\n    if (this.key && this.key !== key) throw new Error('key mismatch')\n    this.key = key\n    const crypto = getCrypto()\n    if (!crypto) throw new Error('missing crypto module')\n    const subtle = crypto.subtle\n    const encoder = new TextEncoder()\n    const data = encoder.encode(key)\n    const hashBuffer = await subtle.digest('SHA-256', data)\n    const hashArray = Array.from(new Uint8Array(hashBuffer))\n    this.keyId = hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n  }\n\n  protected async getMoreReaders(cids: AnyLink[]) {\n    const limit = pLimit(5)\n    const missing = cids.filter(cid => !this.carReaders.has(cid.toString()))\n    await Promise.all(missing.map(cid => limit(() => this.loadCar(cid))))\n  }\n}\n\nexport interface Connection {\n  loader: Loader\n  loaded: Promise<void>\n}\n\n\n", "import type { Block, Link } from 'multiformats'\nimport { create } from 'multiformats/block'\nimport { sha256 as hasher } from 'multiformats/hashes/sha2'\nimport * as codec from '@ipld/dag-cbor'\n\n// @ts-ignore\nimport charwise from 'charwise'\n// @ts-ignore\nimport * as DbIndex from 'prolly-trees/db-index'\n// @ts-ignore\nimport { bf, simpleCompare } from 'prolly-trees/utils'\n// @ts-ignore\nimport { nocache as cache } from 'prolly-trees/cache'\n// @ts-ignore\nimport { ProllyNode as BaseNode } from 'prolly-trees/base'\n\nimport { AnyLink, DocUpdate, MapFn, DocFragment, BlockFetcher, IndexKey, IndexUpdate, QueryOpts, IndexRow, AnyBlock, Doc } from './types'\nimport { Transaction } from './transaction'\nimport { CRDT } from './crdt'\n\nexport class IndexTree {\n  cid: AnyLink | null = null\n  root: ProllyNode | null = null\n}\n\ntype CompareRef = string | number\ntype CompareKey = [string | number, CompareRef]\n\nconst refCompare = (aRef: CompareRef, bRef: CompareRef) => {\n  if (Number.isNaN(aRef)) return -1\n  if (Number.isNaN(bRef)) throw new Error('ref may not be Infinity or NaN')\n  if (aRef === Infinity) return 1\n  // if (!Number.isFinite(bRef)) throw new Error('ref may not be Infinity or NaN')\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n  return simpleCompare(aRef, bRef) as number\n}\n\nconst compare = (a: CompareKey, b: CompareKey) => {\n  const [aKey, aRef] = a\n  const [bKey, bRef] = b\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\n  const comp: number = simpleCompare(aKey, bKey)\n  if (comp !== 0) return comp\n  return refCompare(aRef, bRef)\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\nexport const byKeyOpts: StaticProllyOptions = { cache, chunker: bf(30), codec, hasher, compare }\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\nexport const byIdOpts: StaticProllyOptions = { cache, chunker: bf(30), codec, hasher, compare: simpleCompare }\n\nexport function indexEntriesForChanges(\n  changes: DocUpdate[],\n  mapFn: MapFn\n): { key: [string, string]; value: DocFragment }[] {\n  const indexEntries: { key: [string, string]; value: DocFragment }[] = []\n  changes.forEach(({ key: _id, value, del }) => {\n    if (del || !value) return\n    let mapCalled = false\n    const mapReturn = mapFn({ _id, ...value }, (k: DocFragment, v?: DocFragment) => {\n      mapCalled = true\n      if (typeof k === 'undefined') return\n      indexEntries.push({\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n        key: [charwise.encode(k) as string, _id],\n        value: v || null\n      })\n    })\n    if (!mapCalled && mapReturn) {\n      indexEntries.push({\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n        key: [charwise.encode(mapReturn) as string, _id],\n        value: null\n      })\n    }\n  })\n  return indexEntries\n}\n\nfunction makeProllyGetBlock(blocks: BlockFetcher): (address: AnyLink) => Promise<AnyBlock> {\n  return async (address: AnyLink) => {\n    const block = await blocks.get(address)\n    if (!block) throw new Error(`Missing block ${address.toString()}`)\n    const { cid, bytes } = block\n    return create({ cid, bytes, hasher, codec }) as Promise<AnyBlock>\n  }\n}\n\nexport async function bulkIndex(tblocks: Transaction, inIndex: IndexTree, indexEntries: IndexUpdate[], opts: StaticProllyOptions): Promise<IndexTree> {\n  if (!indexEntries.length) return inIndex\n  if (!inIndex.root) {\n    if (!inIndex.cid) {\n      let returnRootBlock: Block | null = null\n      let returnNode: ProllyNode | null = null\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n      for await (const node of await DbIndex.create({ get: makeProllyGetBlock(tblocks), list: indexEntries, ...opts }) as ProllyNode[]) {\n        const block = await node.block\n        await tblocks.put(block.cid, block.bytes)\n        returnRootBlock = block\n        returnNode = node\n      }\n      if (!returnNode || !returnRootBlock) throw new Error('failed to create index')\n      return { root: returnNode, cid: returnRootBlock.cid }\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n      inIndex.root = await DbIndex.load({ cid: inIndex.cid, get: makeProllyGetBlock(tblocks), ...opts }) as ProllyNode\n    }\n  }\n  const { root, blocks: newBlocks } = await inIndex.root.bulk(indexEntries)\n  if (root) {\n    for await (const block of newBlocks) {\n      await tblocks.put(block.cid, block.bytes)\n    }\n    return { root, cid: (await root.block).cid }\n  } else {\n    return { root: null, cid: null }\n  }\n}\n\nexport async function loadIndex(tblocks: BlockFetcher, cid: AnyLink, opts: StaticProllyOptions): Promise<ProllyNode> {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n  return await DbIndex.load({ cid, get: makeProllyGetBlock(tblocks), ...opts }) as ProllyNode\n}\n\nexport async function applyQuery(crdt: CRDT, resp: { result: IndexRow[] }, query: QueryOpts) {\n  if (query.descending) {\n    resp.result = resp.result.reverse()\n  }\n  if (query.limit) {\n    resp.result = resp.result.slice(0, query.limit)\n  }\n  if (query.includeDocs) {\n    resp.result = await Promise.all(\n      resp.result.map(async row => {\n        const val = await crdt.get(row.id)\n        const doc = val ? ({ _id: row.id, ...val.doc } as Doc) : null\n        return { ...row, doc }\n      })\n    )\n  }\n  return {\n    rows: resp.result.map(row => {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n      row.key = (charwise.decode(row.key) as IndexKey)\n      if (row.row && !row.value) {\n        row.value = row.row\n        delete row.row\n      }\n      return row\n    })\n  }\n}\n\nexport function encodeRange(range: [DocFragment, DocFragment]): [IndexKey, IndexKey] {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n  return range.map(key => charwise.encode(key) as IndexKey) as [IndexKey, IndexKey]\n}\n\nexport function encodeKey(key: DocFragment): string {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n  return charwise.encode(key) as string\n}\n\n// ProllyNode type based on the ProllyNode from 'prolly-trees/base'\ninterface ProllyNode extends BaseNode {\n  getAllEntries(): PromiseLike<{ [x: string]: any; result: IndexRow[] }>\n  getMany(removeIds: string[]): Promise<{ [x: string]: any; result: IndexKey[] }>\n  range(a: IndexKey, b: IndexKey): Promise<{ result: IndexRow[] }>\n  get(key: string): Promise<{ result: IndexRow[] }>\n  bulk(bulk: IndexUpdate[]): PromiseLike<{ root: ProllyNode | null; blocks: Block[] }>\n  address: Promise<Link>\n  distance: number\n  compare: (a: any, b: any) => number\n  cache: any\n  block: Promise<Block>\n}\n\ninterface StaticProllyOptions {\n  cache: any\n  chunker: (entry: any, distance: number) => boolean\n  codec: any\n  hasher: any\n  compare: (a: any, b: any) => number\n}\n", "import {\n  Entry,\n  EntryList,\n  IPLDLeaf,\n  IPLDBranch,\n  create as baseCreate\n} from './base.js';\nimport { readUInt32LE } from './utils.js';\nclass MapEntry extends Entry {\n  async identity() {\n    const encoded = await this.codec.encode(await this.encodeNode());\n    const hash = await this.hasher.encode(encoded);\n    return readUInt32LE(hash);\n  }\n}\nclass MapLeafEntry extends MapEntry {\n  constructor(node, opts) {\n    super(node, opts);\n    this.value = node.value;\n  }\n  encodeNode() {\n    return [\n      this.key,\n      this.value\n    ];\n  }\n}\nclass MapBranchEntry extends MapEntry {\n  constructor(node, opts) {\n    if (!node.address)\n      throw new Error('Cannot create MapBranchEntry without address');\n    super(node, opts);\n  }\n  async encodeNode() {\n    return [\n      this.key,\n      await this.address\n    ];\n  }\n}\nconst getValue = async (node, key) => {\n  const {\n    result: entry,\n    cids\n  } = await node.getEntry(key);\n  return {\n    result: entry.value,\n    cids\n  };\n};\nconst getManyValues = async (node, keys) => {\n  const {\n    result: entries,\n    cids\n  } = await node.getEntries(keys);\n  return {\n    result: entries.map(entry => entry.value),\n    cids\n  };\n};\nclass MapLeaf extends IPLDLeaf {\n  get(key) {\n    return getValue(this, key);\n  }\n  getMany(keys) {\n    return getManyValues(this, keys);\n  }\n  bulk(bulk, opts = {}, isRoot = true) {\n    return super.bulk(bulk, {\n      ...classes,\n      ...opts\n    }, isRoot);\n  }\n}\nclass MapBranch extends IPLDBranch {\n  get(key) {\n    return getValue(this, key);\n  }\n  getMany(keys) {\n    return getManyValues(this, keys);\n  }\n  bulk(bulk, opts = {}, isRoot = true) {\n    return super.bulk(bulk, {\n      ...classes,\n      ...opts\n    }, isRoot);\n  }\n}\nconst classes = {\n  LeafClass: MapLeaf,\n  LeafEntryClass: MapLeafEntry,\n  BranchClass: MapBranch,\n  BranchEntryClass: MapBranchEntry\n};\nconst createGetNode = (get, cache, chunker, codec, hasher, compare, opts) => {\n  const LeafClass = opts.LeafClass || MapLeaf;\n  const LeafEntryClass = opts.LeafEntryClass || MapLeafEntry;\n  const BranchClass = opts.BranchClass || MapBranch;\n  const BranchEntryClass = opts.BranchEntryClass || MapBranchEntry;\n  const getNode = async cid => {\n    if (cache.has(cid))\n      return cache.get(cid);\n    return get(cid).then(block => decoder(block));\n  };\n  const decoder = makeDecoder({\n    chunker,\n    cache,\n    getNode,\n    codec,\n    hasher,\n    compare,\n    LeafEntryClass,\n    LeafClass,\n    BranchEntryClass,\n    BranchClass\n  });\n  return getNode;\n};\nconst create = ({get, cache, chunker, list, codec, hasher, sorted, compare, ...opts}) => {\n  if (!sorted)\n    list = list.sort(({key: a}, {key: b}) => compare(a, b));\n  const getNode = createGetNode(get, cache, chunker, codec, hasher, compare, opts);\n  const _opts = {\n    list,\n    codec,\n    hasher,\n    chunker,\n    getNode,\n    sorted,\n    compare,\n    cache,\n    LeafClass: opts.LeafClass || MapLeaf,\n    LeafEntryClass: opts.LeafEntryClass || MapLeafEntry,\n    BranchClass: opts.BranchClass || MapBranch,\n    BranchEntryClass: opts.BranchEntryClass || MapBranchEntry\n  };\n  return baseCreate(_opts);\n};\nconst load = ({cid, get, cache, chunker, codec, hasher, compare, ...opts}) => {\n  const getNode = createGetNode(get, cache, chunker, codec, hasher, compare, opts);\n  return getNode(cid);\n};\nfunction makeDecoder({chunker, cache, getNode, codec, hasher, compare, LeafEntryClass, LeafClass, BranchEntryClass, BranchClass}) {\n  const entryOpts = {\n    codec,\n    hasher\n  };\n  return block => {\n    const {value} = block;\n    const opts = {\n      chunker,\n      cache,\n      block,\n      getNode,\n      codec,\n      hasher,\n      compare\n    };\n    let entries;\n    let CLS;\n    if (value.leaf) {\n      entries = value.leaf.map(([key, value]) => new LeafEntryClass({\n        key,\n        value\n      }, entryOpts));\n      CLS = LeafClass;\n    } else if (value.branch) {\n      const [distance, _entries] = value.branch;\n      opts.distance = distance;\n      entries = _entries.map(([key, address]) => new BranchEntryClass({\n        key,\n        address\n      }, entryOpts));\n      CLS = BranchClass;\n    } else {\n      throw new Error('Unknown block data, does not match schema');\n    }\n    const entryList = new EntryList({\n      entries,\n      closed: value.closed\n    });\n    const node = new CLS({\n      entryList,\n      ...opts\n    });\n    cache.set(node);\n    return node;\n  };\n}\nexport {\n  create,\n  load,\n  MapLeaf,\n  MapBranch,\n  MapLeafEntry,\n  MapBranchEntry\n};", "import {\n  create as mapCreate,\n  load as mapLoad,\n  MapLeaf,\n  MapBranch,\n  MapLeafEntry,\n  MapBranchEntry\n} from './map.js';\nimport { simpleCompare } from './utils.js';\nconst compare = (a, b) => {\n  const [aKey, aRef] = a;\n  const [bKey, bRef] = b;\n  const comp = simpleCompare(aKey, bKey);\n  if (comp !== 0)\n    return comp;\n  return refCompare(aRef, bRef);\n};\nconst refCompare = (aRef, bRef) => {\n  if (Number.isNaN(aRef))\n    return -1;\n  if (Number.isNaN(bRef))\n    throw new Error('ref may not be Infinity or NaN');\n  if (!Number.isFinite(aRef))\n    return 1;\n  return simpleCompare(aRef, bRef);\n};\nconst getIndex = async (node, key) => {\n  const start = [\n    key,\n    NaN\n  ];\n  const end = [\n    key,\n    Infinity\n  ];\n  const {\n    result: entries,\n    cids\n  } = await node.getRangeEntries(start, end);\n  return {\n    result: entries.map(entry => {\n      const [key, id] = entry.key;\n      return {\n        id,\n        key,\n        row: entry.value\n      };\n    }),\n    cids\n  };\n};\nconst getRange = async (node, start, end) => {\n  start = [\n    start,\n    NaN\n  ];\n  end = [\n    end,\n    Infinity\n  ];\n  const {\n    result: entries,\n    cids\n  } = await node.getRangeEntries(start, end);\n  const result = entries.map(entry => {\n    const [key, id] = entry.key;\n    return {\n      id,\n      key,\n      row: entry.value\n    };\n  });\n  return {\n    result,\n    cids\n  };\n};\nclass DBIndexLeaf extends MapLeaf {\n  get(key) {\n    return getIndex(this, key);\n  }\n  range(start, end) {\n    return getRange(this, start, end);\n  }\n  bulk(bulk, opts = {}, isRoot = true) {\n    return super.bulk(bulk, {\n      ...classes,\n      ...opts\n    }, isRoot);\n  }\n}\nclass DBIndexBranch extends MapBranch {\n  get(key) {\n    return getIndex(this, key);\n  }\n  range(start, end) {\n    return getRange(this, start, end);\n  }\n  bulk(bulk, opts = {}, isRoot = true) {\n    return super.bulk(bulk, {\n      ...classes,\n      ...opts\n    }, isRoot);\n  }\n}\nconst LeafClass = DBIndexLeaf;\nconst BranchClass = DBIndexBranch;\nconst classes = {\n  LeafClass,\n  BranchClass,\n  LeafEntryClass: MapLeafEntry,\n  BranchEntryClass: MapBranchEntry\n};\nconst defaults = {\n  ...classes,\n  compare\n};\nconst create = opts => {\n  opts = {\n    ...defaults,\n    ...opts\n  };\n  return mapCreate(opts);\n};\nconst load = opts => {\n  opts = {\n    ...defaults,\n    ...opts\n  };\n  return mapLoad(opts);\n};\nexport {\n  create,\n  load,\n  DBIndexBranch,\n  DBIndexLeaf\n};", "import type { ClockHead, DocUpdate, MapFn, IndexUpdate, QueryOpts, IdxMeta, DocFragment } from './types'\nimport { IndexBlockstore } from './transaction'\nimport { bulkIndex, indexEntriesForChanges, byIdOpts, byKeyOpts, IndexTree, applyQuery, encodeRange, encodeKey, loadIndex } from './indexer-helpers'\nimport { CRDT } from './crdt'\n\nexport function index({ _crdt }: { _crdt: CRDT }, name: string, mapFn?: MapFn, meta?: IdxMeta): Index {\n  if (mapFn && meta) throw new Error('cannot provide both mapFn and meta')\n  if (mapFn && mapFn.constructor.name !== 'Function') throw new Error('mapFn must be a function')\n  if (_crdt.indexers.has(name)) {\n    const idx = _crdt.indexers.get(name)!\n    idx.applyMapFn(name, mapFn, meta)\n  } else {\n    const idx = new Index(_crdt, name, mapFn, meta)\n    _crdt.indexers.set(name, idx)\n  }\n  return _crdt.indexers.get(name)!\n}\n\nexport class Index {\n  blocks: IndexBlockstore\n  crdt: CRDT\n  name: string | null = null\n  mapFn: MapFn | null = null\n  mapFnString: string = ''\n  byKey = new IndexTree()\n  byId = new IndexTree()\n  indexHead: ClockHead | undefined = undefined\n  includeDocsDefault: boolean = false\n  initError: Error | null = null\n  ready: Promise<void>\n\n  constructor(crdt: CRDT, name: string, mapFn?: MapFn, meta?: IdxMeta) {\n    this.blocks = crdt.indexBlocks\n    this.crdt = crdt\n    this.applyMapFn(name, mapFn, meta)\n    if (!(this.mapFnString || this.initError)) throw new Error('missing mapFnString')\n    this.ready = this.blocks.ready.then(() => { })\n    // .then((header: IdxCarHeader) => {\n    //     // @ts-ignore\n    //     if (header.head) throw new Error('cannot have head in idx header')\n    //     if (header.indexes === undefined) throw new Error('missing indexes in idx header')\n    //     // for (const [name, idx] of Object.entries(header.indexes)) {\n    //     //   index({ _crdt: crdt }, name, undefined, idx as IdxMeta)\n    //     // }\n    //   })\n  }\n\n  applyMapFn(name: string, mapFn?: MapFn, meta?: IdxMeta) {\n    if (mapFn && meta) throw new Error('cannot provide both mapFn and meta')\n    if (this.name && this.name !== name) throw new Error('cannot change name')\n    this.name = name\n    try {\n      if (meta) {\n        // hydrating from header\n        if (this.indexHead &&\n          this.indexHead.map(c => c.toString()).join() !== meta.head.map(c => c.toString()).join()) {\n          throw new Error('cannot apply meta to existing index')\n        }\n\n        if (this.mapFnString) {\n          // we already initialized from application code\n          if (this.mapFnString !== meta.map) {\n            console.log('cannot apply different mapFn meta: old mapFnString', this.mapFnString, 'new mapFnString', meta.map)\n            // throw new Error('cannot apply different mapFn meta')\n          } else {\n            this.byId.cid = meta.byId\n            this.byKey.cid = meta.byKey\n            this.indexHead = meta.head\n          }\n        } else {\n          // we are first\n          this.mapFnString = meta.map\n          this.byId.cid = meta.byId\n          this.byKey.cid = meta.byKey\n          this.indexHead = meta.head\n        }\n      } else {\n        if (this.mapFn) {\n          // we already initialized from application code\n          if (mapFn) {\n            if (this.mapFn.toString() !== mapFn.toString()) throw new Error('cannot apply different mapFn app2')\n          }\n        } else {\n          // application code is creating an index\n          if (!mapFn) {\n            mapFn = makeMapFnFromName(name)\n          }\n          if (this.mapFnString) {\n            // we already loaded from a header\n            if (this.mapFnString !== mapFn.toString()) throw new Error('cannot apply different mapFn app')\n          } else {\n            // we are first\n            this.mapFnString = mapFn.toString()\n          }\n          this.mapFn = mapFn\n        }\n      }\n      const matches = /=>\\s*(.*)/.test(this.mapFnString)\n      this.includeDocsDefault = matches\n    } catch (e) {\n      this.initError = e as Error\n    }\n  }\n\n  async query(opts: QueryOpts = {}) {\n    // this._resetIndex()\n    await this._updateIndex()\n    await this._hydrateIndex()\n    if (!this.byKey.root) return await applyQuery(this.crdt, { result: [] }, opts)\n    if (this.includeDocsDefault && opts.includeDocs === undefined) opts.includeDocs = true\n    if (opts.range) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n      const { result, ...all } = await this.byKey.root.range(...encodeRange(opts.range))\n      return await applyQuery(this.crdt, { result, ...all }, opts)\n    }\n    if (opts.key) {\n      const encodedKey = encodeKey(opts.key)\n      return await applyQuery(this.crdt, await this.byKey.root.get(encodedKey), opts)\n    }\n    if (Array.isArray(opts.keys)) {\n      const results = await Promise.all(opts.keys.map(async (key: DocFragment) => {\n        const encodedKey = encodeKey(key)\n        return (await applyQuery(this.crdt, await this.byKey.root!.get(encodedKey), opts)).rows\n      }))\n      return { rows: results.flat() }\n    }\n    if (opts.prefix) {\n      if (!Array.isArray(opts.prefix)) opts.prefix = [opts.prefix]\n      const start = [...opts.prefix, NaN]\n      const end = [...opts.prefix, Infinity]\n      const encodedR = encodeRange([start, end])\n      return await applyQuery(this.crdt, await this.byKey.root.range(...encodedR), opts)\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\n    const { result, ...all } = await this.byKey.root.getAllEntries() // funky return type\n    return await applyQuery(this.crdt, {\n      result: result.map(({ key: [k, id], value }) =>\n        ({ key: k, id, value })),\n      ...all\n    }, opts)\n  }\n\n  _resetIndex() {\n    this.byId = new IndexTree()\n    this.byKey = new IndexTree()\n    this.indexHead = undefined\n  }\n\n  async _hydrateIndex() {\n    if (this.byId.root && this.byKey.root) return\n    if (!this.byId.cid || !this.byKey.cid) return\n    this.byId.root = await loadIndex(this.blocks, this.byId.cid, byIdOpts)\n    this.byKey.root = await loadIndex(this.blocks, this.byKey.cid, byKeyOpts)\n  }\n\n  async _updateIndex() {\n    await this.ready\n    if (this.initError) throw this.initError\n    if (!this.mapFn) throw new Error('No map function defined')\n    let result: DocUpdate[], head: ClockHead\n    if (!this.indexHead || this.indexHead.length === 0) {\n      ; ({ result, head } = await this.crdt.allDocs())\n    } else {\n      ; ({ result, head } = await this.crdt.changes(this.indexHead))\n    }\n    if (result.length === 0) {\n      this.indexHead = head\n      return { byId: this.byId, byKey: this.byKey }\n    }\n    let staleKeyIndexEntries: IndexUpdate[] = []\n    let removeIdIndexEntries: IndexUpdate[] = []\n    if (this.byId.root) {\n      const removeIds = result.map(({ key }) => key)\n      const { result: oldChangeEntries } = await this.byId.root.getMany(removeIds) as { result: Array<[string, string] | string> }\n      staleKeyIndexEntries = oldChangeEntries.map(key => ({ key, del: true }))\n      removeIdIndexEntries = oldChangeEntries.map((key) => ({ key: key[1], del: true }))\n    }\n    const indexEntries = indexEntriesForChanges(result, this.mapFn) // use a getter to translate from string\n    const byIdIndexEntries: DocUpdate[] = indexEntries.map(({ key }) => ({ key: key[1], value: key }))\n    const indexerMeta: Map<string, IdxMeta> = new Map()\n\n    for (const [name, indexer] of this.crdt.indexers) {\n      if (indexer.indexHead) {\n        indexerMeta.set(name, {\n          byId: indexer.byId.cid,\n          byKey: indexer.byKey.cid,\n          head: indexer.indexHead,\n          map: indexer.mapFnString,\n          name: indexer.name\n        } as IdxMeta)\n      }\n    }\n    return await this.blocks.transaction(async (tblocks): Promise<IdxMeta> => {\n      this.byId = await bulkIndex(\n        tblocks,\n        this.byId,\n        removeIdIndexEntries.concat(byIdIndexEntries),\n        byIdOpts\n      )\n      this.byKey = await bulkIndex(tblocks, this.byKey, staleKeyIndexEntries.concat(indexEntries), byKeyOpts)\n      this.indexHead = head\n      return { byId: this.byId.cid, byKey: this.byKey.cid, head, map: this.mapFnString, name: this.name } as IdxMeta\n    }, indexerMeta)\n  }\n}\n\nfunction makeMapFnFromName(name: string): MapFn {\n  return (doc) => {\n    if (doc[name]) return doc[name]\n  }\n}\n", "// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from \"./link/interface.js\"\nimport { CID, format, toJSON, fromJSON } from './cid.js'\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nconst DAG_PB_CODE = 0x70\n// eslint-disable-next-line\nconst SHA_256_CODE = 0x12\n\n/**\n * Simplified version of `create` for CIDv0.\n *\n * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.\n * @returns {API.LegacyLink}\n */\nexport const createLegacy = digest => CID.create(0, DAG_PB_CODE, digest)\n\n/**\n * Simplified version of `create` for CIDv1.\n *\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @param {Code} code - Content encoding format code.\n * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.\n * @returns {API.Link<Data, Code, Alg>}\n */\nexport const create = (code, digest) => CID.create(1, code, digest)\n\n/**\n * Type predicate returns true if value is the link.\n *\n * @template {API.Link<unknown, number, number, 0|1>} L\n * @param {unknown|L} value\n * @returns {value is L & CID}\n */\nexport const isLink = value => {\n  if (value == null) {\n    return false\n  }\n\n  const withSlash = /** @type {{'/'?: Uint8Array, bytes: Uint8Array}} */ (value)\n\n  if (withSlash['/'] != null && withSlash['/'] === withSlash.bytes) {\n    return true\n  }\n\n  const withAsCID = /** @type {{'asCID'?: unknown}} */ (value)\n\n  if (withAsCID.asCID === value) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Takes cid in a string representation and creates an instance. If `base`\n * decoder is not provided will use a default from the configuration. It will\n * throw an error if encoding of the CID is not compatible with supplied (or\n * a default decoder).\n *\n * @template {string} Prefix\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source\n * @param {API.MultibaseDecoder<Prefix>} [base]\n * @returns {API.Link<Data, Code, Alg, Ver>}\n */\nexport const parse = (source, base) => CID.parse(source, base)\n\nexport { format, toJSON, fromJSON }\n\n/**\n * Decoded a CID from its binary representation. The byte array must contain\n * only the CID with no additional bytes.\n *\n * An error will be thrown if the bytes provided do not contain a valid\n * binary representation of a CID.\n *\n * @template {unknown} Data\n * @template {number} Code\n * @template {number} Alg\n * @template {API.Version} Ver\n * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes\n * @returns {API.Link<Data, Code, Alg, Ver>}\n */\nexport const decode = bytes => CID.decode(bytes)\n", "import * as Digest from './digest.js'\n\n/**\n * @template {string} Name\n * @template {number} Code\n * @param {object} options\n * @param {Name} options.name\n * @param {Code} options.code\n * @param {(input: Uint8Array) => Await<Uint8Array>} options.encode\n */\nexport const from = ({ name, code, encode }) => new Hasher(name, code, encode)\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n *\n * @template {string} Name\n * @template {number} Code\n * @class\n * @implements {MultihashHasher<Code>}\n */\nexport class Hasher {\n  /**\n   *\n   * @param {Name} name\n   * @param {Code} code\n   * @param {(input: Uint8Array) => Await<Uint8Array>} encode\n   */\n  constructor (name, code, encode) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n  }\n\n  /**\n   * @param {Uint8Array} input\n   * @returns {Await<Digest.Digest<Code, number>>}\n   */\n  digest (input) {\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n      return result instanceof Uint8Array\n        ? Digest.create(this.code, result)\n        /* c8 ignore next 1 */\n        : result.then(digest => Digest.create(this.code, digest))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n\n/**\n * @template {number} Alg\n * @typedef {import('./interface.js').MultihashHasher} MultihashHasher\n */\n\n/**\n * @template T\n * @typedef {Promise<T>|T} Await\n */\n", "import { bytes as binary, CID } from './index.js'\n// Linter can see that API is used in types.\n// eslint-disable-next-line\nimport * as API from './interface.js'\n\nfunction readonly ({ enumerable = true, configurable = false } = {}) {\n  return { enumerable, configurable, writable: false }\n}\n\n/**\n * @param {[string|number, string]} path\n * @param {any} value\n * @returns {Iterable<[string, CID]>}\n */\nfunction * linksWithin (path, value) {\n  if (value != null && typeof value === 'object') {\n    if (Array.isArray(value)) {\n      for (const [index, element] of value.entries()) {\n        const elementPath = [...path, index]\n        const cid = CID.asCID(element)\n        if (cid) {\n          yield [elementPath.join('/'), cid]\n        } else if (typeof element === 'object') {\n          yield * links(element, elementPath)\n        }\n      }\n    } else {\n      const cid = CID.asCID(value)\n      if (cid) {\n        yield [path.join('/'), cid]\n      } else {\n        yield * links(value, path)\n      }\n    }\n  }\n}\n\n/**\n * @template T\n * @param {T} source\n * @param {Array<string|number>} base\n * @returns {Iterable<[string, CID]>}\n */\nfunction * links (source, base) {\n  if (source == null || source instanceof Uint8Array) {\n    return\n  }\n  const cid = CID.asCID(source)\n  if (cid) {\n    yield [base.join('/'), cid]\n  }\n  for (const [key, value] of Object.entries(source)) {\n    const path = /** @type {[string|number, string]} */ ([...base, key])\n    yield * linksWithin(path, value)\n  }\n}\n\n/**\n * @param {[string|number, string]} path\n * @param {any} value\n * @returns {Iterable<string>}\n */\nfunction * treeWithin (path, value) {\n  if (Array.isArray(value)) {\n    for (const [index, element] of value.entries()) {\n      const elementPath = [...path, index]\n      yield elementPath.join('/')\n      if (typeof element === 'object' && !CID.asCID(element)) {\n        yield * tree(element, elementPath)\n      }\n    }\n  } else {\n    yield * tree(value, path)\n  }\n}\n\n/**\n * @template T\n * @param {T} source\n * @param {Array<string|number>} base\n * @returns {Iterable<string>}\n */\nfunction * tree (source, base) {\n  if (source == null || typeof source !== 'object') {\n    return\n  }\n  for (const [key, value] of Object.entries(source)) {\n    const path = /** @type {[string|number, string]} */ ([...base, key])\n    yield path.join('/')\n    if (value != null && !(value instanceof Uint8Array) && typeof value === 'object' && !CID.asCID(value)) {\n      yield * treeWithin(path, value)\n    }\n  }\n}\n\n/**\n *\n * @template T\n * @param {T} source\n * @param {string[]} path\n * @returns {API.BlockCursorView<unknown>}\n */\nfunction get (source, path) {\n  let node = /** @type {Record<string, any>} */(source)\n  for (const [index, key] of path.entries()) {\n    node = node[key]\n    if (node == null) {\n      throw new Error(`Object has no property at ${path.slice(0, index + 1).map(part => `[${JSON.stringify(part)}]`).join('')}`)\n    }\n    const cid = CID.asCID(node)\n    if (cid) {\n      return { value: cid, remaining: path.slice(index + 1).join('/') }\n    }\n  }\n  return { value: node }\n}\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} C - multicodec code corresponding to codec used to encode the block\n * @template {number} A - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template {API.Version} V - CID version\n * @implements {API.BlockView<T, C, A, V>}\n */\nclass Block {\n  /**\n   * @param {object} options\n   * @param {CID<T, C, A, V>} options.cid\n   * @param {API.ByteView<T>} options.bytes\n   * @param {T} options.value\n   */\n  constructor ({ cid, bytes, value }) {\n    if (!cid || !bytes || typeof value === 'undefined') { throw new Error('Missing required argument') }\n\n    this.cid = cid\n    this.bytes = bytes\n    this.value = value\n    this.asBlock = this\n\n    // Mark all the properties immutable\n    Object.defineProperties(this, {\n      cid: readonly(),\n      bytes: readonly(),\n      value: readonly(),\n      asBlock: readonly()\n    })\n  }\n\n  links () {\n    return links(this.value, [])\n  }\n\n  tree () {\n    return tree(this.value, [])\n  }\n\n  /**\n   *\n   * @param {string} [path]\n   * @returns {API.BlockCursorView<unknown>}\n   */\n  get (path = '/') {\n    return get(this.value, path.split('/').filter(Boolean))\n  }\n}\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @param {object} options\n * @param {T} options.value\n * @param {API.BlockEncoder<Code, T>} options.codec\n * @param {API.MultihashHasher<Alg>} options.hasher\n * @returns {Promise<API.BlockView<T, Code, Alg>>}\n */\nasync function encode ({ value, codec, hasher }) {\n  if (typeof value === 'undefined') throw new Error('Missing required argument \"value\"')\n  if (!codec || !hasher) throw new Error('Missing required argument: codec or hasher')\n\n  const bytes = codec.encode(value)\n  const hash = await hasher.digest(bytes)\n  /** @type {CID<T, Code, Alg, 1>} */\n  const cid = CID.create(\n    1,\n    codec.code,\n    hash\n  )\n\n  return new Block({ value, bytes, cid })\n}\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @param {object} options\n * @param {API.ByteView<T>} options.bytes\n * @param {API.BlockDecoder<Code, T>} options.codec\n * @param {API.MultihashHasher<Alg>} options.hasher\n * @returns {Promise<API.BlockView<T, Code, Alg>>}\n */\nasync function decode ({ bytes, codec, hasher }) {\n  if (!bytes) throw new Error('Missing required argument \"bytes\"')\n  if (!codec || !hasher) throw new Error('Missing required argument: codec or hasher')\n\n  const value = codec.decode(bytes)\n  const hash = await hasher.digest(bytes)\n  /** @type {CID<T, Code, Alg, 1>} */\n  const cid = CID.create(1, codec.code, hash)\n\n  return new Block({ value, bytes, cid })\n}\n\n/**\n * @typedef {object} RequiredCreateOptions\n * @property {CID} options.cid\n */\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template {API.Version} V - CID version\n * @param {{ cid: API.Link<T, Code, Alg, V>, value:T, codec?: API.BlockDecoder<Code, T>, bytes: API.ByteView<T> }|{cid:API.Link<T, Code, Alg, V>, bytes:API.ByteView<T>, value?:void, codec:API.BlockDecoder<Code, T>}} options\n * @returns {API.BlockView<T, Code, Alg, V>}\n */\nfunction createUnsafe ({ bytes, cid, value: maybeValue, codec }) {\n  const value = maybeValue !== undefined\n    ? maybeValue\n    : (codec && codec.decode(bytes))\n\n  if (value === undefined) throw new Error('Missing required argument, must either provide \"value\" or \"codec\"')\n\n  return new Block({\n    // eslint-disable-next-line object-shorthand\n    cid: /** @type {CID<T, Code, Alg, V>} */ (cid),\n    bytes,\n    value\n  })\n}\n\n/**\n * @template {unknown} T - Logical type of the data encoded in the block\n * @template {number} Code - multicodec code corresponding to codec used to encode the block\n * @template {number} Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template {API.Version} V - CID version\n * @param {object} options\n * @param {API.Link<T, Code, Alg, V>} options.cid\n * @param {API.ByteView<T>} options.bytes\n * @param {API.BlockDecoder<Code, T>} options.codec\n * @param {API.MultihashHasher<Alg>} options.hasher\n * @returns {Promise<API.BlockView<T, Code, Alg, V>>}\n */\nasync function create ({ bytes, cid, hasher, codec }) {\n  if (!bytes) throw new Error('Missing required argument \"bytes\"')\n  if (!hasher) throw new Error('Missing required argument \"hasher\"')\n  const value = codec.decode(bytes)\n  const hash = await hasher.digest(bytes)\n  if (!binary.equals(cid.multihash.bytes, hash.bytes)) {\n    throw new Error('CID hash does not match bytes')\n  }\n\n  return createUnsafe({\n    bytes,\n    cid,\n    value,\n    codec\n  })\n}\n\nexport { encode, decode, create, createUnsafe, Block }\n", "/* global crypto */\n\nimport { from } from './hasher.js'\n\n/**\n * @param {AlgorithmIdentifier} name\n */\nconst sha = name =>\n  /**\n   * @param {Uint8Array} data\n   */\n  async data => new Uint8Array(await crypto.subtle.digest(name, data))\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n", "import { Block, encode, decode } from 'multiformats/block'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport * as cbor from '@ipld/dag-cbor'\n\n/**\n * @template T\n * @typedef {{ parents: EventLink<T>[], data: T }} EventView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats').BlockView<EventView<T>>} EventBlockView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats').Link<EventView<T>>} EventLink\n */\n\n/**\n * Advance the clock by adding an event.\n *\n * @template T\n * @param {import('./block').BlockFetcher} blocks Block storage.\n * @param {EventLink<T>[]} head The head of the clock.\n * @param {EventLink<T>} event The event to add.\n */\nexport async function advance (blocks, head, event) {\n  const events = new EventFetcher(blocks)\n  const headmap = new Map(head.map(cid => [cid.toString(), cid]))\n  if (headmap.has(event.toString())) return head\n\n  // does event contain the clock?\n  let changed = false\n  for (const cid of head) {\n    if (await contains(events, event, cid)) {\n      headmap.delete(cid.toString())\n      headmap.set(event.toString(), event)\n      changed = true\n    }\n  }\n  if (changed) {\n    return [...headmap.values()]\n  }\n\n  // does clock contain the event?\n  for (const p of head) {\n    if (await contains(events, p, event)) {\n      return head\n    }\n  }\n\n  return head.concat(event)\n}\n\n/**\n * @template T\n * @extends {Block<EventView<T>, typeof cbor.code, typeof sha256.code, 1>}\n * @implements {EventBlockView<T>}\n */\nexport class EventBlock extends Block {\n  /**\n   * @param {object} config\n   * @param {EventLink<T>} config.cid\n   * @param {Event} config.value\n   * @param {Uint8Array} config.bytes\n   * @param {string} config.prefix\n   */\n  constructor ({ cid, value, bytes, prefix }) {\n    // @ts-expect-error\n    super({ cid, value, bytes })\n    this.prefix = prefix\n  }\n\n  /**\n   * @template T\n   * @param {T} data\n   * @param {EventLink<T>[]} [parents]\n   */\n  static create (data, parents) {\n    return encodeEventBlock({ data, parents: parents ?? [] })\n  }\n}\n\n/** @template T */\nexport class EventFetcher {\n  /** @param {import('./block').BlockFetcher} blocks */\n  constructor (blocks) {\n    /** @private */\n    this._blocks = blocks\n  }\n\n  /**\n   * @param {EventLink<T>} link\n   * @returns {Promise<EventBlockView<T>>}\n   */\n  async get (link) {\n    const block = await this._blocks.get(link)\n    if (!block) throw new Error(`missing block: ${link}`)\n    return decodeEventBlock(block.bytes)\n  }\n}\n\n/**\n * @template T\n * @param {EventView<T>} value\n * @returns {Promise<EventBlockView<T>>}\n */\nexport async function encodeEventBlock (value) {\n  // TODO: sort parents\n  const { cid, bytes } = await encode({ value, codec: cbor, hasher: sha256 })\n  // @ts-expect-error\n  return new Block({ cid, value, bytes })\n}\n\n/**\n * @template T\n * @param {Uint8Array} bytes\n * @returns {Promise<EventBlockView<T>>}\n */\nexport async function decodeEventBlock (bytes) {\n  const { cid, value } = await decode({ bytes, codec: cbor, hasher: sha256 })\n  // @ts-expect-error\n  return new Block({ cid, value, bytes })\n}\n\n/**\n * Returns true if event \"a\" contains event \"b\". Breadth first search.\n * @template T\n * @param {EventFetcher<T>} events\n * @param {EventLink<T>} a\n * @param {EventLink<T>} b\n */\nasync function contains (events, a, b) {\n  if (a.toString() === b.toString()) return true\n  const [{ value: aevent }, { value: bevent }] = await Promise.all([events.get(a), events.get(b)])\n  const links = [...aevent.parents]\n  const seen = new Set()\n  while (links.length) {\n    const link = links.shift()\n    if (!link) break\n    if (link.toString() === b.toString()) return true\n    // if any of b's parents are this link, then b cannot exist in any of the\n    // tree below, since that would create a cycle.\n    if (bevent.parents.some(p => link.toString() === p.toString())) continue\n    if (seen.has(link.toString())) continue\n    seen.add(link.toString())\n    const { value: event } = await events.get(link)\n    links.push(...event.parents)\n  }\n  return false\n}\n\n/**\n * @template T\n * @param {import('./block').BlockFetcher} blocks Block storage.\n * @param {EventLink<T>[]} head\n * @param {object} [options]\n * @param {(b: EventBlockView<T>) => string} [options.renderNodeLabel]\n */\nexport async function * vis (blocks, head, options = {}) {\n  const renderNodeLabel = options.renderNodeLabel ?? (b => shortLink(b.cid))\n  const events = new EventFetcher(blocks)\n  yield 'digraph clock {'\n  yield '  node [shape=point fontname=\"Courier\"]; head;'\n  const hevents = await Promise.all(head.map(link => events.get(link)))\n  /** @type {import('multiformats').Link<EventView<any>>[]} */\n  const links = []\n  const nodes = new Set()\n  for (const e of hevents) {\n    nodes.add(e.cid.toString())\n    yield `  node [shape=oval fontname=\"Courier\"]; ${e.cid} [label=\"${renderNodeLabel(e)}\"];`\n    yield `  head -> ${e.cid};`\n    for (const p of e.value.parents) {\n      yield `  ${e.cid} -> ${p};`\n    }\n    links.push(...e.value.parents)\n  }\n  while (links.length) {\n    const link = links.shift()\n    if (!link) break\n    if (nodes.has(link.toString())) continue\n    nodes.add(link.toString())\n    const block = await events.get(link)\n    yield `  node [shape=oval]; ${link} [label=\"${renderNodeLabel(block)}\" fontname=\"Courier\"];`\n    for (const p of block.value.parents) {\n      yield `  ${link} -> ${p};`\n    }\n    links.push(...block.value.parents)\n  }\n  yield '}'\n}\n\n/** @param {import('./link').AnyLink} l */\nconst shortLink = l => `${String(l).slice(0, 4)}..${String(l).slice(-4)}`\n", "import { Block, encode, decode } from 'multiformats/block'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport * as cbor from '@ipld/dag-cbor'\n\n/**\n * @typedef {import('./link').AnyLink} ShardEntryValueValue\n * @typedef {[ShardLink]} ShardEntryLinkValue\n * @typedef {[ShardLink, import('./link').AnyLink]} ShardEntryLinkAndValueValue\n * @typedef {[key: string, value: ShardEntryValueValue]} ShardValueEntry\n * @typedef {[key: string, value: ShardEntryLinkValue | ShardEntryLinkAndValueValue]} ShardLinkEntry\n * @typedef {[key: string, value: ShardEntryValueValue | ShardEntryLinkValue | ShardEntryLinkAndValueValue]} ShardEntry\n * @typedef {ShardEntry[]} Shard\n * @typedef {import('multiformats').Link<Shard, typeof cbor.code, typeof sha256.code, 1>} ShardLink\n * @typedef {import('multiformats').BlockView<Shard, typeof cbor.code, typeof sha256.code, 1> & { prefix: string }} ShardBlockView\n */\n\n/**\n * @extends {Block<Shard, typeof cbor.code, typeof sha256.code, 1>}\n * @implements {ShardBlockView}\n */\nexport class ShardBlock extends Block {\n  /**\n   * @param {object} config\n   * @param {ShardLink} config.cid\n   * @param {Shard} config.value\n   * @param {Uint8Array} config.bytes\n   * @param {string} config.prefix\n   */\n  constructor ({ cid, value, bytes, prefix }) {\n    // @ts-expect-error\n    super({ cid, value, bytes })\n    this.prefix = prefix\n  }\n\n  static create () {\n    return encodeShardBlock([])\n  }\n}\n\n/** @type {WeakMap<Uint8Array, ShardBlockView>} */\nconst decodeCache = new WeakMap()\n\n/**\n * @param {Shard} value\n * @param {string} [prefix]\n * @returns {Promise<ShardBlockView>}\n */\nexport async function encodeShardBlock (value, prefix) {\n  const { cid, bytes } = await encode({ value, codec: cbor, hasher: sha256 })\n  const block = new ShardBlock({ cid, value, bytes, prefix: prefix ?? '' })\n  decodeCache.set(block.bytes, block)\n  return block\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {string} [prefix]\n * @returns {Promise<ShardBlockView>}\n */\nexport async function decodeShardBlock (bytes, prefix) {\n  const block = decodeCache.get(bytes)\n  if (block) return block\n  const { cid, value } = await decode({ bytes, codec: cbor, hasher: sha256 })\n  if (!Array.isArray(value)) throw new Error(`invalid shard: ${cid}`)\n  return new ShardBlock({ cid, value, bytes, prefix: prefix ?? '' })\n}\n\nexport class ShardFetcher {\n  /** @param {import('./block').BlockFetcher} blocks */\n  constructor (blocks) {\n    this._blocks = blocks\n  }\n\n  /**\n   * @param {ShardLink} link\n   * @param {string} [prefix]\n   * @returns {Promise<ShardBlockView>}\n   */\n  async get (link, prefix = '') {\n    const block = await this._blocks.get(link)\n    if (!block) throw new Error(`missing block: ${link}`)\n    return decodeShardBlock(block.bytes, prefix)\n  }\n}\n\n/**\n * @param {Shard} target Shard to put to.\n * @param {ShardEntry} entry\n * @returns {Shard}\n */\nexport function putEntry (target, entry) {\n  if (!target.length) return [entry]\n\n  /** @type {Shard} */\n  const shard = []\n  for (const [i, [k, v]] of target.entries()) {\n    if (entry[0] === k) {\n      // if new value is link to shard...\n      if (Array.isArray(entry[1])) {\n        // and old value is link to shard\n        // and old value is _also_ link to data\n        // and new value does not have link to data\n        // then preserve old data\n        if (Array.isArray(v) && v[1] != null && entry[1][1] == null) {\n          shard.push([k, [entry[1][0], v[1]]])\n        } else {\n          shard.push(entry)\n        }\n      } else {\n        // shard as well as value?\n        /** @type {ShardEntry} */\n        const newEntry = Array.isArray(v) ? [k, [v[0], entry[1]]] : entry\n        shard.push(newEntry)\n      }\n      for (let j = i + 1; j < target.length; j++) {\n        shard.push(target[j])\n      }\n      return shard\n    }\n    if (i === 0 && entry[0] < k) {\n      shard.push(entry)\n      for (let j = i; j < target.length; j++) {\n        shard.push(target[j])\n      }\n      return shard\n    }\n    if (i > 0 && entry[0] > target[i - 1][0] && entry[0] < k) {\n      shard.push(entry)\n      for (let j = i; j < target.length; j++) {\n        shard.push(target[j])\n      }\n      return shard\n    }\n    shard.push([k, v])\n  }\n\n  shard.push(entry)\n  return shard\n}\n\n/**\n * @param {import('./shard').Shard} shard\n * @param {string} skey Shard key to use as a base.\n */\nexport function findCommonPrefix (shard, skey) {\n  const startidx = shard.findIndex(([k]) => skey === k)\n  if (startidx === -1) throw new Error(`key not found in shard: ${skey}`)\n  let i = startidx\n  /** @type {string} */\n  let pfx\n  while (true) {\n    pfx = shard[i][0].slice(0, -1)\n    if (pfx.length) {\n      while (true) {\n        const matches = shard.filter(entry => entry[0].startsWith(pfx))\n        if (matches.length > 1) return { prefix: pfx, matches }\n        pfx = pfx.slice(0, -1)\n        if (!pfx.length) break\n      }\n    }\n    i++\n    if (i >= shard.length) {\n      i = 0\n    }\n    if (i === startidx) {\n      return\n    }\n  }\n}\n", "import {\n  ShardFetcher,\n  ShardBlock,\n  encodeShardBlock,\n  decodeShardBlock,\n  putEntry,\n  findCommonPrefix\n} from './shard.js'\n\nexport { ShardBlock, encodeShardBlock, decodeShardBlock }\n\n/**\n * @typedef {{ additions: import('./shard').ShardBlockView[], removals: import('./shard').ShardBlockView[] }} ShardDiff\n */\n\nexport const MaxKeyLength = 64\nexport const MaxShardSize = 512 * 1024\n\n/**\n * Put a value (a CID) for the given key. If the key exists it's value is\n * overwritten.\n *\n * @param {import('./block').BlockFetcher} blocks Bucket block storage.\n * @param {import('./shard').ShardLink} root CID of the root node of the bucket.\n * @param {string} key The key of the value to put.\n * @param {import('./link').AnyLink} value The value to put.\n * @param {object} [options]\n * @param {number} [options.maxShardSize] Maximum shard size in bytes.\n * @returns {Promise<{ root: import('./shard').ShardLink } & ShardDiff>}\n */\nexport async function put (blocks, root, key, value, options = {}) {\n  const shards = new ShardFetcher(blocks)\n  const rshard = await shards.get(root)\n  const path = await traverse(shards, rshard, key)\n  const target = path[path.length - 1]\n  const skey = key.slice(target.prefix.length) // key within the shard\n\n  /** @type {import('./shard').ShardEntry} */\n  let entry = [skey, value]\n\n  /** @type {import('./shard').ShardBlockView[]} */\n  const additions = []\n\n  // if the key in this shard is longer than allowed, then we need to make some\n  // intermediate shards.\n  if (skey.length > MaxKeyLength) {\n    const pfxskeys = Array.from(Array(Math.ceil(skey.length / MaxKeyLength)), (_, i) => {\n      const start = i * MaxKeyLength\n      return {\n        prefix: target.prefix + skey.slice(0, start),\n        skey: skey.slice(start, start + MaxKeyLength)\n      }\n    })\n\n    let child = await encodeShardBlock([[pfxskeys[pfxskeys.length - 1].skey, value]], pfxskeys[pfxskeys.length - 1].prefix)\n    additions.push(child)\n\n    for (let i = pfxskeys.length - 2; i > 0; i--) {\n      child = await encodeShardBlock([[pfxskeys[i].skey, [child.cid]]], pfxskeys[i].prefix)\n      additions.push(child)\n    }\n\n    entry = [pfxskeys[0].skey, [child.cid]]\n  }\n\n  /** @type {import('./shard').Shard} */\n  let shard = putEntry(target.value, entry)\n  let child = await encodeShardBlock(shard, target.prefix)\n\n  if (child.bytes.length > (options.maxShardSize ?? MaxShardSize)) {\n    const common = findCommonPrefix(shard, entry[0])\n    if (!common) throw new Error('shard limit reached')\n    const { prefix, matches } = common\n    const block = await encodeShardBlock(\n      matches.filter(([k]) => k !== prefix).map(([k, v]) => [k.slice(prefix.length), v]),\n      target.prefix + prefix\n    )\n    additions.push(block)\n\n    /** @type {import('./shard').ShardEntryLinkValue | import('./shard').ShardEntryLinkAndValueValue} */\n    let value\n    const pfxmatch = matches.find(([k]) => k === prefix)\n    if (pfxmatch) {\n      if (Array.isArray(pfxmatch[1])) {\n        // should not happen! all entries with this prefix should have been\n        // placed within this shard already.\n        throw new Error(`expected \"${prefix}\" to be a shard value but found a shard link`)\n      }\n      value = [block.cid, pfxmatch[1]]\n    } else {\n      value = [block.cid]\n    }\n\n    shard = shard.filter(e => matches.every(m => e[0] !== m[0]))\n    shard = putEntry(shard, [prefix, value])\n    child = await encodeShardBlock(shard, target.prefix)\n  }\n\n  additions.push(child)\n\n  // path is root -> shard, so work backwards, propagating the new shard CID\n  for (let i = path.length - 2; i >= 0; i--) {\n    const parent = path[i]\n    const key = child.prefix.slice(parent.prefix.length)\n    const value = parent.value.map((entry) => {\n      const [k, v] = entry\n      if (k !== key) return entry\n      if (!Array.isArray(v)) throw new Error(`\"${key}\" is not a shard link in: ${parent.cid}`)\n      return /** @type {import('./shard').ShardEntry} */(v[1] == null ? [k, [child.cid]] : [k, [child.cid, v[1]]])\n    })\n\n    child = await encodeShardBlock(value, parent.prefix)\n    additions.push(child)\n  }\n\n  return { root: additions[additions.length - 1].cid, additions, removals: path }\n}\n\n/**\n * Get the stored value for the given key from the bucket. If the key is not\n * found, `undefined` is returned.\n *\n * @param {import('./block').BlockFetcher} blocks Bucket block storage.\n * @param {import('./shard').ShardLink} root CID of the root node of the bucket.\n * @param {string} key The key of the value to get.\n * @returns {Promise<import('./link').AnyLink | undefined>}\n */\nexport async function get (blocks, root, key) {\n  const shards = new ShardFetcher(blocks)\n  const rshard = await shards.get(root)\n  const path = await traverse(shards, rshard, key)\n  const target = path[path.length - 1]\n  const skey = key.slice(target.prefix.length) // key within the shard\n  const entry = target.value.find(([k]) => k === skey)\n  if (!entry) return\n  return Array.isArray(entry[1]) ? entry[1][1] : entry[1]\n}\n\n/**\n * Delete the value for the given key from the bucket. If the key is not found\n * no operation occurs.\n *\n * @param {import('./block').BlockFetcher} blocks Bucket block storage.\n * @param {import('./shard').ShardLink} root CID of the root node of the bucket.\n * @param {string} key The key of the value to delete.\n * @returns {Promise<{ root: import('./shard').ShardLink } & ShardDiff>}\n */\nexport async function del (blocks, root, key) {\n  const shards = new ShardFetcher(blocks)\n  const rshard = await shards.get(root)\n  const path = await traverse(shards, rshard, key)\n  const target = path[path.length - 1]\n  const skey = key.slice(target.prefix.length) // key within the shard\n\n  const entryidx = target.value.findIndex(([k]) => k === skey)\n  if (entryidx === -1) return { root, additions: [], removals: [] }\n\n  const entry = target.value[entryidx]\n  // cannot delete a shard (without data)\n  if (Array.isArray(entry[1]) && entry[1][1] == null) return { root, additions: [], removals: [] }\n\n  /** @type {import('./shard').ShardBlockView[]} */\n  const additions = []\n  /** @type {import('./shard').ShardBlockView[]} */\n  const removals = [...path]\n\n  let shard = [...target.value]\n\n  if (Array.isArray(entry[1])) {\n    // remove the value from this link+value\n    shard[entryidx] = [entry[0], [entry[1][0]]]\n  } else {\n    shard.splice(entryidx, 1)\n    // if now empty, remove from parent\n    while (!shard.length) {\n      const child = path[path.length - 1]\n      const parent = path[path.length - 2]\n      if (!parent) break\n      path.pop()\n      shard = parent.value.filter(e => {\n        if (!Array.isArray(e[1])) return true\n        return e[1][0].toString() !== child.cid.toString()\n      })\n    }\n  }\n\n  let child = await encodeShardBlock(shard, path[path.length - 1].prefix)\n  additions.push(child)\n\n  // path is root -> shard, so work backwards, propagating the new shard CID\n  for (let i = path.length - 2; i >= 0; i--) {\n    const parent = path[i]\n    const key = child.prefix.slice(parent.prefix.length)\n    const value = parent.value.map((entry) => {\n      const [k, v] = entry\n      if (k !== key) return entry\n      if (!Array.isArray(v)) throw new Error(`\"${key}\" is not a shard link in: ${parent.cid}`)\n      return /** @type {import('./shard').ShardEntry} */(v[1] == null ? [k, [child.cid]] : [k, [child.cid, v[1]]])\n    })\n\n    child = await encodeShardBlock(value, parent.prefix)\n    additions.push(child)\n  }\n\n  return { root: additions[additions.length - 1].cid, additions, removals }\n}\n\n/**\n * List entries in the bucket.\n *\n * @param {import('./block').BlockFetcher} blocks Bucket block storage.\n * @param {import('./shard').ShardLink} root CID of the root node of the bucket.\n * @param {object} [options]\n * @param {string} [options.prefix]\n * @returns {AsyncIterableIterator<import('./shard').ShardValueEntry>}\n */\nexport async function * entries (blocks, root, options = {}) {\n  const { prefix } = options\n  const shards = new ShardFetcher(blocks)\n  const rshard = await shards.get(root)\n\n  yield * (\n    /** @returns {AsyncIterableIterator<import('./shard').ShardValueEntry>} */\n    async function * ents (shard) {\n      for (const entry of shard.value) {\n        const key = shard.prefix + entry[0]\n\n        if (Array.isArray(entry[1])) {\n          if (entry[1][1]) {\n            if (!prefix || (prefix && key.startsWith(prefix))) {\n              yield [key, entry[1][1]]\n            }\n          }\n\n          if (prefix) {\n            if (prefix.length <= key.length && !key.startsWith(prefix)) {\n              continue\n            }\n            if (prefix.length > key.length && !prefix.startsWith(key)) {\n              continue\n            }\n          }\n          yield * ents(await shards.get(entry[1][0], key))\n        } else {\n          if (prefix && !key.startsWith(prefix)) {\n            continue\n          }\n          yield [key, entry[1]]\n        }\n      }\n    }\n  )(rshard)\n}\n\n/**\n * Traverse from the passed shard block to the target shard block using the\n * passed key. All traversed shards are returned, starting with the passed\n * shard and ending with the target.\n *\n * @param {ShardFetcher} shards\n * @param {import('./shard').ShardBlockView} shard\n * @param {string} key\n * @returns {Promise<[import('./shard').ShardBlockView, ...Array<import('./shard').ShardBlockView>]>}\n */\nasync function traverse (shards, shard, key) {\n  for (const [k, v] of shard.value) {\n    if (key === k) return [shard]\n    if (key.startsWith(k) && Array.isArray(v)) {\n      const path = await traverse(shards, await shards.get(v[0], shard.prefix + k), key.slice(k.length))\n      return [shard, ...path]\n    }\n  }\n  return [shard]\n}\n", "import * as Clock from './clock.js'\nimport { EventFetcher, EventBlock } from './clock.js'\nimport * as Pail from './index.js'\nimport { ShardBlock } from './index.js'\nimport { MemoryBlockstore, MultiBlockFetcher } from './block.js'\n\n/**\n * @typedef {{\n *   type: 'put'|'del'\n *   key: string\n *   value: import('./link').AnyLink\n *   root: import('./shard').ShardLink\n * }} EventData\n * @typedef {{\n *   root: import('./shard').ShardLink\n *   head: import('./clock').EventLink<EventData>[]\n *   event: import('./clock').EventBlockView<EventData>\n * } & import('./index').ShardDiff} Result\n */\n\n/**\n * Put a value (a CID) for the given key. If the key exists it's value is\n * overwritten.\n *\n * @param {import('./block').BlockFetcher} blocks Bucket block storage.\n * @param {import('./clock').EventLink<EventData>[]} head Merkle clock head.\n * @param {string} key The key of the value to put.\n * @param {import('./link').AnyLink} value The value to put.\n * @param {object} [options]\n * @returns {Promise<Result>}\n */\nexport async function put (blocks, head, key, value, options) {\n  // console.log('good put', key, value)\n  const mblocks = new MemoryBlockstore()\n  blocks = new MultiBlockFetcher(mblocks, blocks)\n\n  if (!head.length) {\n    const shard = await ShardBlock.create()\n    mblocks.putSync(shard.cid, shard.bytes)\n    const result = await Pail.put(blocks, shard.cid, key, value, options)\n    /** @type {EventData} */\n    const data = { type: 'put', root: result.root, key, value }\n    const event = await EventBlock.create(data, head)\n    head = await Clock.advance(blocks, head, event.cid)\n    return {\n      root: result.root,\n      additions: [shard, ...result.additions],\n      removals: result.removals,\n      head,\n      event\n    }\n  }\n\n  const events = new EventFetcher(blocks)\n  const ancestor = await findCommonAncestor(events, head)\n  if (!ancestor) throw new Error('failed to find common ancestor event')\n\n  const aevent = await events.get(ancestor)\n  let { root } = aevent.value.data\n\n  const sorted = await findSortedEvents(events, head, ancestor)\n  /** @type {Map<string, import('./shard').ShardBlockView>} */\n  const additions = new Map()\n  /** @type {Map<string, import('./shard').ShardBlockView>} */\n  const removals = new Map()\n\n  for (const { value: event } of sorted) {\n    if (!['put', 'del'].includes(event.data.type)) {\n      throw new Error(`unknown event type: ${event.data.type}`)\n    }\n    const result = event.data.type === 'put'\n      ? await Pail.put(blocks, root, event.data.key, event.data.value)\n      : await Pail.del(blocks, root, event.data.key)\n\n    root = result.root\n    for (const a of result.additions) {\n      mblocks.putSync(a.cid, a.bytes)\n      additions.set(a.cid.toString(), a)\n    }\n    for (const r of result.removals) {\n      removals.set(r.cid.toString(), r)\n    }\n  }\n\n  const result = await Pail.put(blocks, root, key, value, options)\n  for (const a of result.additions) {\n    mblocks.putSync(a.cid, a.bytes)\n    additions.set(a.cid.toString(), a)\n  }\n  for (const r of result.removals) {\n    removals.set(r.cid.toString(), r)\n  }\n\n  /** @type {EventData} */\n  const data = { type: 'put', root: result.root, key, value }\n  const event = await EventBlock.create(data, head)\n  mblocks.putSync(event.cid, event.bytes)\n  head = await Clock.advance(blocks, head, event.cid)\n\n  // filter blocks that were added _and_ removed, except for the root\n  const rootCidString = result.root.toString()\n  for (const k of removals.keys()) {\n    if (additions.has(k) && k !== rootCidString) {\n      additions.delete(k)\n      removals.delete(k)\n    }\n  }\n\n  return {\n    root: result.root,\n    additions: [...additions.values()],\n    removals: [...removals.values()],\n    head,\n    event\n  }\n}\n\n/**\n * Delete the value for the given key from the bucket. If the key is not found\n * no operation occurs.\n *\n * @param {import('./block').BlockFetcher} blocks Bucket block storage.\n * @param {import('./clock').EventLink<EventData>[]} head Merkle clock head.\n * @param {string} key The key of the value to delete.\n * @param {object} [options]\n * @returns {Promise<Result>}\n */\nexport async function del (blocks, head, key, options) {\n  throw new Error('not implemented')\n}\n\n/**\n * Determine the effective pail root given the current merkle clock head.\n *\n * Clocks with multiple head events may return blocks that were added or\n * removed while playing forward events from their common ancestor.\n *\n * @param {import('./block').BlockFetcher} blocks Bucket block storage.\n * @param {import('./clock').EventLink<EventData>[]} head Merkle clock head.\n * @returns {Promise<{ root: import('./shard').ShardLink } & import('./index').ShardDiff>}\n */\nexport async function root (blocks, head) {\n  if (!head.length) throw new Error('cannot determine root of headless clock')\n\n  const mblocks = new MemoryBlockstore()\n  blocks = new MultiBlockFetcher(mblocks, blocks)\n\n  /** @type {EventFetcher<EventData>} */\n  const events = new EventFetcher(blocks)\n\n  if (head.length === 1) {\n    const event = await events.get(head[0])\n    const { root } = event.value.data\n    return { root, additions: [], removals: [] }\n  }\n\n  const ancestor = await findCommonAncestor(events, head)\n  if (!ancestor) throw new Error('failed to find common ancestor event')\n\n  const aevent = await events.get(ancestor)\n  let { root } = aevent.value.data\n\n  const sorted = await findSortedEvents(events, head, ancestor)\n  /** @type {Map<string, import('./shard').ShardBlockView>} */\n  const additions = new Map()\n  /** @type {Map<string, import('./shard').ShardBlockView>} */\n  const removals = new Map()\n\n  for (const { value: event } of sorted) {\n    if (!['put', 'del'].includes(event.data.type)) {\n      throw new Error(`unknown event type: ${event.data.type}`)\n    }\n    const result = event.data.type === 'put'\n      ? await Pail.put(blocks, root, event.data.key, event.data.value)\n      : await Pail.del(blocks, root, event.data.key)\n\n    root = result.root\n    for (const a of result.additions) {\n      mblocks.putSync(a.cid, a.bytes)\n      additions.set(a.cid.toString(), a)\n    }\n    for (const r of result.removals) {\n      removals.set(r.cid.toString(), r)\n    }\n  }\n\n  // filter blocks that were added _and_ removed\n  const rootCidString = root.toString()\n  for (const k of removals.keys()) {\n    if (additions.has(k) && k !== rootCidString) {\n      additions.delete(k)\n      removals.delete(k)\n    }\n  }\n\n  return {\n    root,\n    additions: [...additions.values()],\n    removals: [...removals.values()]\n  }\n}\n\n/**\n * @param {import('./block').BlockFetcher} blocks Bucket block storage.\n * @param {import('./clock').EventLink<EventData>[]} head Merkle clock head.\n * @param {string} key The key of the value to retrieve.\n */\nexport async function get (blocks, head, key) {\n  if (!head.length) return\n  const result = await root(blocks, head)\n  if (result.additions.length) {\n    blocks = new MultiBlockFetcher(new MemoryBlockstore(result.additions), blocks)\n  }\n  return Pail.get(blocks, result.root, key)\n}\n\n/**\n * @param {import('./block').BlockFetcher} blocks Bucket block storage.\n * @param {import('./clock').EventLink<EventData>[]} head Merkle clock head.\n * @param {object} [options]\n * @param {string} [options.prefix]\n */\nexport async function * entries (blocks, head, options) {\n  if (!head.length) return\n  const result = await root(blocks, head)\n  if (result.additions.length) {\n    blocks = new MultiBlockFetcher(new MemoryBlockstore(result.additions), blocks)\n  }\n  yield * Pail.entries(blocks, result.root, options)\n}\n\n/**\n * Find the common ancestor event of the passed children. A common ancestor is\n * the first single event in the DAG that _all_ paths from children lead to.\n *\n * @param {import('./clock').EventFetcher<EventData>} events\n * @param  {import('./clock').EventLink<EventData>[]} children\n */\nasync function findCommonAncestor (events, children) {\n  if (!children.length) return\n  const candidates = children.map(c => [c])\n  while (true) {\n    let changed = false\n    for (const c of candidates) {\n      const candidate = await findAncestorCandidate(events, c[c.length - 1])\n      if (!candidate) continue\n      changed = true\n      c.push(candidate)\n      const ancestor = findCommonString(candidates)\n      if (ancestor) return ancestor\n    }\n    if (!changed) return\n  }\n}\n\n/**\n * @param {import('./clock').EventFetcher<EventData>} events\n * @param {import('./clock').EventLink<EventData>} root\n */\nasync function findAncestorCandidate (events, root) {\n  const { value: event } = await events.get(root)\n  if (!event.parents.length) return root\n  return event.parents.length === 1\n    ? event.parents[0]\n    : findCommonAncestor(events, event.parents)\n}\n\n/**\n * @template {{ toString: () => string }} T\n * @param  {Array<T[]>} arrays\n */\nfunction findCommonString (arrays) {\n  arrays = arrays.map(a => [...a])\n  for (const arr of arrays) {\n    for (const item of arr) {\n      let matched = true\n      for (const other of arrays) {\n        if (arr === other) continue\n        matched = other.some(i => String(i) === String(item))\n        if (!matched) break\n      }\n      if (matched) return item\n    }\n  }\n}\n\n/**\n * Find and sort events between the head(s) and the tail.\n * @param {import('./clock').EventFetcher<EventData>} events\n * @param {import('./clock').EventLink<EventData>[]} head\n * @param {import('./clock').EventLink<EventData>} tail\n */\nasync function findSortedEvents (events, head, tail) {\n  if (head.length === 1 && String(head[0]) === String(tail)) {\n    return []\n  }\n  // get weighted events - heavier events happened first\n  /** @type {Map<string, { event: import('./clock').EventBlockView<EventData>, weight: number }>} */\n  const weights = new Map()\n  const all = await Promise.all(head.map(h => findEvents(events, h, tail)))\n  for (const arr of all) {\n    for (const { event, depth } of arr) {\n      const info = weights.get(event.cid.toString())\n      if (info) {\n        info.weight += depth\n      } else {\n        weights.set(event.cid.toString(), { event, weight: depth })\n      }\n    }\n  }\n\n  // group events into buckets by weight\n  /** @type {Map<number, import('./clock').EventBlockView<EventData>[]>} */\n  const buckets = new Map()\n  for (const { event, weight } of weights.values()) {\n    const bucket = buckets.get(weight)\n    if (bucket) {\n      bucket.push(event)\n    } else {\n      buckets.set(weight, [event])\n    }\n  }\n\n  // sort by weight, and by CID within weight\n  return Array.from(buckets)\n    .sort((a, b) => b[0] - a[0])\n    .flatMap(([, es]) => es.sort((a, b) => String(a.cid) < String(b.cid) ? -1 : 1))\n}\n\n/**\n * @param {import('./clock').EventFetcher<EventData>} events\n * @param {import('./clock').EventLink<EventData>} start\n * @param {import('./clock').EventLink<EventData>} end\n * @returns {Promise<Array<{ event: import('./clock').EventBlockView<EventData>, depth: number }>>}\n */\nasync function findEvents (events, start, end, depth = 0) {\n  const event = await events.get(start)\n  const acc = [{ event, depth }]\n  const { parents } = event.value\n  if (parents.length === 1 && String(parents[0]) === String(end)) return acc\n  const rest = await Promise.all(parents.map(p => findEvents(events, p, end, depth + 1)))\n  return acc.concat(...rest)\n}\n", "import * as PB from \"@ipld/dag-pb\"\nimport * as UnixFS from \"./unixfs.js\"\nimport { NodeType } from \"./unixfs.js\"\nimport { Data } from \"../gen/unixfs.js\"\n\nexport * from \"./unixfs.js\"\n\n/** @type {ReadonlyArray<any>} */\nconst EMPTY = Object.freeze([])\nconst EMPTY_BUFFER = new Uint8Array(0)\n\nconst BLANK = Object.freeze({})\nexport const DEFAULT_FILE_MODE = parseInt(\"0644\", 8)\nexport const DEFAULT_DIRECTORY_MODE = parseInt(\"0755\", 8)\n\nexport const code = PB.code\nexport const name = \"UnixFS\"\n\n/**\n * @param {UnixFS.IData} data\n * @param {ReadonlyArray<UnixFS.PBLink>} links\n */\nconst encodePB = (data, links) => {\n  Object(globalThis).debug && console.log({ data, links })\n\n  return PB.encode(\n    // We run through prepare as links need to be sorted by name which it will\n    // do.\n    PB.prepare({\n      Data: Data.encode(data).finish(),\n      // We can cast to mutable array as we know no mutation occurs there\n      Links:\n        /** @type {PB.PBLink[]} */ (links),\n    })\n  )\n}\n\n/**\n * @param {Uint8Array} content\n * @returns {UnixFS.Raw}\n */\nexport const createRaw = content => ({\n  type: NodeType.Raw,\n  content,\n})\n\n/**\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.SimpleFile}\n */\nexport const createEmptyFile = metadata =>\n  createSimpleFile(EMPTY_BUFFER, metadata)\n\n/**\n * @param {Uint8Array} content\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.SimpleFile}\n */\nexport const createSimpleFile = (content, metadata) => ({\n  type: NodeType.File,\n  layout: \"simple\",\n  content,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {Uint8Array} content\n * @returns {UnixFS.FileChunk}\n */\nexport const createFileChunk = content => ({\n  type: NodeType.File,\n  layout: \"simple\",\n  content,\n})\n\n/**\n * @param {UnixFS.FileLink[]} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.AdvancedFile}\n */\nexport const createAdvancedFile = (parts, metadata) => ({\n  type: NodeType.File,\n  layout: \"advanced\",\n  parts,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.FileLink[]} parts\n * @returns {UnixFS.FileShard}\n */\nexport const createFileShard = parts => ({\n  type: NodeType.File,\n  layout: \"advanced\",\n  parts,\n})\n\n/**\n * @deprecated\n * @param {Uint8Array} content\n * @param {UnixFS.FileLink[]} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ComplexFile}\n */\nexport const createComplexFile = (content, parts, metadata) => ({\n  type: NodeType.File,\n  layout: \"complex\",\n  content,\n  parts,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.DirectoryEntryLink[]} entries\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.FlatDirectory}\n */\nexport const createFlatDirectory = (entries, metadata) => ({\n  type: NodeType.Directory,\n  metadata: decodeMetadata(metadata),\n  entries,\n})\n\n/**\n * @param {UnixFS.ShardedDirectoryLink[]} entries\n * @param {Uint8Array} bitfield\n * @param {number} fanout\n * @param {number} hashType\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ShardedDirectory}\n */\nexport const createShardedDirectory = (\n  entries,\n  bitfield,\n  fanout,\n  hashType,\n  metadata = BLANK\n) => ({\n  type: NodeType.HAMTShard,\n  bitfield,\n  fanout: readFanout(fanout),\n  hashType: readInt(hashType),\n  entries,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.ShardedDirectoryLink[]} entries\n * @param {Uint8Array} bitfield\n * @param {number} fanout\n * @param {number} hashType\n * @returns {UnixFS.DirectoryShard}\n */\nexport const createDirectoryShard = (entries, bitfield, fanout, hashType) => ({\n  type: NodeType.HAMTShard,\n  bitfield,\n  fanout: readFanout(fanout),\n  hashType: readInt(hashType),\n  entries,\n})\n\n/**\n *\n * @param {Uint8Array} content\n * @returns {UnixFS.ByteView<UnixFS.Raw>}\n */\nexport const encodeRaw = content =>\n  encodePB(\n    {\n      Type: NodeType.Raw,\n      // TODO:\n      Data: content.byteLength > 0 ? content : undefined,\n      filesize: content.byteLength,\n      // @ts-ignore\n      blocksizes: EMPTY,\n    },\n    []\n  )\n\n/**\n * @param {UnixFS.File|UnixFS.FileChunk|UnixFS.FileShard} node\n * @param {boolean} [ignoreMetadata]\n * @returns {UnixFS.ByteView<UnixFS.SimpleFile|UnixFS.AdvancedFile|UnixFS.ComplexFile>}\n */\nexport const encodeFile = (node, ignoreMetadata = false) => {\n  const metadata = ignoreMetadata ? BLANK : Object(node).metadata\n  switch (node.layout) {\n    case \"simple\":\n      return encodeSimpleFile(node.content, metadata)\n    case \"advanced\":\n      return encodeAdvancedFile(node.parts, metadata)\n    case \"complex\":\n      return encodeComplexFile(node.content, node.parts, metadata)\n    default:\n      throw new TypeError(\n        `File with unknown layout \"${Object(node).layout}\" was passed`\n      )\n  }\n}\n\n/**\n * @param {Uint8Array} content\n * @returns {UnixFS.ByteView<UnixFS.FileChunk>}\n */\nexport const encodeFileChunk = content => encodeSimpleFile(content, BLANK)\n\n/**\n * @param {ReadonlyArray<UnixFS.FileLink>} parts\n * @returns {UnixFS.ByteView<UnixFS.FileShard>}\n */\nexport const encodeFileShard = parts =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      blocksizes: parts.map(contentByteLength),\n      filesize: cumulativeContentByteLength(parts),\n    },\n    parts.map(encodeLink)\n  )\n\n/**\n * @param {ReadonlyArray<UnixFS.FileLink>} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ByteView<UnixFS.AdvancedFile>}\n */\nexport const encodeAdvancedFile = (parts, metadata = BLANK) =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      blocksizes: parts.map(contentByteLength),\n      filesize: cumulativeContentByteLength(parts),\n\n      ...encodeMetadata(metadata),\n    },\n    parts.map(encodeLink)\n  )\n\n/**\n * @param {UnixFS.DAGLink} dag\n * @returns {UnixFS.PBLink}\n */\nexport const encodeLink = dag => ({\n  Name: \"\",\n  Tsize: dag.dagByteLength,\n  // @ts-ignore - @see https://github.com/multiformats/js-multiformats/pull/161\n  Hash: dag.cid,\n})\n\n/**\n * @param {Uint8Array} content\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ByteView<UnixFS.SimpleFile>}\n */\n\nexport const encodeSimpleFile = (content, metadata = BLANK) =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      // adding empty file to both go-ipfs and js-ipfs produces block in\n      // which `Data` is omitted but filesize and blocksizes are present.\n      // For the sake of hash consistency we do the same.\n      Data: content.byteLength > 0 ? content : undefined,\n      filesize: content.byteLength,\n      blocksizes: [],\n      ...encodeMetadata(metadata),\n    },\n    []\n  )\n\n/**\n *\n * @param {Uint8Array} content\n * @param {ReadonlyArray<UnixFS.FileLink>} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ByteView<UnixFS.ComplexFile>}\n */\nexport const encodeComplexFile = (content, parts, metadata = BLANK) =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      Data: content,\n      filesize: content.byteLength + cumulativeContentByteLength(parts),\n      blocksizes: parts.map(contentByteLength),\n    },\n    parts.map(encodeLink)\n  )\n\n/**\n * @param {UnixFS.FlatDirectory} node\n * @returns {UnixFS.ByteView<UnixFS.FlatDirectory>}\n */\nexport const encodeDirectory = node =>\n  encodePB(\n    {\n      Type: node.type,\n      ...encodeDirectoryMetadata(node.metadata || BLANK),\n    },\n    node.entries.map(encodeNamedLink)\n  )\n\n/**\n * @param {UnixFS.ShardedDirectory|UnixFS.DirectoryShard} node\n * @returns {UnixFS.ByteView<UnixFS.ShardedDirectory>}\n */\nexport const encodeHAMTShard = ({\n  bitfield,\n  fanout,\n  hashType,\n  entries,\n  metadata = BLANK,\n}) =>\n  encodePB(\n    {\n      Type: NodeType.HAMTShard,\n      Data: bitfield.byteLength > 0 ? bitfield : undefined,\n      fanout: readFanout(fanout),\n      hashType: readInt(hashType),\n\n      ...encodeDirectoryMetadata(metadata),\n    },\n    entries.map(encodeNamedLink)\n  )\n\n/**\n * @param {number} n\n * @returns {number}\n */\nconst readFanout = n => {\n  if (Math.log2(n) % 1 === 0) {\n    return n\n  } else {\n    throw new TypeError(\n      `Expected hamt size to be a power of two instead got ${n}`\n    )\n  }\n}\n\n/**\n * @param {number} n\n * @returns {number}\n */\n\nconst readInt = n => {\n  if (Number.isInteger(n)) {\n    return n\n  } else {\n    throw new TypeError(`Expected an integer value instead got ${n}`)\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n */\nconst readData = bytes => (bytes.byteLength > 0 ? bytes : undefined)\n\n/**\n * @param {Uint8Array} path\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.Symlink}\n */\nexport const createSymlink = (path, metadata = BLANK) => ({\n  type: NodeType.Symlink,\n  content: path,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.Symlink} node\n * @param {boolean} [ignoreMetadata]\n * @returns {UnixFS.ByteView<UnixFS.Symlink>}\n */\nexport const encodeSymlink = (node, ignoreMetadata = false) => {\n  const metadata = ignoreMetadata ? BLANK : Object(node).metadata\n  // We do not include filesize on symlinks because that is what go-ipfs does\n  // when doing `ipfs add mysymlink`. js-ipfs on the other hand seems to store\n  // it, here we choose to follow go-ipfs\n  // @see https://explore.ipld.io/#/explore/QmPZ1CTc5fYErTH2XXDGrfsPsHicYXtkZeVojGycwAfm3v\n  // @see https://github.com/ipfs/js-ipfs-unixfs/issues/195\n  return encodePB(\n    {\n      Type: NodeType.Symlink,\n      Data: node.content,\n      ...encodeMetadata(metadata || BLANK),\n    },\n    []\n  )\n}\n\n/**\n * @template {UnixFS.Node} T\n * @param {T} node\n * @param {boolean} root\n */\nexport const encode = (node, root = true) => {\n  switch (node.type) {\n    case NodeType.Raw:\n      return encodeRaw(node.content)\n    case NodeType.File:\n      return encodeFile(node)\n    case NodeType.Directory:\n      return encodeDirectory(node)\n    case NodeType.HAMTShard:\n      return encodeHAMTShard(node)\n    case NodeType.Symlink:\n      return encodeSymlink(node)\n    default:\n      throw new Error(`Unknown node type ${Object(node).type}`)\n  }\n}\n\n/**\n * @param {UnixFS.ByteView<UnixFS.Node>} bytes\n * @returns {UnixFS.Node}\n */\nexport const decode = bytes => {\n  const pb = PB.decode(bytes)\n  const message = Data.decode(/** @type {Uint8Array} */ (pb.Data))\n\n  const {\n    Type: type,\n    Data: data,\n    mtime,\n    mode,\n    blocksizes,\n    ...rest\n  } = Data.toObject(message, {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false,\n  })\n  const metadata = {\n    ...(mode && { mode }),\n    ...decodeMtime(mtime),\n  }\n  /** @type {UnixFS.PBLink[]} */\n  const links = pb.Links\n\n  switch (message.Type) {\n    case NodeType.Raw:\n      return createRaw(data)\n    case NodeType.File:\n      if (links.length === 0) {\n        return new SimpleFileView(data, metadata)\n      } else if (data.byteLength === 0) {\n        return new AdvancedFileView(\n          decodeFileLinks(rest.blocksizes, links),\n          metadata\n        )\n      } else {\n        return new ComplexFileView(\n          data,\n          decodeFileLinks(rest.blocksizes, links),\n          metadata\n        )\n      }\n    case NodeType.Directory:\n      return createFlatDirectory(decodeDirectoryLinks(links), metadata)\n    case NodeType.HAMTShard:\n      return createShardedDirectory(\n        decodeDirectoryLinks(links),\n        data || EMPTY_BUFFER,\n        rest.fanout,\n        rest.hashType,\n        metadata\n      )\n    case NodeType.Symlink:\n      return createSymlink(data, metadata)\n    default:\n      throw new TypeError(`Unsupported node type ${message.Type}`)\n  }\n}\n\n/**\n * @param {UnixFS.UnixTime|undefined} mtime\n */\nconst decodeMtime = mtime =>\n  mtime == null\n    ? undefined\n    : {\n        mtime: { secs: mtime.Seconds, nsecs: mtime.FractionalNanoseconds || 0 },\n      }\n\n/**\n * @param {NodeType} type\n * @param {number[]|undefined} blocksizes\n */\nconst decodeBlocksizes = (type, blocksizes) => {\n  switch (type) {\n    case NodeType.File:\n      return blocksizes && blocksizes.length > 0 ? { blocksizes } : undefined\n    default:\n      return undefined\n  }\n}\n\n/**\n *\n * @param {number[]} blocksizes\n * @param {UnixFS.PBLink[]} links\n * @returns {UnixFS.FileLink[]}\n */\n\nconst decodeFileLinks = (blocksizes, links) => {\n  const parts = []\n  const length = blocksizes.length\n  let n = 0\n  while (n < length) {\n    parts.push(\n      /** @type {UnixFS.FileLink} */ ({\n        cid: links[n].Hash,\n        dagByteLength: links[n].Tsize || 0,\n        contentByteLength: blocksizes[n],\n      })\n    )\n  }\n  return parts\n}\n\n/**\n * @param {UnixFS.PBLink[]} links\n * @returns {UnixFS.DirectoryEntryLink[]}\n */\nconst decodeDirectoryLinks = links =>\n  links.map(\n    link =>\n      /** @type {UnixFS.DirectoryEntryLink} */ ({\n        cid: link.Hash,\n        name: link.Name || \"\",\n        dagByteLength: link.Tsize || 0,\n      })\n  )\n\n/**\n * @param {ReadonlyArray<UnixFS.FileLink>} links\n * @returns {number}\n */\nexport const cumulativeContentByteLength = links =>\n  links.reduce((size, link) => size + link.contentByteLength, 0)\n\n/**\n * @param {Uint8Array} root\n * @param {ReadonlyArray<UnixFS.DAGLink>} links\n * @returns {number}\n */\nexport const cumulativeDagByteLength = (root, links) =>\n  links.reduce((size, link) => size + link.dagByteLength, root.byteLength)\n\n/**\n *\n * @param {UnixFS.FileLink} link\n */\nconst contentByteLength = link => link.contentByteLength\n\n/**\n * @param {UnixFS.NamedDAGLink<unknown>} link\n * @returns {UnixFS.PBLink}\n */\nconst encodeNamedLink = ({ name, dagByteLength, cid }) => ({\n  Name: name,\n  Tsize: dagByteLength,\n  Hash: cid,\n})\n\n/**\n * @param {UnixFS.Metadata} metadata\n */\nexport const encodeDirectoryMetadata = metadata =>\n  encodeMetadata(metadata, DEFAULT_DIRECTORY_MODE)\n\n/**\n * @param {UnixFS.Metadata} metadata\n * @param {UnixFS.Mode} defaultMode\n */\nexport const encodeMetadata = (\n  { mode, mtime },\n  defaultMode = DEFAULT_FILE_MODE\n) => ({\n  mode: mode != null ? encodeMode(mode, defaultMode) : undefined,\n  mtime: mtime != null ? encodeMTime(mtime) : undefined,\n})\n\n/**\n * @param {UnixFS.Metadata} [data]\n */\nexport const decodeMetadata = data =>\n  data == null\n    ? BLANK\n    : {\n        ...(data.mode == null ? undefined : { mode: decodeMode(data.mode) }),\n        ...(data.mtime == null ? undefined : { mtime: data.mtime }),\n      }\n\n/**\n * @param {UnixFS.MTime} mtime\n */\nconst encodeMTime = mtime => {\n  return mtime == null\n    ? undefined\n    : mtime.nsecs !== 0\n    ? { Seconds: mtime.secs, FractionalNanoseconds: mtime.nsecs }\n    : { Seconds: mtime.secs }\n}\n\n/**\n * @param {number} specifiedMode\n * @param {number} defaultMode\n */\nexport const encodeMode = (specifiedMode, defaultMode) => {\n  const mode = specifiedMode == null ? undefined : decodeMode(specifiedMode)\n  return mode === defaultMode || mode == null ? undefined : mode\n}\n\n/**\n * @param {UnixFS.Mode} mode\n * @returns {UnixFS.Mode}\n */\nconst decodeMode = mode => (mode & 0xfff) | (mode & 0xfffff000)\n\n/**\n * @param {{content?: Uint8Array, parts?: ReadonlyArray<UnixFS.FileLink>, metadata?: UnixFS.Metadata }} node\n * @returns {UnixFS.SimpleFile|UnixFS.AdvancedFile|UnixFS.ComplexFile}\n */\nexport const matchFile = ({\n  content = EMPTY_BUFFER,\n  parts = EMPTY,\n  metadata = BLANK,\n  ...rest\n}) => {\n  if (parts.length === 0) {\n    return new SimpleFileView(content, metadata)\n  } else if (content.byteLength === 0) {\n    return new AdvancedFileView(parts, metadata)\n  } else {\n    return new ComplexFileView(content, parts, metadata)\n  }\n}\n\n/**\n * @implements {UnixFS.SimpleFile}\n */\nclass SimpleFileView {\n  /**\n   * @param {Uint8Array} content\n   * @param {UnixFS.Metadata} metadata\n   */\n  constructor(content, metadata) {\n    this.content = content\n    this.metadata = metadata\n    /**\n     * @readonly\n     * @type {\"simple\"}\n     */\n    this.layout = \"simple\"\n    /**\n     * @readonly\n     * @type {NodeType.File}\n     */\n    this.type = NodeType.File\n  }\n\n  get filesize() {\n    return this.content.byteLength\n  }\n\n  encode() {\n    return encodeSimpleFile(this.content, this.metadata)\n  }\n}\n\n/**\n * @implements {UnixFS.AdvancedFile}\n */\nclass AdvancedFileView {\n  /**\n   * @param {ReadonlyArray<UnixFS.FileLink>} parts\n   * @param {UnixFS.Metadata} metadata\n   */\n  constructor(parts, metadata) {\n    this.parts = parts\n    this.metadata = metadata\n  }\n  /** @type {\"advanced\"} */\n  get layout() {\n    return \"advanced\"\n  }\n\n  /**\n   * @returns {NodeType.File}\n   */\n  get type() {\n    return NodeType.File\n  }\n  get fileSize() {\n    return cumulativeContentByteLength(this.parts)\n  }\n  get blockSizes() {\n    return this.parts.map(contentByteLength)\n  }\n\n  encode() {\n    return encodeAdvancedFile(this.parts, this.metadata)\n  }\n}\n\n/**\n * @implements {UnixFS.ComplexFile}\n */\nclass ComplexFileView {\n  /**\n   * @param {Uint8Array} content\n   * @param {ReadonlyArray<UnixFS.FileLink>} parts\n   * @param {UnixFS.Metadata} metadata\n   */\n  constructor(content, parts, metadata) {\n    this.content = content\n    this.parts = parts\n    this.metadata = metadata\n  }\n  /** @type {\"complex\"} */\n  get layout() {\n    return \"complex\"\n  }\n\n  /**\n   * @returns {NodeType.File}\n   */\n  get type() {\n    return NodeType.File\n  }\n  get fileSize() {\n    return this.content.byteLength + cumulativeContentByteLength(this.parts)\n  }\n  get blockSizes() {\n    return this.parts.map(contentByteLength)\n  }\n\n  encode() {\n    return encodeComplexFile(this.content, this.parts, this.metadata)\n  }\n}\n\n/**\n * @param {UnixFS.File|UnixFS.Raw|UnixFS.FileChunk|UnixFS.FileShard|UnixFS.Symlink} node\n * @returns {number}\n */\nexport const filesize = node => {\n  switch (node.type) {\n    case NodeType.Raw:\n    case NodeType.Symlink:\n      return node.content.byteLength\n    case NodeType.File:\n      switch (node.layout) {\n        case \"simple\":\n          return node.content.byteLength\n        case \"advanced\":\n          return cumulativeContentByteLength(node.parts)\n        case \"complex\":\n          return (\n            node.content.byteLength + cumulativeContentByteLength(node.parts)\n          )\n      }\n    default:\n      return 0\n  }\n}\n", "const textDecoder = new TextDecoder()\n\n/**\n * @typedef {import('./interface').RawPBLink} RawPBLink\n */\n\n/**\n * @typedef {import('./interface').RawPBNode} RawPBNode\n */\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {[number, number]}\n */\nfunction decodeVarint (bytes, offset) {\n  let v = 0\n\n  for (let shift = 0; ; shift += 7) {\n    /* c8 ignore next 3 */\n    if (shift >= 64) {\n      throw new Error('protobuf: varint overflow')\n    }\n    /* c8 ignore next 3 */\n    if (offset >= bytes.length) {\n      throw new Error('protobuf: unexpected end of data')\n    }\n\n    const b = bytes[offset++]\n    v += shift < 28 ? (b & 0x7f) << shift : (b & 0x7f) * (2 ** shift)\n    if (b < 0x80) {\n      break\n    }\n  }\n  return [v, offset]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {[Uint8Array, number]}\n */\nfunction decodeBytes (bytes, offset) {\n  let byteLen\n  ;[byteLen, offset] = decodeVarint(bytes, offset)\n  const postOffset = offset + byteLen\n\n  /* c8 ignore next 3 */\n  if (byteLen < 0 || postOffset < 0) {\n    throw new Error('protobuf: invalid length')\n  }\n  /* c8 ignore next 3 */\n  if (postOffset > bytes.length) {\n    throw new Error('protobuf: unexpected end of data')\n  }\n\n  return [bytes.subarray(offset, postOffset), postOffset]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} index\n * @returns {[number, number, number]}\n */\nfunction decodeKey (bytes, index) {\n  let wire\n  ;[wire, index] = decodeVarint(bytes, index)\n  // [wireType, fieldNum, newIndex]\n  return [wire & 0x7, wire >> 3, index]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {RawPBLink}\n */\nfunction decodeLink (bytes) {\n  /** @type {RawPBLink} */\n  const link = {}\n  const l = bytes.length\n  let index = 0\n\n  while (index < l) {\n    let wireType, fieldNum\n    ;[wireType, fieldNum, index] = decodeKey(bytes, index)\n\n    if (fieldNum === 1) {\n      if (link.Hash) {\n        throw new Error('protobuf: (PBLink) duplicate Hash section')\n      }\n      if (wireType !== 2) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`)\n      }\n      if (link.Name !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Name before Hash')\n      }\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Hash')\n      }\n\n      [link.Hash, index] = decodeBytes(bytes, index)\n    } else if (fieldNum === 2) {\n      if (link.Name !== undefined) {\n        throw new Error('protobuf: (PBLink) duplicate Name section')\n      }\n      if (wireType !== 2) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`)\n      }\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Name')\n      }\n\n      let byts\n      ;[byts, index] = decodeBytes(bytes, index)\n      link.Name = textDecoder.decode(byts)\n    } else if (fieldNum === 3) {\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) duplicate Tsize section')\n      }\n      if (wireType !== 0) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`)\n      }\n\n      [link.Tsize, index] = decodeVarint(bytes, index)\n    } else {\n      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  if (index > l) {\n    throw new Error('protobuf: (PBLink) unexpected end of data')\n  }\n\n  return link\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {RawPBNode}\n */\nexport function decodeNode (bytes) {\n  const l = bytes.length\n  let index = 0\n  /** @type {RawPBLink[]|void} */\n  let links\n  let linksBeforeData = false\n  /** @type {Uint8Array|void} */\n  let data\n\n  while (index < l) {\n    let wireType, fieldNum\n    ;[wireType, fieldNum, index] = decodeKey(bytes, index)\n\n    if (wireType !== 2) {\n      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`)\n    }\n\n    if (fieldNum === 1) {\n      if (data) {\n        throw new Error('protobuf: (PBNode) duplicate Data section')\n      }\n\n      [data, index] = decodeBytes(bytes, index)\n      if (links) {\n        linksBeforeData = true\n      }\n    } else if (fieldNum === 2) {\n      if (linksBeforeData) { // interleaved Links/Data/Links\n        throw new Error('protobuf: (PBNode) duplicate Links section')\n      } else if (!links) {\n        links = []\n      }\n      let byts\n      ;[byts, index] = decodeBytes(bytes, index)\n      links.push(decodeLink(byts))\n    } else {\n      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  if (index > l) {\n    throw new Error('protobuf: (PBNode) unexpected end of data')\n  }\n\n  /** @type {RawPBNode} */\n  const node = {}\n  if (data) {\n    node.Data = data\n  }\n  node.Links = links || []\n  return node\n}\n", "const textEncoder = new TextEncoder()\nconst maxInt32 = 2 ** 32\nconst maxUInt32 = 2 ** 31\n\n/**\n * @typedef {import('./interface').RawPBLink} RawPBLink\n */\n\n/**\n * @typedef {import('./interface').RawPBNode} RawPBNode\n */\n\n// the encoders work backward from the end of the bytes array\n\n/**\n * encodeLink() is passed a slice of the parent byte array that ends where this\n * link needs to end, so it packs to the right-most part of the passed `bytes`\n *\n * @param {RawPBLink} link\n * @param {Uint8Array} bytes\n * @returns {number}\n */\nfunction encodeLink (link, bytes) {\n  let i = bytes.length\n\n  if (typeof link.Tsize === 'number') {\n    if (link.Tsize < 0) {\n      throw new Error('Tsize cannot be negative')\n    }\n    if (!Number.isSafeInteger(link.Tsize)) {\n      throw new Error('Tsize too large for encoding')\n    }\n    i = encodeVarint(bytes, i, link.Tsize) - 1\n    bytes[i] = 0x18\n  }\n\n  if (typeof link.Name === 'string') {\n    const nameBytes = textEncoder.encode(link.Name)\n    i -= nameBytes.length\n    bytes.set(nameBytes, i)\n    i = encodeVarint(bytes, i, nameBytes.length) - 1\n    bytes[i] = 0x12\n  }\n\n  if (link.Hash) {\n    i -= link.Hash.length\n    bytes.set(link.Hash, i)\n    i = encodeVarint(bytes, i, link.Hash.length) - 1\n    bytes[i] = 0xa\n  }\n\n  return bytes.length - i\n}\n\n/**\n * Encodes a PBNode into a new byte array of precisely the correct size\n *\n * @param {RawPBNode} node\n * @returns {Uint8Array}\n */\nexport function encodeNode (node) {\n  const size = sizeNode(node)\n  const bytes = new Uint8Array(size)\n  let i = size\n\n  if (node.Data) {\n    i -= node.Data.length\n    bytes.set(node.Data, i)\n    i = encodeVarint(bytes, i, node.Data.length) - 1\n    bytes[i] = 0xa\n  }\n\n  if (node.Links) {\n    for (let index = node.Links.length - 1; index >= 0; index--) {\n      const size = encodeLink(node.Links[index], bytes.subarray(0, i))\n      i -= size\n      i = encodeVarint(bytes, i, size) - 1\n      bytes[i] = 0x12\n    }\n  }\n\n  return bytes\n}\n\n/**\n * work out exactly how many bytes this link takes up\n *\n * @param {RawPBLink} link\n * @returns\n */\nfunction sizeLink (link) {\n  let n = 0\n\n  if (link.Hash) {\n    const l = link.Hash.length\n    n += 1 + l + sov(l)\n  }\n\n  if (typeof link.Name === 'string') {\n    const l = textEncoder.encode(link.Name).length\n    n += 1 + l + sov(l)\n  }\n\n  if (typeof link.Tsize === 'number') {\n    n += 1 + sov(link.Tsize)\n  }\n\n  return n\n}\n\n/**\n * Work out exactly how many bytes this node takes up\n *\n * @param {RawPBNode} node\n * @returns {number}\n */\nfunction sizeNode (node) {\n  let n = 0\n\n  if (node.Data) {\n    const l = node.Data.length\n    n += 1 + l + sov(l)\n  }\n\n  if (node.Links) {\n    for (const link of node.Links) {\n      const l = sizeLink(link)\n      n += 1 + l + sov(l)\n    }\n  }\n\n  return n\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @param {number} v\n * @returns {number}\n */\nfunction encodeVarint (bytes, offset, v) {\n  offset -= sov(v)\n  const base = offset\n\n  while (v >= maxUInt32) {\n    bytes[offset++] = (v & 0x7f) | 0x80\n    v /= 128\n  }\n\n  while (v >= 128) {\n    bytes[offset++] = (v & 0x7f) | 0x80\n    v >>>= 7\n  }\n\n  bytes[offset] = v\n\n  return base\n}\n\n/**\n * size of varint\n *\n * @param {number} x\n * @returns {number}\n */\nfunction sov (x) {\n  if (x % 2 === 0) {\n    x++\n  }\n  return Math.floor((len64(x) + 6) / 7)\n}\n\n/**\n * golang math/bits, how many bits does it take to represent this integer?\n *\n * @param {number} x\n * @returns {number}\n */\nfunction len64 (x) {\n  let n = 0\n  if (x >= maxInt32) {\n    x = Math.floor(x / maxInt32)\n    n = 32\n  }\n  if (x >= (1 << 16)) {\n    x >>>= 16\n    n += 16\n  }\n  if (x >= (1 << 8)) {\n    x >>>= 8\n    n += 8\n  }\n  return n + len8tab[x]\n}\n\n// golang math/bits\nconst len8tab = [\n  0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8\n]\n", "import { CID } from 'multiformats/cid'\n\n/**\n * @typedef {import('./interface').PBLink} PBLink\n * @typedef {import('./interface').PBNode} PBNode\n */\n\nconst pbNodeProperties = ['Data', 'Links']\nconst pbLinkProperties = ['Hash', 'Name', 'Tsize']\n\nconst textEncoder = new TextEncoder()\n\n/**\n * @param {PBLink} a\n * @param {PBLink} b\n * @returns {number}\n */\nfunction linkComparator (a, b) {\n  if (a === b) {\n    return 0\n  }\n\n  const abuf = a.Name ? textEncoder.encode(a.Name) : []\n  const bbuf = b.Name ? textEncoder.encode(b.Name) : []\n\n  let x = abuf.length\n  let y = bbuf.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (abuf[i] !== bbuf[i]) {\n      x = abuf[i]\n      y = bbuf[i]\n      break\n    }\n  }\n\n  return x < y ? -1 : y < x ? 1 : 0\n}\n\n/**\n * @param {any} node\n * @param {string[]} properties\n * @returns {boolean}\n */\nfunction hasOnlyProperties (node, properties) {\n  return !Object.keys(node).some((p) => !properties.includes(p))\n}\n\n/**\n * Converts a CID, or a PBLink-like object to a PBLink\n *\n * @param {any} link\n * @returns {PBLink}\n */\nfunction asLink (link) {\n  if (typeof link.asCID === 'object') {\n    const Hash = CID.asCID(link)\n    if (!Hash) {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n    return { Hash }\n  }\n\n  if (typeof link !== 'object' || Array.isArray(link)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  const pbl = {}\n\n  if (link.Hash) {\n    let cid = CID.asCID(link.Hash)\n    try {\n      if (!cid) {\n        if (typeof link.Hash === 'string') {\n          cid = CID.parse(link.Hash)\n        } else if (link.Hash instanceof Uint8Array) {\n          cid = CID.decode(link.Hash)\n        }\n      }\n    } catch (/** @type {any} */ e) {\n      throw new TypeError(`Invalid DAG-PB form: ${e.message}`)\n    }\n\n    if (cid) {\n      pbl.Hash = cid\n    }\n  }\n\n  if (!pbl.Hash) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  if (typeof link.Name === 'string') {\n    pbl.Name = link.Name\n  }\n\n  if (typeof link.Tsize === 'number') {\n    pbl.Tsize = link.Tsize\n  }\n\n  return pbl\n}\n\n/**\n * @param {any} node\n * @returns {PBNode}\n */\nexport function prepare (node) {\n  if (node instanceof Uint8Array || typeof node === 'string') {\n    node = { Data: node }\n  }\n\n  if (typeof node !== 'object' || Array.isArray(node)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  /** @type {PBNode} */\n  const pbn = {}\n\n  if (node.Data !== undefined) {\n    if (typeof node.Data === 'string') {\n      pbn.Data = textEncoder.encode(node.Data)\n    } else if (node.Data instanceof Uint8Array) {\n      pbn.Data = node.Data\n    } else {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n  }\n\n  if (node.Links !== undefined) {\n    if (Array.isArray(node.Links)) {\n      pbn.Links = node.Links.map(asLink)\n      pbn.Links.sort(linkComparator)\n    } else {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n  } else {\n    pbn.Links = []\n  }\n\n  return pbn\n}\n\n/**\n * @param {PBNode} node\n */\nexport function validate (node) {\n  /*\n  type PBLink struct {\n    Hash optional Link\n    Name optional String\n    Tsize optional Int\n  }\n\n  type PBNode struct {\n    Links [PBLink]\n    Data optional Bytes\n  }\n  */\n  // @ts-ignore private property for TS\n  if (!node || typeof node !== 'object' || Array.isArray(node) || node instanceof Uint8Array || (node['/'] && node['/'] === node.bytes)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  if (!hasOnlyProperties(node, pbNodeProperties)) {\n    throw new TypeError('Invalid DAG-PB form (extraneous properties)')\n  }\n\n  if (node.Data !== undefined && !(node.Data instanceof Uint8Array)) {\n    throw new TypeError('Invalid DAG-PB form (Data must be bytes)')\n  }\n\n  if (!Array.isArray(node.Links)) {\n    throw new TypeError('Invalid DAG-PB form (Links must be a list)')\n  }\n\n  for (let i = 0; i < node.Links.length; i++) {\n    const link = node.Links[i]\n    // @ts-ignore private property for TS\n    if (!link || typeof link !== 'object' || Array.isArray(link) || link instanceof Uint8Array || (link['/'] && link['/'] === link.bytes)) {\n      throw new TypeError('Invalid DAG-PB form (bad link)')\n    }\n\n    if (!hasOnlyProperties(link, pbLinkProperties)) {\n      throw new TypeError('Invalid DAG-PB form (extraneous properties on link)')\n    }\n\n    if (link.Hash === undefined) {\n      throw new TypeError('Invalid DAG-PB form (link must have a Hash)')\n    }\n\n    // @ts-ignore private property for TS\n    if (link.Hash == null || !link.Hash['/'] || link.Hash['/'] !== link.Hash.bytes) {\n      throw new TypeError('Invalid DAG-PB form (link Hash must be a CID)')\n    }\n\n    if (link.Name !== undefined && typeof link.Name !== 'string') {\n      throw new TypeError('Invalid DAG-PB form (link Name must be a string)')\n    }\n\n    if (link.Tsize !== undefined) {\n      if (typeof link.Tsize !== 'number' || link.Tsize % 1 !== 0) {\n        throw new TypeError('Invalid DAG-PB form (link Tsize must be an integer)')\n      }\n      if (link.Tsize < 0) {\n        throw new TypeError('Invalid DAG-PB form (link Tsize cannot be negative)')\n      }\n    }\n\n    if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {\n      throw new TypeError('Invalid DAG-PB form (links must be sorted by Name bytes)')\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {PBLink[]} [links=[]]\n * @returns {PBNode}\n */\nexport function createNode (data, links = []) {\n  return prepare({ Data: data, Links: links })\n}\n\n/**\n * @param {string} name\n * @param {number} size\n * @param {CID} cid\n * @returns {PBLink}\n */\nexport function createLink (name, size, cid) {\n  return asLink({ Hash: cid, Name: name, Tsize: size })\n}\n", "import { CID } from 'multiformats/cid'\nimport { decodeNode } from './pb-decode.js'\nimport { encodeNode } from './pb-encode.js'\nimport { prepare, validate, createNode, createLink } from './util.js'\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @typedef {import('./interface').PBLink} PBLink\n * @typedef {import('./interface').PBNode} PBNode\n */\n\nexport const name = 'dag-pb'\nexport const code = 0x70\n\n/**\n * @param {PBNode} node\n * @returns {ByteView<PBNode>}\n */\nexport function encode (node) {\n  validate(node)\n\n  const pbn = {}\n  if (node.Links) {\n    pbn.Links = node.Links.map((l) => {\n      const link = {}\n      if (l.Hash) {\n        link.Hash = l.Hash.bytes // cid -> bytes\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize\n      }\n      return link\n    })\n  }\n  if (node.Data) {\n    pbn.Data = node.Data\n  }\n\n  return encodeNode(pbn)\n}\n\n/**\n * @param {ByteView<PBNode>} bytes\n * @returns {PBNode}\n */\nexport function decode (bytes) {\n  const pbn = decodeNode(bytes)\n\n  const node = {}\n\n  if (pbn.Data) {\n    node.Data = pbn.Data\n  }\n\n  if (pbn.Links) {\n    node.Links = pbn.Links.map((l) => {\n      const link = {}\n      try {\n        link.Hash = CID.decode(l.Hash)\n      } catch (e) {}\n      if (!link.Hash) {\n        throw new Error('Invalid Hash field found in link, expected CID')\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize\n      }\n      return link\n    })\n  }\n\n  return node\n}\n\nexport { prepare, validate, createNode, createLink }\n", "/*eslint-disable*/\nimport $protobuf from \"protobufjs/minimal.js\";\n\n// Common aliases\nconst $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nconst $root = $protobuf.roots.unixfs || ($protobuf.roots.unixfs = {});\n\nexport const Data = $root.Data = (() => {\n\n    /**\n     * Properties of a Data.\n     * @exports IData\n     * @interface IData\n     * @property {Data.DataType} Type Data Type\n     * @property {Uint8Array|null} [Data] Data Data\n     * @property {number|null} [filesize] Data filesize\n     * @property {Array.<number>|null} [blocksizes] Data blocksizes\n     * @property {number|null} [hashType] Data hashType\n     * @property {number|null} [fanout] Data fanout\n     * @property {number|null} [mode] Data mode\n     * @property {IUnixTime|null} [mtime] Data mtime\n     */\n\n    /**\n     * Constructs a new Data.\n     * @exports Data\n     * @classdesc Represents a Data.\n     * @implements IData\n     * @constructor\n     * @param {IData=} [p] Properties to set\n     */\n    function Data(p) {\n        this.blocksizes = [];\n        if (p)\n            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                if (p[ks[i]] != null)\n                    this[ks[i]] = p[ks[i]];\n    }\n\n    /**\n     * Data Type.\n     * @member {Data.DataType} Type\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.Type = 0;\n\n    /**\n     * Data Data.\n     * @member {Uint8Array} Data\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.Data = $util.newBuffer([]);\n\n    /**\n     * Data filesize.\n     * @member {number} filesize\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.filesize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Data blocksizes.\n     * @member {Array.<number>} blocksizes\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.blocksizes = $util.emptyArray;\n\n    /**\n     * Data hashType.\n     * @member {number} hashType\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.hashType = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Data fanout.\n     * @member {number} fanout\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.fanout = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Data mode.\n     * @member {number} mode\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.mode = 0;\n\n    /**\n     * Data mtime.\n     * @member {IUnixTime|null|undefined} mtime\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.mtime = null;\n\n    /**\n     * Encodes the specified Data message. Does not implicitly {@link Data.verify|verify} messages.\n     * @function encode\n     * @memberof Data\n     * @static\n     * @param {IData} m Data message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Data.encode = function encode(m, w) {\n        if (!w)\n            w = $Writer.create();\n        w.uint32(8).int32(m.Type);\n        if (m.Data != null && Object.hasOwnProperty.call(m, \"Data\"))\n            w.uint32(18).bytes(m.Data);\n        if (m.filesize != null && Object.hasOwnProperty.call(m, \"filesize\"))\n            w.uint32(24).uint64(m.filesize);\n        if (m.blocksizes != null && m.blocksizes.length) {\n            for (var i = 0; i < m.blocksizes.length; ++i)\n                w.uint32(32).uint64(m.blocksizes[i]);\n        }\n        if (m.hashType != null && Object.hasOwnProperty.call(m, \"hashType\"))\n            w.uint32(40).uint64(m.hashType);\n        if (m.fanout != null && Object.hasOwnProperty.call(m, \"fanout\"))\n            w.uint32(48).uint64(m.fanout);\n        if (m.mode != null && Object.hasOwnProperty.call(m, \"mode\"))\n            w.uint32(56).uint32(m.mode);\n        if (m.mtime != null && Object.hasOwnProperty.call(m, \"mtime\"))\n            $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();\n        return w;\n    };\n\n    /**\n     * Decodes a Data message from the specified reader or buffer.\n     * @function decode\n     * @memberof Data\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Data} Data\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Data.decode = function decode(r, l) {\n        if (!(r instanceof $Reader))\n            r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l, m = new $root.Data();\n        while (r.pos < c) {\n            var t = r.uint32();\n            switch (t >>> 3) {\n            case 1:\n                m.Type = r.int32();\n                break;\n            case 2:\n                m.Data = r.bytes();\n                break;\n            case 3:\n                m.filesize = r.uint64();\n                break;\n            case 4:\n                if (!(m.blocksizes && m.blocksizes.length))\n                    m.blocksizes = [];\n                if ((t & 7) === 2) {\n                    var c2 = r.uint32() + r.pos;\n                    while (r.pos < c2)\n                        m.blocksizes.push(r.uint64());\n                } else\n                    m.blocksizes.push(r.uint64());\n                break;\n            case 5:\n                m.hashType = r.uint64();\n                break;\n            case 6:\n                m.fanout = r.uint64();\n                break;\n            case 7:\n                m.mode = r.uint32();\n                break;\n            case 8:\n                m.mtime = $root.UnixTime.decode(r, r.uint32());\n                break;\n            default:\n                r.skipType(t & 7);\n                break;\n            }\n        }\n        if (!m.hasOwnProperty(\"Type\"))\n            throw $util.ProtocolError(\"missing required 'Type'\", { instance: m });\n        return m;\n    };\n\n    /**\n     * Creates a Data message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Data\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Data} Data\n     */\n    Data.fromObject = function fromObject(d) {\n        if (d instanceof $root.Data)\n            return d;\n        var m = new $root.Data();\n        switch (d.Type) {\n        case \"Raw\":\n        case 0:\n            m.Type = 0;\n            break;\n        case \"Directory\":\n        case 1:\n            m.Type = 1;\n            break;\n        case \"File\":\n        case 2:\n            m.Type = 2;\n            break;\n        case \"Metadata\":\n        case 3:\n            m.Type = 3;\n            break;\n        case \"Symlink\":\n        case 4:\n            m.Type = 4;\n            break;\n        case \"HAMTShard\":\n        case 5:\n            m.Type = 5;\n            break;\n        }\n        if (d.Data != null) {\n            if (typeof d.Data === \"string\")\n                $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);\n            else if (d.Data.length)\n                m.Data = d.Data;\n        }\n        if (d.filesize != null) {\n            if ($util.Long)\n                (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;\n            else if (typeof d.filesize === \"string\")\n                m.filesize = parseInt(d.filesize, 10);\n            else if (typeof d.filesize === \"number\")\n                m.filesize = d.filesize;\n            else if (typeof d.filesize === \"object\")\n                m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);\n        }\n        if (d.blocksizes) {\n            if (!Array.isArray(d.blocksizes))\n                throw TypeError(\".Data.blocksizes: array expected\");\n            m.blocksizes = [];\n            for (var i = 0; i < d.blocksizes.length; ++i) {\n                if ($util.Long)\n                    (m.blocksizes[i] = $util.Long.fromValue(d.blocksizes[i])).unsigned = true;\n                else if (typeof d.blocksizes[i] === \"string\")\n                    m.blocksizes[i] = parseInt(d.blocksizes[i], 10);\n                else if (typeof d.blocksizes[i] === \"number\")\n                    m.blocksizes[i] = d.blocksizes[i];\n                else if (typeof d.blocksizes[i] === \"object\")\n                    m.blocksizes[i] = new $util.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);\n            }\n        }\n        if (d.hashType != null) {\n            if ($util.Long)\n                (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;\n            else if (typeof d.hashType === \"string\")\n                m.hashType = parseInt(d.hashType, 10);\n            else if (typeof d.hashType === \"number\")\n                m.hashType = d.hashType;\n            else if (typeof d.hashType === \"object\")\n                m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);\n        }\n        if (d.fanout != null) {\n            if ($util.Long)\n                (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;\n            else if (typeof d.fanout === \"string\")\n                m.fanout = parseInt(d.fanout, 10);\n            else if (typeof d.fanout === \"number\")\n                m.fanout = d.fanout;\n            else if (typeof d.fanout === \"object\")\n                m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);\n        }\n        if (d.mode != null) {\n            m.mode = d.mode >>> 0;\n        }\n        if (d.mtime != null) {\n            if (typeof d.mtime !== \"object\")\n                throw TypeError(\".Data.mtime: object expected\");\n            m.mtime = $root.UnixTime.fromObject(d.mtime);\n        }\n        return m;\n    };\n\n    /**\n     * Creates a plain object from a Data message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Data\n     * @static\n     * @param {Data} m Data\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Data.toObject = function toObject(m, o) {\n        if (!o)\n            o = {};\n        var d = {};\n        if (o.arrays || o.defaults) {\n            d.blocksizes = [];\n        }\n        if (o.defaults) {\n            d.Type = o.enums === String ? \"Raw\" : 0;\n            if (o.bytes === String)\n                d.Data = \"\";\n            else {\n                d.Data = [];\n                if (o.bytes !== Array)\n                    d.Data = $util.newBuffer(d.Data);\n            }\n            if ($util.Long) {\n                var n = new $util.Long(0, 0, true);\n                d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n            } else\n                d.filesize = o.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var n = new $util.Long(0, 0, true);\n                d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n            } else\n                d.hashType = o.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var n = new $util.Long(0, 0, true);\n                d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n            } else\n                d.fanout = o.longs === String ? \"0\" : 0;\n            d.mode = 0;\n            d.mtime = null;\n        }\n        if (m.Type != null && m.hasOwnProperty(\"Type\")) {\n            d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;\n        }\n        if (m.Data != null && m.hasOwnProperty(\"Data\")) {\n            d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;\n        }\n        if (m.filesize != null && m.hasOwnProperty(\"filesize\")) {\n            if (typeof m.filesize === \"number\")\n                d.filesize = o.longs === String ? String(m.filesize) : m.filesize;\n            else\n                d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;\n        }\n        if (m.blocksizes && m.blocksizes.length) {\n            d.blocksizes = [];\n            for (var j = 0; j < m.blocksizes.length; ++j) {\n                if (typeof m.blocksizes[j] === \"number\")\n                    d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];\n                else\n                    d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];\n            }\n        }\n        if (m.hashType != null && m.hasOwnProperty(\"hashType\")) {\n            if (typeof m.hashType === \"number\")\n                d.hashType = o.longs === String ? String(m.hashType) : m.hashType;\n            else\n                d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;\n        }\n        if (m.fanout != null && m.hasOwnProperty(\"fanout\")) {\n            if (typeof m.fanout === \"number\")\n                d.fanout = o.longs === String ? String(m.fanout) : m.fanout;\n            else\n                d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;\n        }\n        if (m.mode != null && m.hasOwnProperty(\"mode\")) {\n            d.mode = m.mode;\n        }\n        if (m.mtime != null && m.hasOwnProperty(\"mtime\")) {\n            d.mtime = $root.UnixTime.toObject(m.mtime, o);\n        }\n        return d;\n    };\n\n    /**\n     * Converts this Data to JSON.\n     * @function toJSON\n     * @memberof Data\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Data.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * DataType enum.\n     * @name Data.DataType\n     * @enum {number}\n     * @property {number} Raw=0 Raw value\n     * @property {number} Directory=1 Directory value\n     * @property {number} File=2 File value\n     * @property {number} Metadata=3 Metadata value\n     * @property {number} Symlink=4 Symlink value\n     * @property {number} HAMTShard=5 HAMTShard value\n     */\n    Data.DataType = (function() {\n        const valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"Raw\"] = 0;\n        values[valuesById[1] = \"Directory\"] = 1;\n        values[valuesById[2] = \"File\"] = 2;\n        values[valuesById[3] = \"Metadata\"] = 3;\n        values[valuesById[4] = \"Symlink\"] = 4;\n        values[valuesById[5] = \"HAMTShard\"] = 5;\n        return values;\n    })();\n\n    return Data;\n})();\n\nexport const UnixTime = $root.UnixTime = (() => {\n\n    /**\n     * Properties of an UnixTime.\n     * @exports IUnixTime\n     * @interface IUnixTime\n     * @property {number} Seconds UnixTime Seconds\n     * @property {number|null} [FractionalNanoseconds] UnixTime FractionalNanoseconds\n     */\n\n    /**\n     * Constructs a new UnixTime.\n     * @exports UnixTime\n     * @classdesc Represents an UnixTime.\n     * @implements IUnixTime\n     * @constructor\n     * @param {IUnixTime=} [p] Properties to set\n     */\n    function UnixTime(p) {\n        if (p)\n            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                if (p[ks[i]] != null)\n                    this[ks[i]] = p[ks[i]];\n    }\n\n    /**\n     * UnixTime Seconds.\n     * @member {number} Seconds\n     * @memberof UnixTime\n     * @instance\n     */\n    UnixTime.prototype.Seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n    /**\n     * UnixTime FractionalNanoseconds.\n     * @member {number} FractionalNanoseconds\n     * @memberof UnixTime\n     * @instance\n     */\n    UnixTime.prototype.FractionalNanoseconds = 0;\n\n    /**\n     * Encodes the specified UnixTime message. Does not implicitly {@link UnixTime.verify|verify} messages.\n     * @function encode\n     * @memberof UnixTime\n     * @static\n     * @param {IUnixTime} m UnixTime message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    UnixTime.encode = function encode(m, w) {\n        if (!w)\n            w = $Writer.create();\n        w.uint32(8).int64(m.Seconds);\n        if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, \"FractionalNanoseconds\"))\n            w.uint32(21).fixed32(m.FractionalNanoseconds);\n        return w;\n    };\n\n    /**\n     * Decodes an UnixTime message from the specified reader or buffer.\n     * @function decode\n     * @memberof UnixTime\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {UnixTime} UnixTime\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    UnixTime.decode = function decode(r, l) {\n        if (!(r instanceof $Reader))\n            r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l, m = new $root.UnixTime();\n        while (r.pos < c) {\n            var t = r.uint32();\n            switch (t >>> 3) {\n            case 1:\n                m.Seconds = r.int64();\n                break;\n            case 2:\n                m.FractionalNanoseconds = r.fixed32();\n                break;\n            default:\n                r.skipType(t & 7);\n                break;\n            }\n        }\n        if (!m.hasOwnProperty(\"Seconds\"))\n            throw $util.ProtocolError(\"missing required 'Seconds'\", { instance: m });\n        return m;\n    };\n\n    /**\n     * Creates an UnixTime message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof UnixTime\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {UnixTime} UnixTime\n     */\n    UnixTime.fromObject = function fromObject(d) {\n        if (d instanceof $root.UnixTime)\n            return d;\n        var m = new $root.UnixTime();\n        if (d.Seconds != null) {\n            if ($util.Long)\n                (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;\n            else if (typeof d.Seconds === \"string\")\n                m.Seconds = parseInt(d.Seconds, 10);\n            else if (typeof d.Seconds === \"number\")\n                m.Seconds = d.Seconds;\n            else if (typeof d.Seconds === \"object\")\n                m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();\n        }\n        if (d.FractionalNanoseconds != null) {\n            m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;\n        }\n        return m;\n    };\n\n    /**\n     * Creates a plain object from an UnixTime message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof UnixTime\n     * @static\n     * @param {UnixTime} m UnixTime\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    UnixTime.toObject = function toObject(m, o) {\n        if (!o)\n            o = {};\n        var d = {};\n        if (o.defaults) {\n            if ($util.Long) {\n                var n = new $util.Long(0, 0, false);\n                d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n            } else\n                d.Seconds = o.longs === String ? \"0\" : 0;\n            d.FractionalNanoseconds = 0;\n        }\n        if (m.Seconds != null && m.hasOwnProperty(\"Seconds\")) {\n            if (typeof m.Seconds === \"number\")\n                d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;\n            else\n                d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;\n        }\n        if (m.FractionalNanoseconds != null && m.hasOwnProperty(\"FractionalNanoseconds\")) {\n            d.FractionalNanoseconds = m.FractionalNanoseconds;\n        }\n        return d;\n    };\n\n    /**\n     * Converts this UnixTime to JSON.\n     * @function toJSON\n     * @memberof UnixTime\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    UnixTime.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return UnixTime;\n})();\n\nexport const Metadata = $root.Metadata = (() => {\n\n    /**\n     * Properties of a Metadata.\n     * @exports IMetadata\n     * @interface IMetadata\n     * @property {string|null} [MimeType] Metadata MimeType\n     */\n\n    /**\n     * Constructs a new Metadata.\n     * @exports Metadata\n     * @classdesc Represents a Metadata.\n     * @implements IMetadata\n     * @constructor\n     * @param {IMetadata=} [p] Properties to set\n     */\n    function Metadata(p) {\n        if (p)\n            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                if (p[ks[i]] != null)\n                    this[ks[i]] = p[ks[i]];\n    }\n\n    /**\n     * Metadata MimeType.\n     * @member {string} MimeType\n     * @memberof Metadata\n     * @instance\n     */\n    Metadata.prototype.MimeType = \"\";\n\n    /**\n     * Encodes the specified Metadata message. Does not implicitly {@link Metadata.verify|verify} messages.\n     * @function encode\n     * @memberof Metadata\n     * @static\n     * @param {IMetadata} m Metadata message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Metadata.encode = function encode(m, w) {\n        if (!w)\n            w = $Writer.create();\n        if (m.MimeType != null && Object.hasOwnProperty.call(m, \"MimeType\"))\n            w.uint32(10).string(m.MimeType);\n        return w;\n    };\n\n    /**\n     * Decodes a Metadata message from the specified reader or buffer.\n     * @function decode\n     * @memberof Metadata\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Metadata} Metadata\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Metadata.decode = function decode(r, l) {\n        if (!(r instanceof $Reader))\n            r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l, m = new $root.Metadata();\n        while (r.pos < c) {\n            var t = r.uint32();\n            switch (t >>> 3) {\n            case 1:\n                m.MimeType = r.string();\n                break;\n            default:\n                r.skipType(t & 7);\n                break;\n            }\n        }\n        return m;\n    };\n\n    /**\n     * Creates a Metadata message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Metadata\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Metadata} Metadata\n     */\n    Metadata.fromObject = function fromObject(d) {\n        if (d instanceof $root.Metadata)\n            return d;\n        var m = new $root.Metadata();\n        if (d.MimeType != null) {\n            m.MimeType = String(d.MimeType);\n        }\n        return m;\n    };\n\n    /**\n     * Creates a plain object from a Metadata message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Metadata\n     * @static\n     * @param {Metadata} m Metadata\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Metadata.toObject = function toObject(m, o) {\n        if (!o)\n            o = {};\n        var d = {};\n        if (o.defaults) {\n            d.MimeType = \"\";\n        }\n        if (m.MimeType != null && m.hasOwnProperty(\"MimeType\")) {\n            d.MimeType = m.MimeType;\n        }\n        return d;\n    };\n\n    /**\n     * Converts this Metadata to JSON.\n     * @function toJSON\n     * @memberof Metadata\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Metadata.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Metadata;\n})();\n\nexport { $root as default };\n", "// @ts-nocheck\n\n/**\n * This is file is shadowed by api.ts and only exists so JS could import it to\n * refer to types without encountering runtime errors\n * @see https://github.com/microsoft/TypeScript/issues/41825\n */\n\nimport { Data } from \"../gen/unixfs.js\"\nexport const NodeType = Data.DataType\n", "import * as Task from \"./task.js\"\nexport * from \"./task.js\"\n\n/**\n * Turns a task (that never fails or sends messages) into an effect of it's\n * result.\n *\n * @template T\n * @param {Task.Task<T, never>} task\n * @returns {Task.Effect<T>}\n */\nexport const effect = function* (task) {\n  const message = yield* task\n  yield* send(message)\n}\n\n/**\n * Gets a handle to the task that invoked it. Useful when task needs to\n * suspend execution until some outside event occurs, in which case handle\n * can be used resume execution (see `suspend` code example for more details)\n *\n * @template T, M, X\n * @returns {Task.Task<Task.Controller<T, X, M>, never>}\n */\nexport function* current() {\n  return /** @type {Task.Controller<T, X, M>} */ (yield CURRENT)\n}\n\n/**\n * Suspends the current task (task that invokes it),  which can then be\n * resumed from another task or an outside event (e.g. `setTimeout` callback)\n * by calling the `resume` with an task's handle.\n *\n * Calling this in almost all cases is preceeded by call to `current()` in\n * order to obtain a `handle` which can be passed to `resume` function\n * to resume the execution.\n *\n * Note: This task never fails, although it may never resume either. However\n * you can utilize `finally` block to do a necessary cleanup in case execution\n * is aborted.\n *\n * @example\n * ```js\n * import { current, suspend, resume } from \"actor\"\n * function * sleep(duration) {\n *    // get a reference to this task so we can resume it.\n *    const self = yield * current()\n *    // resume this task when timeout fires\n *    const id = setTimeout(() => resume(self), duration)\n *    try {\n *      // suspend this task nothing below this line will run until task is\n *      // resumed.\n *      yield * suspend()\n *    } finally {\n *      // if task is aborted finally block will still run which given you\n *      // chance to cleanup.\n *      clearTimeout(id)\n *    }\n * }\n * ```\n *\n * @returns {Task.Task<void, never>}\n */\nexport const suspend = function* () {\n  yield SUSPEND\n}\n\n/**\n * Suspends execution for the given duration in milliseconds, after which\n * execution is resumed (unless it was aborted in the meantime).\n *\n * @example\n * ```js\n * function * demo() {\n *    console.log(\"I'm going to take small nap\")\n *    yield * sleep(200)\n *    console.log(\"I am back to work\")\n * }\n * ```\n *\n * @param {number} [duration]\n * @returns {Task.Task<void, never>}\n */\nexport function* sleep(duration = 0) {\n  const task = yield* current()\n  const id = setTimeout(enqueue, duration, task)\n\n  try {\n    yield* suspend()\n  } finally {\n    clearTimeout(id)\n  }\n}\n\n/**\n * Provides equivalent of `await` in async functions. Specifically it takes\n * a value that you can `await` on (that is `Promise<T>|T`) and suspends\n * execution until promise is settled. If promise succeeds execution is resumed\n * with `T` otherwise an error of type `X` is thrown (which is by default\n * `unknown` since promises do not encode error type).\n *\n * It is useful when you need to deal with potentially async set of operations\n * without having to check if thing is a promise at every step.\n *\n * Please note: This that execution is suspended even if given value is not a\n * promise, however scheduler will still resume it in the same tick of the event\n * loop after, just processing other scheduled tasks. This avoids problematic\n * race condititions that can otherwise occur when values are sometimes promises\n * and other times are not.\n *\n * @example\n * ```js\n * function * fetchJSON (url, options) {\n *    const response = yield * wait(fetch(url, options))\n *    const json = yield * wait(response.json())\n *    return json\n * }\n * ```\n *\n * @template T, [X=unknown]\n * @param {Task.Await<T>} input\n * @returns {Task.Task<T, Error>}\n */\nexport const wait = function* (input) {\n  const task = yield* current()\n  if (isAsync(input)) {\n    let failed = false\n    /** @type {unknown} */\n    let output = undefined\n    input.then(\n      value => {\n        failed = false\n        output = value\n        enqueue(task)\n      },\n      error => {\n        failed = true\n        output = error\n        enqueue(task)\n      }\n    )\n\n    yield* suspend()\n    if (failed) {\n      throw output\n    } else {\n      return /** @type {T} */ (output)\n    }\n  } else {\n    // This may seem redundunt but it is not, by enqueuing this task we allow\n    // scheduler to perform other queued tasks first. This way many race\n    // conditions can be avoided when values are sometimes promises and other\n    // times aren't.\n    // Unlike `await` however this will resume in the same tick.\n    main(wake(task))\n    yield* suspend()\n    return input\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Controller<T, X, M>} task\n * @returns {Task.Task<void, never, never>}\n */\nfunction* wake(task) {\n  enqueue(task)\n}\n\n/**\n * Checks if value value is a promise (or it's lookalike).\n *\n * @template T\n * @param {any} node\n * @returns {node is PromiseLike<T>}\n */\n\nconst isAsync = node =>\n  node != null &&\n  typeof (/** @type {{then?:unknown}} */ (node).then) === \"function\"\n\n/**\n * Task that sends given message (or rather an effect producing this message).\n * Please note, that while you could use `yield message` instead, but you'd risk\n * having to deal with potential breaking changes if library internals change\n * in the future, which in fact may happen as anticipated improvements in\n * TS generator inference could enable replace need for `yield *`.\n *\n * @see https://github.com/microsoft/TypeScript/issues/43632\n *\n * @template T\n * @param {T} message\n * @returns {Task.Effect<T>}\n */\nexport const send = function* (message) {\n  yield /** @type {Task.Message<T>} */ (message)\n}\n\n/**\n * Takes several effects and merges them into a single effect of tagged\n * variants so that their source could be identified via `type` field.\n *\n * @example\n * ```js\n * listen({\n *    read: Task.effect(dbRead),\n *    write: Task.effect(dbWrite)\n * })\n * ```\n *\n * @template {string} Tag\n * @template T\n * @param {{ [K in Tag]: Task.Effect<T> }} source\n * @returns {Task.Effect<Tagged<Tag, T>>}\n */\nexport const listen = function* (source) {\n  /** @type {Task.Fork<void, never, Tagged<Tag, T>>[]} */\n  const forks = []\n  for (const entry of Object.entries(source)) {\n    const [name, effect] = /** @type {[Tag, Task.Effect<T>]} */ (entry)\n    if (effect !== NONE) {\n      forks.push(yield* fork(tag(effect, name)))\n    }\n  }\n\n  yield* group(forks)\n}\n\n/**\n * Takes several tasks and creates an effect of them all.\n *\n * @example\n * ```js\n * Task.effects([\n *    dbRead,\n *    dbWrite\n * ])\n * ```\n *\n * @template {string} Tag\n * @template T\n * @param {Task.Task<T, never>[]} tasks\n * @returns {Task.Effect<T>}\n */\n\nexport const effects = tasks =>\n  tasks.length > 0 ? batch(tasks.map(effect)) : NONE\n\n/**\n * Takes several effects and combines them into a one.\n *\n * @template T\n * @param {Task.Effect<T>[]} effects\n * @returns {Task.Effect<T>}\n */\nexport function* batch(effects) {\n  const forks = []\n  for (const effect of effects) {\n    forks.push(yield* fork(effect))\n  }\n\n  yield* group(forks)\n}\n\n/**\n * @template {string} Tag\n * @template T\n * @typedef {{type: Tag} & {[K in Tag]: T}} Tagged\n */\n/**\n * Tags an effect by boxing each event with an object that has `type` field\n * corresponding to given tag and same named field holding original message\n * e.g. given `nums` effect that produces numbers, `tag(nums, \"inc\")` would\n * create an effect that produces events like `{type:'inc', inc:1}`.\n *\n * @template {string} Tag\n * @template T, M, X\n * @param {Task.Task<T, X, M>} effect\n * @param {Tag} tag\n * @returns {Task.Task<T, X, Tagged<Tag, M>>}\n */\nexport const tag = (effect, tag) =>\n  // @ts-ignore\n  effect === NONE\n    ? NONE\n    : effect instanceof Tagger\n    ? new Tagger([...effect.tags, tag], effect.source)\n    : new Tagger([tag], effect)\n\n/**\n * @template {string} Tag\n * @template Success, Failure, Message\n *\n * @implements {Task.Task<Success, Failure, Tagged<Tag, Message>>}\n * @implements {Task.Controller<Success, Failure, Tagged<Tag, Message>>}\n */\nclass Tagger {\n  /**\n   * @param {Task.Task<Success, Failure, Message>} source\n   * @param {string[]} tags\n   */\n  constructor(tags, source) {\n    this.tags = tags\n    this.source = source\n    /** @type {Task.Controller<Success, Failure, Message>} */\n    this.controller\n  }\n  /* c8 ignore next 3 */\n  [Symbol.iterator]() {\n    if (!this.controller) {\n      this.controller = this.source[Symbol.iterator]()\n    }\n    return this\n  }\n  /**\n   * @param {Task.TaskState<Success, Message>} state\n   * @returns {Task.TaskState<Success, Tagged<Tag, Message>>}\n   */\n  box(state) {\n    if (state.done) {\n      return state\n    } else {\n      switch (state.value) {\n        case SUSPEND:\n        case CURRENT:\n          return /** @type {Task.TaskState<Success, Tagged<Tag, Message>>} */ (\n            state\n          )\n        default: {\n          // Instead of boxing result at each transform step we perform in-place\n          // mutation as we know nothing else is accessing this value.\n          const tagged = /** @type {{ done: false, value: any }} */ (state)\n          let { value } = tagged\n          for (const tag of this.tags) {\n            value = withTag(tag, value)\n          }\n          tagged.value = value\n          return tagged\n        }\n      }\n    }\n  }\n  /**\n   *\n   * @param {Task.Instruction<Message>} instruction\n   */\n  next(instruction) {\n    return this.box(this.controller.next(instruction))\n  }\n  /**\n   *\n   * @param {Failure} error\n   */\n  throw(error) {\n    return this.box(this.controller.throw(error))\n  }\n  /**\n   * @param {Success} value\n   */\n  return(value) {\n    return this.box(this.controller.return(value))\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"TaggedEffect\"\n  }\n}\n\n/**\n * Returns empty `Effect`, that is produces no messages. Kind of like `[]` or\n * `\"\"` but for effects.\n *\n * @type {() => Task.Effect<never>}\n */\nexport const none = () => NONE\n\n/**\n * Takes iterable of tasks and runs them concurrently, returning array of\n * results in an order of tasks (not the order of completion). If any of the\n * tasks fail all the rest are aborted and error is throw into calling task.\n *\n * > This is basically equivalent of `Promise.all` except cancelation logic\n * because tasks unlike promises can be cancelled.\n *\n * @template T, X\n * @param {Iterable<Task.Task<T, X>>} tasks\n * @returns {Task.Task<T[], X>}\n */\nexport const all = function* (tasks) {\n  const self = yield* current()\n\n  /** @type {(id:number) => (value:T) => void} */\n  const succeed = id => value => {\n    delete forks[id]\n    results[id] = value\n    count -= 1\n    if (count === 0) {\n      enqueue(self)\n    }\n  }\n\n  /** @type {(error:X) => void} */\n  const fail = error => {\n    for (const handle of forks) {\n      if (handle) {\n        enqueue(abort(handle, error))\n      }\n    }\n\n    enqueue(abort(self, error))\n  }\n\n  /** @type {Task.Fork<void, never>[]} */\n  let forks = []\n  let count = 0\n  for (const task of tasks) {\n    forks.push(yield* fork(then(task, succeed(count++), fail)))\n  }\n  const results = new Array(count)\n\n  if (count > 0) {\n    yield* suspend()\n  }\n\n  return results\n}\n\n/**\n * @template {string} Tag\n * @template T\n * @param {Tag} tag\n * @param {Task.Message<T>} value\n */\nconst withTag = (tag, value) =>\n  /** @type {Tagged<Tag, T>} */\n  ({ type: tag, [tag]: value })\n\n/**\n * Kind of like promise.then which is handy when you want to extract result\n * from the given task from the outside.\n *\n * @template T, U, X, M\n * @param {Task.Task<T, X, M>} task\n * @param {(value:T) => U} resolve\n * @param {(error:X) => U} reject\n * @returns {Task.Task<U, never, M>}\n */\nexport function* then(task, resolve, reject) {\n  try {\n    return resolve(yield* task)\n  } catch (error) {\n    return reject(/** @type {X} */ (error))\n  }\n}\n\n// Special control instructions recognized by a scheduler.\nconst CURRENT = Symbol(\"current\")\nconst SUSPEND = Symbol(\"suspend\")\n/** @typedef {typeof SUSPEND|typeof CURRENT} Control */\n\n/**\n * @template M\n * @param {Task.Instruction<M>} value\n * @returns {value is M}\n */\nexport const isMessage = value => {\n  switch (value) {\n    case SUSPEND:\n    case CURRENT:\n      return false\n    default:\n      return true\n  }\n}\n\n/**\n * @template M\n * @param {Task.Instruction<M>} value\n * @returns {value is Control}\n */\nexport const isInstruction = value => !isMessage(value)\n\n/**\n * @template T, X, M\n * @implements {Task.TaskGroup<T, X, M>}\n */\nclass Group {\n  /**\n   * @template T, X, M\n   * @param {Task.Controller<T, X, M>|Task.Fork<T, X, M>} member\n   * @returns {Task.Group<T, X, M>}\n   */\n  static of(member) {\n    return (\n      /** @type {{group?:Task.TaskGroup<T, X, M>}} */ (member).group || MAIN\n    )\n  }\n\n  /**\n   * @template T, X, M\n   * @param {(Task.Controller<T, X, M>|Task.Fork<T, X, M>) & {group?:Task.TaskGroup<T, X, M>}} member\n   * @param {Task.TaskGroup<T, X, M>} group\n   */\n  static enqueue(member, group) {\n    member.group = group\n    group.stack.active.push(member)\n  }\n  /**\n   * @param {Task.Controller<T, X, M>} driver\n   * @param {Task.Controller<T, X, M>[]} [active]\n   * @param {Set<Task.Controller<T, X, M>>} [idle]\n   * @param {Task.Stack<T, X, M>} [stack]\n   */\n  constructor(\n    driver,\n    active = [],\n    idle = new Set(),\n    stack = new Stack(active, idle)\n  ) {\n    this.driver = driver\n    this.parent = Group.of(driver)\n    this.stack = stack\n    this.id = ++ID\n  }\n}\n\n/**\n * @template T, X, M\n * @implements {Task.Main<T, X, M>}\n */\nclass Main {\n  constructor() {\n    this.status = IDLE\n    this.stack = new Stack()\n    this.id = /** @type {0} */ (0)\n  }\n}\n\n/**\n * @template T, X, M\n */\nclass Stack {\n  /**\n   * @param {Task.Controller<T, X, M>[]} [active]\n   * @param {Set<Task.Controller<T, X, M>>} [idle]\n   */\n  constructor(active = [], idle = new Set()) {\n    this.active = active\n    this.idle = idle\n  }\n\n  /**\n   *\n   * @param {Task.Stack<unknown, unknown, unknown>} stack\n   * @returns\n   */\n  static size({ active, idle }) {\n    return active.length + idle.size\n  }\n}\n\n/**\n * Starts a main task.\n *\n * @param {Task.Task<void, never>} task\n */\nexport const main = task => enqueue(task[Symbol.iterator]())\n\n/**\n * @template T, X, M\n * @param {Task.Controller<T, X, M>} task\n */\nconst enqueue = task => {\n  let group = Group.of(task)\n  group.stack.active.push(task)\n  group.stack.idle.delete(task)\n\n  // then walk up the group chain and unblock their driver tasks.\n  while (group.parent) {\n    const { idle, active } = group.parent.stack\n    if (idle.has(group.driver)) {\n      idle.delete(group.driver)\n      active.push(group.driver)\n    } else {\n      // if driver was not blocked it must have been unblocked by\n      // other task so stop there.\n      break\n    }\n\n    group = group.parent\n  }\n\n  if (MAIN.status === IDLE) {\n    MAIN.status = ACTIVE\n    while (true) {\n      try {\n        for (const _message of step(MAIN)) {\n        }\n        MAIN.status = IDLE\n        break\n      } catch (_error) {\n        // Top level task may crash and throw an error, but given this is a main\n        // group we do not want to interupt other unrelated tasks, which is why\n        // we discard the error and the task that caused it.\n        MAIN.stack.active.shift()\n      }\n    }\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Controller<T, X, M>} task\n */\nexport const resume = task => enqueue(task)\n\n/**\n * @template T, X, M\n * @param {Task.Group<T, X, M>} group\n */\n\nconst step = function* (group) {\n  const { active } = group.stack\n  let task = active[0]\n  group.stack.idle.delete(task)\n  while (task) {\n    /** @type {Task.TaskState<T, M>} */\n    let state = INIT\n    // Keep processing insturctions until task is done, it send suspend request\n    // or it's has been removed from the active queue.\n    // \u26A0\uFE0F Group changes require extra care so please make sure to understand\n    // the detail here. It occurs when spawned task(s) are joined into a group\n    // which will change the task driver, that is when `task === active[0]` will\n    // became false and need to to drop the task immediately otherwise race\n    // condition will occur due to task been  driven by multiple concurrent\n    // schedulers.\n    loop: while (!state.done && task === active[0]) {\n      const instruction = state.value\n      switch (instruction) {\n        // if task is suspended we add it to the idle list and break the loop\n        // to move to a next task.\n        case SUSPEND:\n          group.stack.idle.add(task)\n          break loop\n        // if task requested a context (which is usually to suspend itself)\n        // pass back a task reference and continue.\n        case CURRENT:\n          state = task.next(task)\n          break\n        default:\n          // otherwise task sent a message which we yield to the driver and\n          // continue\n          state = task.next(\n            yield /** @type {M & Task.Message<M>}*/ (instruction)\n          )\n          break\n      }\n    }\n\n    // If task is complete, or got suspended we move to a next task\n    active.shift()\n    task = active[0]\n    group.stack.idle.delete(task)\n  }\n}\n\n/**\n * Executes given task concurrently with a current task (task that spawned it).\n * Spawned task is detached from the task that spawned it and it can outlive it\n * and / or fail without affecting a task that spawned it. If you need to wait\n * on concurrent task completion consider using `fork` instead which can be\n * later `joined`. If you just want a to block on task execution you can just\n * `yield* work()` directly instead.\n *\n * @param {Task.Task<void, never, never>} task\n * @returns {Task.Task<void, never>}\n */\nexport function* spawn(task) {\n  main(task)\n}\n\n/**\n * Executes given task concurrently with current task (the task that initiated\n * fork). Froked task is detached from the task that created it and it can\n * outlive it and / or fail without affecting it. You do however get a handle\n * for the fork which could be used to `join` the task, in which case `joining`\n * task will block until fork finishes execution.\n *\n * This is also a primary interface for executing tasks from the outside of the\n * task context. Function returns `Fork` which implements `Promise` interface\n * so it could be awaited. Please note that calling `fork` does not really do\n * anything, it lazily starts execution when you either `await fork(work())`\n * from arbitray context or `yield* fork(work())` in anothe task context.\n *\n * @template T, X, M\n * @param {Task.Task<T, X, M>} task\n * @param {Task.ForkOptions} [options]\n * @returns {Task.Fork<T, X, M>}\n */\nexport const fork = (task, options) => new Fork(task, options)\n\n/**\n * Exits task succesfully with a given return value.\n *\n * @template T, M, X\n * @param  {Task.Controller<T, M, X>} handle\n * @param {T} value\n * @returns {Task.Task<void, never>}\n */\nexport const exit = (handle, value) => conclude(handle, { ok: true, value })\n\n/**\n * Terminates task execution execution. Only takes task that produces no\n * result, if your task has non `void` return type you should use `exit` instead.\n *\n * @template M, X\n * @param {Task.Controller<void, X, M>} handle\n */\nexport const terminate = handle =>\n  conclude(handle, { ok: true, value: undefined })\n\n/**\n * Aborts given task with an error. Task error type should match provided error.\n *\n * @template T, M, X\n * @param {Task.Controller<T, X, M>} handle\n * @param {X} [error]\n */\nexport const abort = (handle, error) => conclude(handle, { ok: false, error })\n\n/**\n * Aborts given task with an given error.\n *\n * @template T, M, X\n * @param {Task.Controller<T, X, M>} handle\n * @param {Task.Result<T, X>} result\n * @returns {Task.Task<void, never> & Task.Controller<void, never>}\n */\nfunction* conclude(handle, result) {\n  try {\n    const task = handle\n    const state = result.ok\n      ? task.return(result.value)\n      : task.throw(result.error)\n\n    if (!state.done) {\n      if (state.value === SUSPEND) {\n        const { idle } = Group.of(task).stack\n        idle.add(task)\n      } else {\n        enqueue(task)\n      }\n    }\n  } catch (error) {}\n}\n\n/**\n * Groups multiple forks togather and joins joins them with current task.\n *\n * @template T, X, M\n * @param {Task.Fork<T, X, M>[]} forks\n * @returns {Task.Task<void, X, M>}\n */\nexport function* group(forks) {\n  // Abort eraly if there'se no work todo.\n  if (forks.length === 0) return\n\n  const self = yield* current()\n  /** @type {Task.TaskGroup<T, X, M>} */\n  const group = new Group(self)\n  /** @type {Task.Failure<X>|null} */\n  let failure = null\n\n  for (const fork of forks) {\n    const { result } = fork\n    if (result) {\n      if (!result.ok && !failure) {\n        failure = result\n      }\n      continue\n    }\n    move(fork, group)\n  }\n\n  // Keep work looping until there is nom more work to be done\n  try {\n    if (failure) {\n      throw failure.error\n    }\n\n    while (true) {\n      yield* step(group)\n      if (Stack.size(group.stack) > 0) {\n        yield* suspend()\n      } else {\n        break\n      }\n    }\n  } catch (error) {\n    for (const task of group.stack.active) {\n      yield* abort(task, error)\n    }\n\n    for (const task of group.stack.idle) {\n      yield* abort(task, error)\n      enqueue(task)\n    }\n\n    throw error\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Fork<T, X, M>} fork\n * @param {Task.TaskGroup<T, X, M>} group\n */\nconst move = (fork, group) => {\n  const from = Group.of(fork)\n  if (from !== group) {\n    const { active, idle } = from.stack\n    const target = group.stack\n    fork.group = group\n    // If it is idle just move from one group to the other\n    // and update the group task thinks it belongs to.\n    if (idle.has(fork)) {\n      idle.delete(fork)\n      target.idle.add(fork)\n    } else {\n      const index = active.indexOf(fork)\n      // If task is in the job queue, we move it to a target job queue. Moving\n      // top task in the queue requires extra care so it does not end up\n      // processed by two groups which would lead to race. For that reason\n      // `step` loop checks for group changes on each turn.\n      if (index >= 0) {\n        active.splice(index, 1)\n        target.active.push(fork)\n      }\n      // otherwise task is complete\n    }\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Fork<T, X, M>} fork\n * @returns {Task.Task<T, X, M>}\n */\nexport function* join(fork) {\n  // If fork is still idle activate it.\n  if (fork.status === IDLE) {\n    yield* fork\n  }\n\n  if (!fork.result) {\n    yield* group([fork])\n  }\n\n  const result = /** @type {Task.Result<T, X>} */ (fork.result)\n  if (result.ok) {\n    return result.value\n  } else {\n    throw result.error\n  }\n}\n\n/**\n * @template T, X\n * @implements {Task.Future<T, X>}\n */\nclass Future {\n  /**\n   * @param {Task.StateHandler<T, X>} handler\n   */\n  constructor(handler) {\n    this.handler = handler\n    /**\n     * @abstract\n     * @type {Task.Result<T, X>|void}\n     */\n    this.result\n  }\n  /**\n   * @type {Promise<T>}\n   */\n  get promise() {\n    const { result } = this\n    const promise =\n      result == null\n        ? new Promise((succeed, fail) => {\n            this.handler.onsuccess = succeed\n            this.handler.onfailure = fail\n          })\n        : result.ok\n        ? Promise.resolve(result.value)\n        : Promise.reject(result.error)\n    Object.defineProperty(this, \"promise\", { value: promise })\n    return promise\n  }\n\n  /**\n   * @template U, [E=never]\n   * @param {((value:T) => U | PromiseLike<U>)|undefined|null} [onresolve]\n   * @param {((error:X) => E|PromiseLike<E>)|undefined|null} [onreject]\n   * @returns {Promise<U|E>}\n   */\n  then(onresolve, onreject) {\n    return this.activate().promise.then(onresolve, onreject)\n  }\n  /**\n   * @template [U=never]\n   * @param {(error:X) => U} onreject\n   */\n  catch(onreject) {\n    return /** @type {Task.Future<T|U, never>} */ (\n      this.activate().promise.catch(onreject)\n    )\n  }\n  /**\n   * @param {() => void} onfinally\n   * @returns {Task.Future<T, X>}\n   */\n  finally(onfinally) {\n    return /** @type {Task.Future<T, X>} */ (\n      this.activate().promise.finally(onfinally)\n    )\n  }\n  /**\n   * @abstract\n   */\n  /* c8 ignore next 3 */\n  activate() {\n    return this\n  }\n}\n\n/**\n * @template T, X, M\n * @implements {Task.Fork<T, X, M>}\n * @implements {Task.Controller<T, X, M>}\n * @implements {Task.Task<Task.Fork<T, X, M>, never>}\n * @implements {Task.Future<T, X>}\n * @extends {Future<T, X>}\n */\nclass Fork extends Future {\n  /**\n   * @param {Task.Task<T, X, M>} task\n   * @param {Task.ForkOptions} [options]\n   * @param {Task.StateHandler<T, X>} [handler]\n   * @param {Task.TaskState<T, M>} [state]\n   */\n  constructor(task, options = BLANK, handler = {}, state = INIT) {\n    super(handler)\n    this.id = ++ID\n    this.name = options.name || \"\"\n    /** @type {Task.Task<T, X, M>} */\n    this.task = task\n    this.state = state\n    this.status = IDLE\n    /** @type {Task.Result<T, X>} */\n    this.result\n    this.handler = handler\n\n    /** @type {Task.Controller<T, X, M>} */\n    this.controller\n  }\n\n  *resume() {\n    resume(this)\n  }\n\n  /**\n   * @returns {Task.Task<T, X, M>}\n   */\n  join() {\n    return join(this)\n  }\n\n  /**\n   * @param {X} error\n   */\n  abort(error) {\n    return abort(this, error)\n  }\n  /**\n   * @param {T} value\n   */\n  exit(value) {\n    return exit(this, value)\n  }\n  get [Symbol.toStringTag]() {\n    return \"Fork\"\n  }\n\n  /**\n   * @returns {Task.Controller<Task.Fork<T, X, M>, never, never>}\n   */\n  *[Symbol.iterator]() {\n    return this.activate()\n  }\n\n  activate() {\n    this.controller = this.task[Symbol.iterator]()\n    this.status = ACTIVE\n    enqueue(this)\n    return this\n  }\n\n  /**\n   * @private\n   * @param {any} error\n   * @returns {never}\n   */\n  panic(error) {\n    this.result = { ok: false, error }\n    this.status = FINISHED\n    const { handler } = this\n    if (handler.onfailure) {\n      handler.onfailure(error)\n    }\n\n    throw error\n  }\n\n  /**\n   * @private\n   * @param {Task.TaskState<T, M>} state\n   */\n  step(state) {\n    this.state = state\n    if (state.done) {\n      this.result = { ok: true, value: state.value }\n      this.status = FINISHED\n      const { handler } = this\n      if (handler.onsuccess) {\n        handler.onsuccess(state.value)\n      }\n    }\n\n    return state\n  }\n\n  /**\n   * @param {unknown} value\n   */\n  next(value) {\n    try {\n      return this.step(this.controller.next(value))\n    } catch (error) {\n      return this.panic(error)\n    }\n  }\n  /**\n   * @param {T} value\n   */\n  return(value) {\n    try {\n      return this.step(this.controller.return(value))\n    } catch (error) {\n      return this.panic(error)\n    }\n  }\n  /**\n   * @param {X} error\n   */\n  throw(error) {\n    try {\n      return this.step(this.controller.throw(error))\n    } catch (error) {\n      return this.panic(error)\n    }\n  }\n}\n\n/**\n * @template M\n * @param {Task.Effect<M>} init\n * @param {(message:M) => Task.Effect<M>} next\n * @returns {Task.Task<void, never, never>}\n */\nexport const loop = function* (init, next) {\n  /** @type {Task.Controller<void, never, M>} */\n  const controller = yield* current()\n  const group = new Group(controller)\n  Group.enqueue(init[Symbol.iterator](), group)\n\n  while (true) {\n    for (const message of step(group)) {\n      Group.enqueue(next(message)[Symbol.iterator](), group)\n    }\n\n    if (Stack.size(group.stack) > 0) {\n      yield* suspend()\n    } else {\n      break\n    }\n  }\n}\n\nlet ID = 0\n/** @type {Task.Status} */\nconst IDLE = \"idle\"\nconst ACTIVE = \"active\"\nconst FINISHED = \"finished\"\n/** @type {Task.TaskState<any, any>} */\nconst INIT = { done: false, value: CURRENT }\n\nconst BLANK = {}\n\n/** @type {Task.Effect<never>} */\nconst NONE = (function* none() {})()\n\n/** @type {Task.Main<any, any, any>} */\nconst MAIN = new Main()\n", "function Indexed() {}\n\nObject.defineProperties(Indexed, {\n  prototype: {\n    value: new Proxy(Object.prototype, {\n      /**\n       * @param {object} target\n       * @param {PropertyKey} property\n       * @param {{get(key:PropertyKey): any}} receiver\n       */\n      get(target, property, receiver) {\n        return typeof property === \"symbol\"\n          ? Reflect.get(target, property, receiver)\n          : receiver.get(property)\n      },\n    }),\n  },\n})\n\nexport { Indexed }\n", "import { Indexed } from \"./indexed.js\"\n\n/**\n * @typedef {{\n * readonly byteOffset: number\n * readonly byteLength: number\n * readonly segments: Uint8Array[]\n * }} BufferSlice\n */\n\n/** @typedef {BufferView} View */\nexport const empty = () => new BufferView()\n\n/**\n * @param {Uint8Array[]} segments\n * @param {number} byteOffset\n * @param {number} byteLength\n */\nexport const create = (\n  segments,\n  byteOffset = 0,\n  byteLength = totalByteLength(segments)\n) => new BufferView(segments, byteOffset, byteLength)\n\n/**\n *\n * @param {Uint8Array[]} segments\n * @returns\n */\nconst totalByteLength = segments => {\n  let byteLength = 0\n  for (const segment of segments) {\n    byteLength += segment.byteLength\n  }\n  return byteLength\n}\n\n/**\n * @param {BufferSlice} buffer\n * @param {number} [startOffset]\n * @param {number} [endOffset]\n */\nexport const slice = (\n  buffer,\n  startOffset = 0,\n  endOffset = buffer.byteLength\n) => {\n  const segments = []\n  const start = startOffset < 0 ? buffer.byteLength - startOffset : startOffset\n  const end = endOffset < 0 ? buffer.byteLength - endOffset : endOffset\n\n  // If start at 0 offset and end is past buffer range it is effectively\n  // as same buffer.\n  if (start === 0 && end >= buffer.byteLength) {\n    return buffer\n  }\n\n  // If range is not within the current buffer just create an empty slice.\n  if (start > end || start > buffer.byteLength || end <= 0) {\n    return empty()\n  }\n\n  let byteLength = 0\n  let offset = 0\n  for (const segment of buffer.segments) {\n    const nextOffset = offset + segment.byteLength\n    // Have not found a start yet\n    if (byteLength === 0) {\n      // If end offset is within the current segment we know start is also,\n      // because it preceeds the end & we had not found start yet.\n      // In such case we create a view with only single segment of bytes\n      // in the range.\n      if (end <= nextOffset) {\n        const range = segment.subarray(start - offset, end - offset)\n        segments.push(range)\n        byteLength = range.byteLength\n        break\n      }\n      // If start offeset falls with in current range (but not the end)\n      // we save matching buffer slice and update byteLength.\n      else if (start < nextOffset) {\n        const range =\n          start === offset ? segment : segment.subarray(start - offset)\n        segments.push(range)\n        byteLength = range.byteLength\n      }\n    }\n    // Otherwise we already started collecting matching segments and are looking\n    // for the end end of the slice. If it is with in the current range capture\n    // the segment and create a view.\n    else if (end <= nextOffset) {\n      const range =\n        end === nextOffset ? segment : segment.subarray(0, end - offset)\n      segments.push(range)\n      byteLength += range.byteLength\n      break\n    }\n    // If end is past current range we just save the segment and continue.\n    else {\n      segments.push(segment)\n      byteLength += segment.byteLength\n    }\n\n    offset = nextOffset\n  }\n\n  return new BufferView(segments, buffer.byteOffset + start, byteLength)\n}\n\n/**\n * @param {BufferSlice} buffer\n * @param {Uint8Array} part\n */\n\nexport const push = (buffer, part) => {\n  if (part.byteLength > 0) {\n    // We MUTATE here but that is ok because it is out of bound for the passed\n    // buffer view so there will be no visible side effects.\n    buffer.segments.push(part)\n    return new BufferView(\n      buffer.segments,\n      buffer.byteOffset,\n      buffer.byteLength + part.byteLength\n    )\n  } else {\n    return buffer\n  }\n}\n\n/**\n * @param {BufferSlice} buffer\n * @param {number} n\n */\nexport const get = (buffer, n) => {\n  if (n < buffer.byteLength) {\n    let offset = 0\n    for (const segment of buffer.segments) {\n      if (n < offset + segment.byteLength) {\n        return segment[n - offset]\n      } else {\n        offset += segment.byteLength\n      }\n    }\n  }\n\n  return undefined\n}\n\n/**\n *\n * @param {BufferView} buffer\n * @param {Uint8Array} target\n * @param {number} byteOffset\n */\nexport const copyTo = (buffer, target, byteOffset) => {\n  let offset = byteOffset\n  for (const segment of buffer.segments) {\n    target.set(segment, offset)\n    offset += segment.byteLength\n  }\n\n  return target\n}\n\n/**\n *\n * @param {BufferView} buffer\n */\nexport function* iterate(buffer) {\n  for (const part of buffer.segments) {\n    yield* part\n  }\n}\n\n/**\n * @extends {Indexed<number>}\n */\nclass BufferView extends Indexed {\n  /**\n   * @param {Uint8Array[]} segments\n   * @param {number} byteOffset\n   * @param {number} byteLength\n   */\n  constructor(segments = [], byteOffset = 0, byteLength = 0) {\n    super()\n    /** @hide */\n    this.segments = segments\n    /** @readonly */\n    this.byteLength = byteLength\n    /** @readonly */\n    this.length = byteLength\n    /** @readonly */\n    this.byteOffset = byteOffset\n  }\n\n  [Symbol.iterator]() {\n    return iterate(this)\n  }\n\n  /**\n   * @param {number} [start]\n   * @param {number} [end]\n   */\n  slice(start, end) {\n    return /** @type {BufferView} */ (slice(this, start, end))\n  }\n\n  /**\n   * @param {number} [start]\n   * @param {number} [end]\n   */\n  subarray(start, end) {\n    return /** @type {BufferView} */ (slice(this, start, end))\n  }\n\n  /**\n   *\n   * @param {Uint8Array} bytes\n   */\n  push(bytes) {\n    return /** @type {BufferView} */ (push(this, bytes))\n  }\n\n  /**\n   * @param {number} n\n   */\n  get(n) {\n    return get(this, n)\n  }\n\n  /**\n   *\n   * @param {Uint8Array} target\n   * @param {number} offset\n   */\n  copyTo(target, offset) {\n    return copyTo(this, target, offset)\n  }\n}\n", "/**\n * @param {string} reason\n * @returns {never}\n */\nexport const panic = reason => {\n  throw new Error(reason)\n}\n\n/**\n * @param {{ raw: readonly string[] | ArrayLike<string>}} template\n * @param {never} [subject]\n * @param {unknown[]} substitutions\n * @returns {never}\n */\nexport const unreachable = (template, subject, ...substitutions) =>\n  panic(String.raw(template, JSON.stringify(subject), ...substitutions))\n\nexport const EMPTY_BUFFER = new Uint8Array(0)\n/** @type {any[]} */\nexport const EMPTY = []\n", "import * as BufferQueue from \"./chunker/buffer.js\"\nimport * as Chunker from \"./chunker/api.js\"\nimport { EMPTY } from \"../writer/util.js\"\nexport * from \"./chunker/api.js\"\n\n/**\n * @typedef {{\n * chunker: Chunker.Chunker\n * }} Config\n *\n *\n * @typedef {{\n * buffer: BufferQueue.View\n * config: Config\n * }} Chunker\n *\n * @typedef {Chunker & {chunks: Chunker.Chunk[]}} ChunkerWithChunks\n */\n\n/**\n * @param {Config} config\n * @returns {Chunker}\n */\nexport const open = config => ({\n  config,\n  buffer: BufferQueue.empty(),\n})\n\n/**\n * @param {Chunker} state\n * @param {Uint8Array} bytes\n * @returns {ChunkerWithChunks}\n */\nexport const write = (state, bytes) =>\n  bytes.byteLength > 0\n    ? split(state.config, state.buffer.push(bytes), false)\n    : { ...state, chunks: EMPTY }\n\n/**\n * @param {Chunker} state\n * @returns {ChunkerWithChunks}\n */\nexport const close = state => split(state.config, state.buffer, true)\n\n/**\n * @param {Config} config\n * @param {BufferQueue.View} buffer\n * @param {boolean} end\n * @returns {ChunkerWithChunks}\n */\n\nexport const split = (config, buffer, end) => {\n  const chunker = config.chunker\n  const chunks = []\n\n  let offset = 0\n  for (const size of chunker.cut(chunker.context, buffer, end)) {\n    // We may be splitting empty buffer in which case there will be no chunks\n    // in it so we make sure that we do not emit empty buffer.\n    if (size > 0) {\n      const chunk = buffer.subarray(offset, offset + size)\n      chunks.push(chunk)\n      offset += size\n    }\n  }\n\n  return { config, chunks, buffer: buffer.subarray(offset) }\n}\n", "import * as Layout from \"./api.js\"\nimport * as Queue from \"./queue/api.js\"\nexport * from \"./queue/api.js\"\n\n/**\n * @returns {Queue.Result}\n */\nexport const empty = () => ({\n  mutable: false,\n  needs: {},\n  nodes: {},\n  links: {},\n  linked: [],\n})\n\nexport const mutable = () => ({\n  mutable: true,\n  needs: {},\n  nodes: {},\n  links: {},\n  linked: EMPTY,\n})\n\n/**\n * Adds given layout node to the layout queue. If links for all of the node\n * children are available correspnoding linked node is added (removing links\n * form the queue) otherwise `nood` is added to the wait queue until all the\n * needed links are added.\n *\n *\n * @param {Layout.Branch} node\n * @param {Queue.Queue} queue\n * @returns {Queue.Result}\n */\nexport const addNode = (node, queue) => addNodes([node], queue)\n\n/**\n *\n * @param {Layout.Branch[]} newNodes\n * @param {Queue.Queue} input\n * @returns {Queue.Result}\n */\nexport const addNodes = (newNodes, input) => {\n  let queue = patch(input, {})\n  for (const node of newNodes) {\n    const { ready, has, wants } = collect(node.children, queue.links)\n    // If node isn't waiting on any of the children it's ready to be linked\n    // so we add linked node diretly.\n    if (wants.length === 0) {\n      queue = patch(queue, {\n        links: assign(undefined, has),\n        linked: [{ id: node.id, links: ready }],\n      })\n    } else {\n      queue = patch(queue, {\n        needs: assign(node.id, wants),\n        nodes: {\n          [node.id]: {\n            children: node.children,\n            count: wants.length,\n          },\n        },\n      })\n    }\n  }\n\n  return queue\n}\n\n/**\n * Adds link to the queue. If queue contains a node that needs this link it gets\n * updated. Either it's gets linked (when it was blocked only on this link) or\n * it's want could is reduced. If no node needed this link it just gets stored\n * for the future node that will need it.\n *\n *\n * @param {Queue.NodeID} id\n * @param {Queue.Link} link\n * @param {Queue.Queue} queue\n * @returns {Queue.Result}\n */\n\nexport const addLink = (id, link, queue) => {\n  const nodeID = queue.needs[id]\n  const node = queue.nodes[nodeID]\n  // We have node than needs this link.\n  if (node != null) {\n    // This is the only link it needed so we materialize the node and remove\n    // links and needs associated with it.\n    if (node.count === 1) {\n      const { ready, has } = collect(node.children, {\n        ...queue.links,\n        [id]: link,\n      })\n\n      return patch(queue, {\n        needs: { [id]: undefined },\n        links: assign(undefined, has),\n        nodes: { [nodeID]: undefined },\n        linked: [{ id: nodeID, links: ready }],\n      })\n    }\n    // If node needs more links we just reduce a want count and remove this\n    // need.\n    else {\n      return patch(queue, {\n        needs: { [id]: undefined },\n        links: { [id]: link },\n        nodes: {\n          [nodeID]: {\n            ...node,\n            count: node.count - 1,\n          },\n        },\n      })\n    }\n  }\n  // If we have no one waiting for this link just add it to the queue\n  else {\n    return patch(queue, {\n      links: { [id]: link },\n    })\n  }\n}\n\n/**\n *\n * @param {Queue.Queue} queue\n * @param {Queue.Delta} delta\n */\n\nconst patch = (queue, { needs, nodes, links, linked }) => {\n  const result = queue.mutable ? queue : { ...queue }\n  const original = queue.mutable ? BLANK : undefined\n\n  if (needs) {\n    result.needs = patchDict(queue.needs, needs, original)\n  }\n\n  if (nodes) {\n    result.nodes = patchDict(queue.nodes, nodes, original)\n  }\n\n  if (links) {\n    result.links = patchDict(queue.links, links, original)\n  }\n\n  result.linked = linked\n    ? append(queue.linked || EMPTY, linked, EMPTY)\n    : queue.linked || []\n\n  return /** @type {Queue.Result} */ (result)\n}\n\n/**\n * @template V\n * @template {PropertyKey} K\n * @param {V} value\n * @param {K[]} keys\n * @returns {Record<K, V>}\n */\n\nconst assign = (value, keys) => {\n  const delta = /** @type {Record<K, V>} */ ({})\n  for (const key of keys) {\n    delta[key] = value\n  }\n\n  return delta\n}\n\n/**\n * @template {PropertyKey} K\n * @template V\n * @param {Record<K, V>} target\n *\n * @param {Record<K, V|void>} delta\n * @param {Record<K, V>} original\n * @returns {Record<K, V>}\n */\n\nconst patchDict = (target, delta, original = target) => {\n  const result = target === original ? { ...target } : target\n  for (const entry of Object.entries(delta)) {\n    const [id, value] = /** @type {[K, V|void]} */ (entry)\n    if (value == null) {\n      delete result[id]\n    } else {\n      result[id] = value\n    }\n  }\n\n  return result\n}\n/**\n *\n * @param {Iterable<[Queue.NodeID, Queue.Link]>} entries\n * @param {Queue.Queue} queue\n * @returns {Queue.Queue}\n */\nexport const addLinks = (entries, queue) => {\n  for (const [id, link] of entries) {\n    queue = addLink(id, link, queue)\n  }\n  return queue\n}\n\n/**\n * @param {Queue.Queue} queue\n */\n\nexport const isEmpty = queue =>\n  Object.keys(queue.nodes).length === 0 && Object.keys(queue.links).length === 0\n\n/**\n * @template T\n * @param {T[]} target\n * @param {T[]} items\n * @param {T[]} original\n */\nconst append = (target, items, original = target) => {\n  if (target === original) {\n    return [...target, ...items]\n  } else {\n    for (const item of items) {\n      target.push(item)\n    }\n    return target\n  }\n}\n\n/**\n * @param {Queue.NodeID[]} children\n * @param {Record<Queue.NodeID, Queue.Link>} source\n * @returns {{has:Queue.NodeID[], wants:Queue.NodeID[], ready:Queue.Link[]}}\n */\nconst collect = (children, source) => {\n  const has = []\n  const wants = []\n  const ready = []\n  for (const child of children) {\n    const link = source[child]\n    if (link) {\n      has.push(child)\n      ready.push(link)\n    } else {\n      wants.push(child)\n    }\n  }\n\n  return { has, wants, ready }\n}\n\nconst EMPTY = /** @type {never[]} */ (Object.freeze([]))\n\nconst BLANK = /** @type {Record<never, never>} */ (Object.freeze({}))\n", "import * as Task from \"actor\"\nimport * as API from \"./api.js\"\nimport * as Layout from \"./layout/api.js\"\nimport * as UnixFS from \"../codec.js\"\nimport * as Chunker from \"./chunker.js\"\nimport { EMPTY_BUFFER, panic, unreachable } from \"../writer/util.js\"\nimport * as Queue from \"./layout/queue.js\"\n\n/**\n * @template Layout\n * @typedef {{\n * readonly status: 'open'\n * readonly metadata: UnixFS.Metadata\n * readonly config: API.EncoderSettings<Layout>\n * readonly writer: API.BlockWriter\n * chunker: Chunker.Chunker\n * layout: Layout\n * nodeQueue: Queue.Queue\n * }} Open\n */\n/**\n * @template Layout\n * @typedef {{\n * readonly status: 'closed'\n * readonly metadata: UnixFS.Metadata\n * readonly config: API.EncoderSettings<Layout>\n * readonly writer: API.BlockWriter\n * readonly rootID: Layout.NodeID\n * readonly end?: Task.Fork<void, never>\n * chunker?: null\n * layout?: null\n * nodeQueue: Queue.Queue\n * }} Closed\n */\n/**\n * @template Layout\n * @typedef {{\n * readonly status: 'linked'\n * readonly metadata: UnixFS.Metadata\n * readonly config: API.EncoderSettings<Layout>\n * readonly writer: API.BlockWriter\n * readonly link: Layout.Link\n * chunker?: null\n * layout?: null\n * nodeQueue: Queue.Queue\n * }} Linked\n */\n\n/**\n * @template Layout\n * @typedef {Open<Layout>|Closed<Layout>|Linked<Layout>} State\n */\n\n/**\n * @template {object} Layout\n * @typedef {{\n * state: State<Layout>\n * effect: Task.Effect<Message>\n * }} Update\n */\n/**\n * @typedef {never\n * |{type:\"write\", bytes:Uint8Array}\n * |{type:\"link\", link:API.EncodedFile}\n * |{type:\"block\"}\n * |{type: \"close\"}\n * |{type: \"end\"}\n * } Message\n */\n\n/**\n * @template Layout\n * @param {Message} message\n * @param {State<Layout>} state\n */\nexport const update = (message, state) => {\n  switch (message.type) {\n    case \"write\":\n      return write(state, message.bytes)\n    case \"link\":\n      return link(state, message.link)\n    /* c8 ignore next 2 */\n    case \"block\":\n      return { state, effect: Task.none() }\n    case \"close\":\n      return close(state)\n    case \"end\":\n      return { state, effect: Task.none() }\n    default:\n      return unreachable`File Writer got unknown message ${message}`\n  }\n}\n\n/**\n * @template Layout\n * @param {API.BlockWriter} writer\n * @param {UnixFS.Metadata} metadata\n * @param {API.EncoderSettings} config\n * @returns {State<Layout>}\n */\nexport const init = (writer, metadata, config) => {\n  return {\n    status: \"open\",\n    metadata,\n    config,\n    writer,\n    chunker: Chunker.open({ chunker: config.chunker }),\n    layout: config.fileLayout.open(),\n    // Note: Writing in large slices e.g. 1GiB at a time creates large queues\n    // with around `16353` items. Immutable version ends up copying it every\n    // time state of the queue changes, which introduces significant overhead.\n    // To avoid this overhead we use mutable implementation which is API\n    // compatible but makes in place updates.\n    // TODO: We should consider using Persistent bit-partitioned vector tries\n    // instead of arrays which would provide immutable interface with neglegable\n    // overhead.\n    // @see https://github.com/Gozala/vectrie\n    nodeQueue: Queue.mutable(),\n  }\n}\n/**\n * @template Layout\n * @param {State<Layout>} state\n * @param {Uint8Array} bytes\n * @returns {Update<Layout>}\n */\nexport const write = (state, bytes) => {\n  if (state.status === \"open\") {\n    // Chunk up provided bytes\n    const { chunks, ...chunker } = Chunker.write(state.chunker, bytes)\n\n    // Pass chunks to layout engine to produce nodes\n    const { nodes, leaves, layout } = state.config.fileLayout.write(\n      state.layout,\n      chunks\n    )\n\n    const { linked, ...nodeQueue } = Queue.addNodes(nodes, state.nodeQueue)\n\n    // Create leaf encode tasks for all new leaves\n    const tasks = [\n      ...encodeLeaves(leaves, state.config),\n      ...encodeBranches(linked, state.config),\n    ]\n\n    return {\n      state: {\n        ...state,\n        chunker,\n        layout,\n        nodeQueue,\n      },\n      effect: Task.listen({\n        link: Task.effects(tasks),\n      }),\n    }\n  } else {\n    return panic(\"Unable to perform write on closed file\")\n  }\n}\n\n/**\n * @template Layout\n * @param {State<Layout>} state\n * @param {API.EncodedFile} entry\n * @returns {Update<Layout>}\n */\nexport const link = (state, { id, link, block }) => {\n  let { linked, ...nodeQueue } = Queue.addLink(id, link, state.nodeQueue)\n\n  const tasks = encodeBranches(linked, state.config)\n\n  /** @type {State<Layout>} */\n  const newState =\n    state.status === \"closed\" && id === state.rootID\n      ? {\n          ...state,\n          status: \"linked\",\n          link,\n          nodeQueue,\n        }\n      : { ...state, nodeQueue }\n\n  // If we just linked a root and there is a **suspended** \"end\" task we create\n  // a task to resume it.\n  const end =\n    state.status === \"closed\" && id === state.rootID && state.end\n      ? state.end.resume()\n      : Task.none()\n\n  return {\n    state: newState,\n    effect: Task.listen({\n      link: Task.effects(tasks),\n      block: writeBlock(state.writer, block),\n      end,\n    }),\n  }\n}\n\n/**\n * @template Layout\n * @param {State<Layout>} state\n * @returns {Update<Layout>}\n */\nexport const close = state => {\n  if (state.status === \"open\") {\n    const { chunks } = Chunker.close(state.chunker)\n    const { layout, ...write } = state.config.fileLayout.write(\n      state.layout,\n      chunks\n    )\n\n    const { root, ...close } = state.config.fileLayout.close(\n      layout,\n      state.metadata\n    )\n\n    const [nodes, leaves] = isLeafNode(root)\n      ? [\n          [...write.nodes, ...close.nodes],\n          [...write.leaves, ...close.leaves, root],\n        ]\n      : [\n          [...write.nodes, ...close.nodes, root],\n          [...write.leaves, ...close.leaves],\n        ]\n\n    const { linked, ...nodeQueue } = Queue.addNodes(nodes, state.nodeQueue)\n\n    const tasks = [\n      ...encodeLeaves(leaves, state.config),\n      ...encodeBranches(linked, state.config),\n    ]\n\n    // We want to keep run loop around until root node is linked. To\n    // accomplish this we fork a task that suspends itself, which we will\n    // resume when root is linked (see link function).\n    // Below we join this forked task in our effect, this way effect is not\n    // complete until task forked task is, which will do once we link the\n    // root.\n    const fork = Task.fork(Task.suspend())\n\n    return {\n      state: {\n        ...state,\n        chunker: null,\n        layout: null,\n        rootID: root.id,\n        status: \"closed\",\n        end: fork,\n        nodeQueue,\n      },\n      effect: Task.listen({\n        link: Task.effects(tasks),\n        end: Task.join(fork),\n      }),\n    }\n  } else {\n    return { state, effect: Task.none() }\n  }\n}\n\n/**\n * Creates concurrent leaf encode tasks. Each one will have an ID corresponding\n * to index in the queue.\n *\n * @param {Layout.Leaf[]} leaves\n * @param {API.EncoderSettings} config\n */\nconst encodeLeaves = (leaves, config) =>\n  leaves.map(leaf => encodeLeaf(config, leaf, config.fileChunkEncoder))\n\n/**\n * @param {API.EncoderSettings} config\n * @param {Layout.Leaf} leaf\n * @param {API.FileChunkEncoder} encoder\n * @returns {Task.Task<API.EncodedFile, never>}\n */\nconst encodeLeaf = function* ({ hasher, linker }, { id, content }, encoder) {\n  const bytes = encoder.encode(content ? asUint8Array(content) : EMPTY_BUFFER)\n  const hash = yield* Task.wait(hasher.digest(bytes))\n  const cid = linker.createLink(encoder.code, hash)\n\n  const block = { cid, bytes }\n  const link = /** @type {UnixFS.FileLink} */ ({\n    cid,\n    contentByteLength: content ? content.byteLength : 0,\n    dagByteLength: bytes.byteLength,\n  })\n\n  return { id, block, link }\n}\n\n/**\n * @param {Queue.LinkedNode[]} nodes\n * @param {API.EncoderSettings} config\n */\nconst encodeBranches = (nodes, config) =>\n  nodes.map(node => encodeBranch(config, node))\n\n/**\n * @template Layout\n * @param {API.EncoderSettings<Layout>} config\n * @param {Queue.LinkedNode} node\n * @param {UnixFS.Metadata} [metadata]\n * @returns {Task.Task<API.EncodedFile>}\n */\nexport const encodeBranch = function* (config, { id, links }, metadata) {\n  const bytes = config.fileEncoder.encode({\n    type: UnixFS.NodeType.File,\n    layout: \"advanced\",\n    parts: links,\n    metadata,\n  })\n  const hash = yield* Task.wait(Promise.resolve(config.hasher.digest(bytes)))\n  const cid = config.linker.createLink(config.fileEncoder.code, hash)\n  const block = { bytes, cid }\n  const link = /** @type {UnixFS.FileLink} */ ({\n    cid,\n    contentByteLength: UnixFS.cumulativeContentByteLength(links),\n    dagByteLength: UnixFS.cumulativeDagByteLength(bytes, links),\n  })\n\n  return { id, block, link }\n}\n\n/**\n * @param {API.BlockWriter} writer\n * @param {UnixFS.Block} block\n * @returns {Task.Task<void, never>}\n */\n\nexport const writeBlock = function* (writer, block) {\n  if ((writer.desiredSize || 0) <= 0) {\n    yield* Task.wait(writer.ready)\n  }\n  writer.write(block)\n}\n\n/**\n *\n * @param {Uint8Array|Chunker.Chunk} buffer\n * @returns\n */\n\nconst asUint8Array = buffer =>\n  buffer instanceof Uint8Array\n    ? buffer\n    : buffer.copyTo(new Uint8Array(buffer.byteLength), 0)\n\n/**\n * @param {Layout.Node} node\n * @returns {node is Layout.Leaf}\n */\nconst isLeafNode = node => node.children == null\n", "import * as API from \"./api.js\"\n\nexport const name = \"fixed\"\n/**\n * @typedef {Object} FixedSize\n * @property {number} maxChunkSize\n */\n\n/** @type {FixedSize} */\nexport const context = {\n  maxChunkSize: 262144,\n}\n\nexport const type = \"Stateless\"\n\n/**\n * @param {number} maxChunkSize\n * @returns {API.StatelessChunker<FixedSize>}\n */\nexport const withMaxChunkSize = maxChunkSize => ({\n  type: \"Stateless\",\n  context: { maxChunkSize },\n  name,\n  cut,\n})\n\n/**\n * @param {FixedSize} maxChunkSize\n * @param {API.Chunk} buffer\n * @param {boolean} end\n * @returns {number[]}\n */\nexport const cut = ({ maxChunkSize }, { byteLength }, end) => {\n  // number of fixed size chunks that would fit\n  const n = (byteLength / maxChunkSize) | 0\n  const chunks = new Array(n).fill(maxChunkSize)\n  const lastChunkSize = end ? byteLength - n * maxChunkSize : 0\n  if (lastChunkSize > 0) {\n    chunks.push(lastChunkSize)\n  }\n  return chunks\n}\n", "import * as Layout from \"./api.js\"\nimport * as Chunker from \"./../chunker/api.js\"\n\n/**\n * Type representing a state of the balanced tree. First row hold leaves coming\n * into a builder, once number of leaves in the stack reaches `maxChildren` they\n * are moved into `RootNode` instance which is pushed into the next row of nodes.\n * If next row now contains `maxChildren` nodes from there are again moved into\n * a new `RootNode` and pushed into next row etc...\n *\n * For illustration let's assume we have `maxChildren: 3`, after 3 leafs were\n * added tree will have following layout\n *\n * ```\n *           (root1)\n *              |\n *    ----------------------\n *    |         |          |\n * (leaf1)   (leaf2)    (leaf3)\n * ```\n *\n * Which in our model before flushing is represented as follows:\n *\n * ```js\n * {\n *    width: 3\n *    leafIndex: [leaf1, leaf2, leaf3]\n *    nodeIndex: []\n *    nodes: []\n * }\n * ```\n *\n * After flushing 3 leaves (which is width) are moved into a `RootNode` that\n * is added to `nodes` array (and returned so that caller can create a block).\n * Additionally position of the added node is captured in the `index` at an\n * appropriate depth `0` (that is because we don't count leaves into depth).\n *\n * ```js\n * {\n *    width: 3\n *    leafIndex: []\n *    nodeIndex: [[0]]\n *    nodes: [new RootNode([leaf1, leaf2, leaf3])]\n * }\n * ```\n *\n * Increasing number of leaves to 10 would produce following tree layout\n *\n *```\n *                                                         (root7)\n *                                                           |\n *                                    ------------------------------------------\n *                                    |                                        |\n *                                  (root4)                                  (root6)\n *                                    |                                        |\n *              ----------------------------------------------                 |\n *              |                     |                       |                |\n *           (root1)               (root2)                 (root3)          (root5)\n *              |                     |                       |                |\n *    -----------------       --------|--------       -----------------        |\n *    |       |       |       |       |       |       |       |       |        |\n * (leaf1) (leaf2) (leaf3) (leaf4) (leaf5) (leaf6) (leaf7) (leaf8) (leaf9) (leaf10)\n * ```\n *\n * Which in our model will look as follows (note we do not have root5 - root7\n * in model because they are build once width is reached or once builder is\n * closed)\n *\n * ```js\n * {\n *    width: 3\n *    leafIndex: [leaf10]\n *    nodeIndex: [\n *      [0, 1, 2], // [r1, r2, r3]\n *      [3]        // [r4]\n *     ]\n *    nodes: [\n *      new Node([leaf1, leaf2, leaf3]), // r1\n *      new Node([leaf4, leaf5, leaf6]), // r2\n *      new Node([leaf7, leaf8, leaf9]), // r3\n *      new Node([ // r4\n *         new Node([leaf1, leaf2, leaf3]), // r1\n *         new Node([leaf4, leaf5, leaf6]), // r2\n *         new Node([leaf7, leaf8, leaf9]), // r3\n *      ])\n *    ]\n * }\n * ```\n *\n * @typedef {{\n * width: number\n * head: Chunker.Chunk | null\n * leafIndex: number[]\n * nodeIndex: number[][]\n * lastID: number\n * }} Balanced\n */\n\nclass Node {\n  /**\n   *\n   * @param {number} id\n   * @param {number[]} children\n   * @param {Layout.Metadata} [metadata]\n   */\n  constructor(id, children, metadata) {\n    this.id = id\n    this.children = children\n    this.metadata = metadata\n  }\n}\n\n/**\n * @typedef Options\n * @property {number} width - Max children per node.\n *\n * @param {number} width\n * @returns {Layout.LayoutEngine<Balanced>}\n */\nexport const withWidth = width => ({\n  open: () => open({ width }),\n  write,\n  close,\n})\n\nexport const defaults = { width: 174 }\n\n/**\n * @param {Options} options\n * @returns {Balanced}\n */\nexport const open = ({ width } = defaults) => ({\n  width,\n\n  head: null,\n  leafIndex: [],\n  nodeIndex: [],\n  lastID: 0,\n})\n\n/**\n *\n * @param {Balanced} layout\n * @param {Chunker.Chunk[]} chunks\n * @returns {Layout.WriteResult<Balanced>}\n */\nexport const write = (layout, chunks) => {\n  if (chunks.length === 0) {\n    return { layout, nodes: EMPTY, leaves: EMPTY }\n  } else {\n    let { lastID } = layout\n    // We need to hold on to the first chunk until we either get a second chunk\n    // (at which point we know our layout will have branches) or until we close\n    // (at which point our layout will be single leaf or node depneding on\n    // metadata)\n    const [head, slices] = layout.head\n      ? // If we had a head we have more then two chunks (we already checked\n        // chunks weren't empty) so we process head along with other chunks.\n        [null, (chunks.unshift(layout.head), chunks)]\n      : // If we have no head no leaves and got only one chunk we have to save it\n      // until we can decide what to do with it.\n      chunks.length === 1 && layout.leafIndex.length === 0\n      ? [chunks[0], EMPTY]\n      : // Otherwise we have no head but got enough chunks to know we'll have a\n        // node.\n        [null, chunks]\n\n    if (slices.length === 0) {\n      return { layout: { ...layout, head }, nodes: EMPTY, leaves: EMPTY }\n    } else {\n      const leafIndex = [...layout.leafIndex]\n      const leaves = []\n      for (const chunk of slices) {\n        const leaf = { id: ++lastID, content: chunk }\n        leaves.push(leaf)\n        leafIndex.push(leaf.id)\n      }\n\n      if (leafIndex.length >= layout.width) {\n        return flush({ ...layout, leafIndex, head, lastID }, leaves)\n      } else {\n        return {\n          layout: { ...layout, head, leafIndex, lastID },\n          leaves,\n          nodes: EMPTY,\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {Balanced} state\n * @param {Layout.Leaf[]} leaves\n * @param {Layout.Branch[]} [nodes]\n * @param {boolean} [close]\n * @returns {Layout.WriteResult<Balanced>}\n */\nexport const flush = (state, leaves = EMPTY, nodes = [], close = false) => {\n  let { lastID } = state\n  const nodeIndex = state.nodeIndex.map(row => [...row])\n  const leafIndex = [...state.leafIndex]\n  const { width } = state\n\n  // Move leaves into nodes\n  while (leafIndex.length >= width || (leafIndex.length > 0 && close)) {\n    grow(nodeIndex, 1)\n    const node = new Node(++lastID, leafIndex.splice(0, width))\n    nodeIndex[0].push(node.id)\n    nodes.push(node)\n  }\n\n  let depth = 0\n  while (depth < nodeIndex.length) {\n    const row = nodeIndex[depth]\n    depth++\n\n    while (\n      row.length >= width ||\n      (row.length > 0 && close && depth < nodeIndex.length)\n    ) {\n      const node = new Node(++lastID, row.splice(0, width))\n      grow(nodeIndex, depth + 1)\n      nodeIndex[depth].push(node.id)\n      nodes.push(node)\n    }\n  }\n\n  return { layout: { ...state, lastID, leafIndex, nodeIndex }, leaves, nodes }\n}\n\n/**\n * @param {Balanced} layout\n * @param {Layout.Metadata} [metadata]\n * @returns {Layout.CloseResult}\n */\nexport const close = (layout, metadata) => {\n  const state = layout\n  if (layout.head) {\n    return {\n      root: { id: 1, content: layout.head, metadata },\n      leaves: EMPTY,\n      nodes: EMPTY,\n    }\n  } else if (layout.leafIndex.length === 0) {\n    return {\n      root: { id: 1, metadata },\n      leaves: EMPTY,\n      nodes: EMPTY,\n    }\n  } else {\n    // Flush with width 1 so all the items will be propagate up the tree\n    // and height of `depth-1` so we propagate nodes all but from the top\n    // most level\n    const { nodes, layout } = flush(state, EMPTY, [], true)\n\n    const { nodeIndex } = layout\n    const height = nodeIndex.length - 1\n\n    const top = nodeIndex[height]\n    if (top.length === 1) {\n      const root = nodes[nodes.length - 1]\n      nodes.length = nodes.length - 1\n      return { root, nodes, leaves: EMPTY }\n    } else {\n      const root = new Node(layout.lastID + 1, top, metadata)\n      return { root, nodes, leaves: EMPTY }\n    }\n  }\n}\n\n/**\n * @template T\n * @param {T[][]} index\n * @param {number} length\n */\nconst grow = (index, length) => {\n  while (index.length < length) {\n    index.push([])\n  }\n  return index\n}\n\n/** @type {never[]} */\nconst EMPTY = []\n", "import * as API from \"./file/api.js\"\nimport * as UnixFS from \"./codec.js\"\nimport * as Writer from \"./file/writer.js\"\nimport * as Task from \"actor\"\nimport { panic } from \"./writer/util.js\"\nimport * as FixedSize from \"./file/chunker/fixed.js\"\nimport { sha256 } from \"multiformats/hashes/sha2\"\nimport { CID } from \"multiformats/cid\"\nimport * as Balanced from \"./file/layout/balanced.js\"\n\nexport * from \"./file/api.js\"\n\n/**\n * @returns {API.EncoderSettings}\n */\nexport const defaults = () => ({\n  chunker: FixedSize,\n  fileChunkEncoder: UnixFSLeaf,\n  smallFileEncoder: UnixFSLeaf,\n  fileEncoder: UnixFS,\n  fileLayout: Balanced.withWidth(174),\n  hasher: sha256,\n  linker: { createLink: CID.createV1 },\n})\n\n/**\n * @template {unknown} Layout\n * @param {Partial<API.EncoderSettings<Layout>>} config\n * @returns {API.EncoderSettings<Layout>}\n */\nexport const configure = config => ({\n  ...defaults(),\n  ...config,\n})\n\nexport const UnixFSLeaf = {\n  code: UnixFS.code,\n  name: UnixFS.name,\n  encode: UnixFS.encodeFileChunk,\n}\n\nexport const UnixFSRawLeaf = {\n  code: UnixFS.code,\n  name: UnixFS.name,\n  encode: UnixFS.encodeRaw,\n}\n\n/**\n * @template Layout\n * @param {API.Options<Layout>} options\n * @returns {API.View<Layout>}\n */\nexport const create = ({ writer, metadata = {}, settings = defaults() }) =>\n  new FileWriterView(Writer.init(writer, metadata, configure(settings)))\n\n/**\n * @template T\n * @param {API.View<T>} view\n * @param {Uint8Array} bytes\n * @return {Promise<API.View<T>>}\n */\n\nexport const write = async (view, bytes) => {\n  await perform(view, Task.send({ type: \"write\", bytes }))\n  return view\n}\n\n/**\n * @template T\n * @param {API.View<T>} view\n * @param {API.CloseOptions} options\n */\nexport const close = async (\n  view,\n  { releaseLock = false, closeWriter = false } = {}\n) => {\n  await perform(view, Task.send({ type: \"close\" }))\n  const { state } = view\n  if (state.status === \"linked\") {\n    if (closeWriter) {\n      await view.state.writer.close()\n    } else if (releaseLock) {\n      view.state.writer.releaseLock()\n    }\n    return state.link\n    /* c8 ignore next 5 */\n  } else {\n    panic(\n      `Expected writer to be in 'linked' state after close, but it is in \"${state.status}\" instead`\n    )\n  }\n}\n\n/**\n * @template T\n * @param {API.View<T>} view\n * @param {Task.Effect<Writer.Message>} effect\n */\nconst perform = (view, effect) =>\n  Task.fork(\n    Task.loop(effect, message => {\n      const { state, effect } = Writer.update(message, view.state)\n      view.state = state\n      return effect\n    })\n  )\n\n/**\n * @template Layout\n * @implements {API.View<Layout>}\n */\nclass FileWriterView {\n  /**\n   * @param {Writer.State<Layout>} state\n   */\n  constructor(state) {\n    this.state = state\n  }\n  get writer() {\n    return this.state.writer\n  }\n  get settings() {\n    return this.state.config\n  }\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {Promise<API.View<Layout>>}\n   */\n  write(bytes) {\n    return write(this, bytes)\n  }\n  /**\n   * @param {API.CloseOptions} [options]\n   * @returns {Promise<UnixFS.FileLink>}\n   */\n  close(options) {\n    return close(this, options)\n  }\n}\n", "import * as API from \"./directory/api.js\"\nimport * as File from \"./file.js\"\nimport * as UnixFS from \"./codec.js\"\nexport * from \"./directory/api.js\"\n\nexport const configure = File.configure\nexport const defaults = File.defaults\n\n/**\n * @template [Layout=unknown]\n * @param {API.Options<Layout>} config\n * @returns {API.View<Layout>}\n */\nexport const create = ({ writer, settings = defaults(), metadata = {} }) =>\n  new DirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new Map(),\n    closed: false,\n  })\n\n/**\n * @template {unknown} L\n * @template {{ state: API.State<L> }} View\n * @param {View} view\n * @param {string} name\n * @param {API.EntryLink} link\n * @param {API.WriteOptions} options\n */\nexport const set = (view, name, link, { overwrite = false } = {}) => {\n  const writable = asWritable(view.state)\n  if (name.includes(\"/\")) {\n    throw new Error(\n      `Directory entry name \"${name}\" contains forbidden \"/\" character`\n    )\n  }\n  if (!overwrite && writable.entries.has(name)) {\n    throw new Error(`Directory already contains entry with name \"${name}\"`)\n  } else {\n    writable.entries.set(name, link)\n    return view\n  }\n}\n\n/**\n * @template {unknown} L\n * @template {{ state: API.State<L> }} View\n * @param {View} view\n * @param {string} name\n */\nexport const remove = (view, name) => {\n  const writer = asWritable(view.state)\n  writer.entries.delete(name)\n  return view\n}\n\n/**\n * @template {API.State} Writer\n * @param {Writer} writer\n * @returns {Writer}\n */\nconst asWritable = writer => {\n  if (!writer.closed) {\n    return writer\n  } else {\n    throw new Error(\n      `Can not change written directory, but you can .fork() and make changes to it`\n    )\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {{ state: API.State<Layout> }} view\n * @param {API.CloseOptions} options\n * @returns {Promise<UnixFS.DirectoryLink>}\n */\nexport const close = async (\n  view,\n  { closeWriter = false, releaseLock = false } = {}\n) => {\n  const { writer, settings, metadata } = asWritable(view.state)\n  view.state.closed = true\n  const entries = [...links(view)]\n  const node = UnixFS.createFlatDirectory(entries, metadata)\n  const bytes = UnixFS.encodeDirectory(node)\n  const digest = await settings.hasher.digest(bytes)\n  /** @type {UnixFS.Link<UnixFS.Directory>} */\n  const cid = settings.linker.createLink(UnixFS.code, digest)\n\n  // we make sure that writer has some capacity for this write. If it\n  // does not we await.\n  if ((writer.desiredSize || 0) <= 0) {\n    await writer.ready\n  }\n  // once writer has some capacity we write a block, however we do not\n  // await completion as we don't care when it's taken off the stream.\n  writer.write({ cid, bytes })\n\n  if (closeWriter) {\n    await writer.close()\n  } else if (releaseLock) {\n    writer.releaseLock()\n  }\n\n  return {\n    cid,\n    dagByteLength: UnixFS.cumulativeDagByteLength(bytes, entries),\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {{ state: API.State<Layout> }} view\n * @returns {IterableIterator<UnixFS.DirectoryEntryLink>}\n */\nexport const links = function* ({ state }) {\n  for (const [name, { dagByteLength, cid }] of state.entries) {\n    yield /** @type {UnixFS.DirectoryEntryLink} */ ({\n      name,\n      dagByteLength,\n      cid,\n    })\n  }\n}\n\n/**\n * @template L1, L2\n * @param {API.View<L1>} state\n * @param {Partial<API.Options<L1|L2>>} options\n * @returns {API.View<L1|L2>}\n */\nexport const fork = (\n  { state },\n  {\n    writer = state.writer,\n    metadata = state.metadata,\n    settings = state.settings,\n  } = {}\n) =>\n  new DirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new Map(state.entries.entries()),\n    closed: false,\n  })\n\n/**\n * @template [Layout=unknown]\n * @implements {API.View<Layout>}\n */\nclass DirectoryWriter {\n  /**\n   * @param {API.State<Layout>} state\n   */\n  constructor(state) {\n    this.state = state\n  }\n  get writer() {\n    return this.state.writer\n  }\n  get settings() {\n    return this.state.settings\n  }\n\n  links() {\n    return links(this)\n  }\n\n  /**\n   * @param {string} name\n   * @param {UnixFS.FileLink | UnixFS.DirectoryLink} link\n   * @param {API.WriteOptions} [options]\n   */\n\n  set(name, link, options) {\n    return set(this, name, link, options)\n  }\n\n  /**\n   * @param {string} name\n   */\n  remove(name) {\n    return remove(this, name)\n  }\n\n  /**\n   * @template L\n   * @param {Partial<API.Options<L>>} [options]\n   * @returns {API.View<Layout|L>}\n   */\n  fork(options) {\n    return fork(this, options)\n  }\n\n  /**\n   * @param {API.CloseOptions} [options]\n   * @returns {Promise<UnixFS.DirectoryLink>}\n   */\n  close(options) {\n    return close(this, options)\n  }\n\n  entries() {\n    return this.state.entries.entries()\n  }\n  /**\n   * @param {string} name\n   */\n  has(name) {\n    return this.state.entries.has(name)\n  }\n  get size() {\n    return this.state.entries.size\n  }\n}\n", "import * as API from \"./api.js\"\n\nexport { API }\n\n/**\n * @param {API.Uint32} size\n */\nexport const empty = (size = 32) => {\n  // We could support < 32, but it seems impractical and would negatively affect\n  // performance as we would have to do extra bound checks.\n  if (size !== 32) {\n    throw new Error(`Uint32 BitField does not support size: ${size}`)\n  }\n\n  return 0\n}\n\n/**\n * @param  {API.Uint32[]} bits\n * @param {API.Uint32} [size]\n */\nexport const from = (bits, size) => {\n  let bitfield = empty(size)\n  for (const bit of bits) {\n    bitfield = set(bitfield, bit)\n  }\n  return bitfield\n}\n\n/**\n * @param {API.Uint32} _bitField\n */\nexport const size = _bitField => 32\n\n/**\n * Reads out 5 bits at the given bit offset.\n *\n * @param {API.Uint32} bitField - Bitfield in Uint32 representation.\n * @param {API.Uint32} index - Index with-in `bitField` to read bits from.\n * @returns {API.Uint32}\n */\nconst mask = (bitField, index) => (bitField >>> index) & 0b11111\n\n/**\n * Creates mask that can be used to check a bit in nodes bitmap for the give\n * key (hash) at given depth.\n *\n * @param {API.Uint32} bitField - Key hash as 32 bit integer.\n * @param {API.Uint32} index - Index with-in the 32bit bitfield\n */\nconst offset = (bitField, index) => 1 << mask(bitField, index)\n\n/**\n * Maps numbers [0, 31] to powers of two. Creates mask that can be used\n * to check a bit in nodes bitmap for the give key (hash) at given depth.\n *\n * @param {API.Uint32} bitField - Key hash as 32 bit integer.\n * @param {API.Uint32} index - Index with-in the 32bit bitfield\n */\nexport const popcount = (bitField, index = 31) =>\n  bitCount(bitField & (offset(index, 0) - 1))\n\n/**\n * @param {API.Uint32} bitField\n * @param {API.Uint32} index\n */\nexport const set = (bitField, index) => bitField | (1 << index)\n\n/**\n * @param {API.Uint32} bitField\n * @param {API.Uint32} index\n */\nexport const unset = (bitField, index) => bitField & (0xff ^ (1 << index))\n\n/**\n * @param {API.Uint32} bitField\n * @param {API.Uint32} index\n */\nexport const get = (bitField, index) => ((bitField >> index) & 0x1) !== 0\n\n/**\n * Counts the number of bits set in n\n * @param {API.Uint32} bitField\n */\nexport const bitCount = bitField => {\n  const n1 = bitField - ((bitField >> 1) & 0x55555555)\n  const n2 = (n1 & 0x33333333) + ((n1 >> 2) & 0x33333333)\n  const n3 = ((n2 + (n2 >> 4)) & 0xf0f0f0f) * 0x1010101\n  return n3 >> 24\n}\n\n/**\n * @param {API.Uint32} left\n * @param {API.Uint32} right\n * @returns {API.Uint32}\n */\nexport const and = (left, right) => left & right\n\n/**\n * @param {API.Uint32} left\n * @param {API.Uint32} right\n * @returns {API.Uint32}\n */\nexport const or = (left, right) => left | right\n\n/**\n * Counts the number of bits set in n\n * @param {API.Uint32} bitField\n * @returns {Uint8Array}\n */\nexport const toBytes = bitField =>\n  Uint8Array.of(\n    (bitField >> 24) & 0b1111_1111,\n    (bitField >> 16) & 0b1111_1111,\n    (bitField >> 8) & 0b1111_1111,\n    bitField & 0b1111_1111\n  )\n\n/**\n *\n * @param {Uint8Array} bytes\n * @returns {API.Uint32}\n */\nexport const fromBytes = bytes => {\n  if (bytes.length !== 4) {\n    throw new Error(`Expected 4 bytes instead got ${bytes.length}`)\n  }\n  return (bytes[0] << 24) + (bytes[1] << 16) + (bytes[2] << 8) + bytes[3]\n}\n", "export {}\n", "import * as API from \"./api.js\"\n// @ts-expect-error - has no types\nimport murmur from \"murmurhash3js-revisited\"\n\nconst utf8 = new TextEncoder()\n\n/**\n * @typedef {(bytes:Uint8Array) => API.Uint32} Hasher\n * @type {Hasher}\n */\nexport const hash32 = murmur.x64.hash126\n\n/**\n * @param {Partial<API.Options<API.Uint32>>} options\n * @returns {API.Path<API.Uint32>}\n */\n/* c8 ignore next 45 */\nexport const configure = ({ bitWidth = 5, hash = hash32 }) => {\n  const hashSize = 4\n  if (bitWidth > hashSize * 8) {\n    throw new RangeError(\n      `Can not use bitWidth ${bitWidth} which exceeds the hashSize ${hashSize}`\n    )\n  }\n\n  if (hashSize * 8 > 32) {\n    throw new RangeError(\n      `Can not use hashSize ${hashSize} as it can not be encoded in Uint32`\n    )\n  }\n\n  // Mask for reading `bitWidth` number of bits from the end.\n  const mask = 0xffffffff >>> (32 - bitWidth)\n\n  /**\n   * Determines bit position for the path entry at the given `depth`.\n   * ```js\n   * const key = hash(\"result\") // 0b00011010010110010101111100110010\n   * // Which is following path (in reverse as we read from the right)\n   * // 10010/11001/10111/10010/00101/01101/00000 -> [ 18, 25, 23, 18, 5, 13, 0 ]\n   * at(key, 0) // 0b10010 -> 18\n   * at(key, 1) // 0b11001 -> 25\n   * at(key, 2) // 0b10111 -> 23\n   * at(key, 3) // 0b10010 -> 18\n   * at(key, 4) // 0b00101 -> 5\n   * at(key, 5) // 0b01101 -> 13\n   * at(key, 6) // 0b00000 -> 0\n   * ```\n   *\n   * @param {API.Uint32} path\n   * @param {number} depth\n   */\n  const at = (path, depth) => (path >>> (depth * bitWidth)) & mask\n\n  /**\n   * @param {string} key\n   * @returns {API.Uint32}\n   */\n  const from = key => hash(utf8.encode(key))\n\n  return { at, from, size: Math.ceil((hashSize * 8) / bitWidth) }\n}\n", "import * as API from \"./api.js\"\nexport * from \"./api.js\"\nimport * as BitField from \"./bitfield/Uint32.js\"\nimport * as Path from \"./path/Uint32.js\"\nexport { API }\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @implements {API.BitmapIndexedNode<T, K, C>}\n */\nclass BitmapIndexedNode {\n  /**\n   * @param {API.Edit|null} edit\n   * @param {ReturnType<C['BitField']['empty']>} datamap\n   * @param {ReturnType<C['BitField']['empty']>} nodemap\n   * @param {API.Children<T, K, C>} children\n   * @param {C} config\n   */\n  constructor(edit, datamap, nodemap, children, config) {\n    this.edit = edit\n    this.config = config\n    this.datamap = datamap\n    this.nodemap = nodemap\n    this.children = children\n  }\n\n  get nodeArity() {\n    return this.config.BitField.popcount(this.nodemap)\n  }\n  get dataArity() {\n    return this.config.BitField.popcount(this.datamap)\n  }\n\n  /**\n   * @returns {API.BitmapIndexedNode<T, K, C>}\n   */\n  /* c8 ignore next 3 */\n  empty() {\n    return create(this.config)\n  }\n\n  /**\n   * @template X\n   * @param {API.Uint32} depth\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K} key\n   * @param {X} notFound\n   * @returns {T|X}\n   */\n\n  lookup(depth, path, key, notFound) {\n    return lookup(this, depth, path, key, notFound)\n  }\n\n  /**\n   * @template {string} R\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} depth\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K|R} key\n   * @param {T} value\n   * @param {{value:boolean}} addedLeaf\n   * @returns {API.BitmapIndexedNode<T, K | R, C>}\n   */\n  associate(edit, depth, path, key, value, addedLeaf) {\n    return associate(this, edit, depth, path, key, value, addedLeaf)\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} depth\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K} key\n   * @param {{value:boolean}} removedLeaf\n   * @returns {API.BitmapIndexedNode<T, K, C>}\n   */\n  dissociate(edit, depth, path, key, removedLeaf) {\n    return dissociate(this, edit, depth, path, key, removedLeaf)\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @returns {API.BitmapIndexedNode<T, K, C>}\n   */\n  fork(edit = null) {\n    return fork(this, edit)\n  }\n\n  /**\n   * @returns {IterableIterator<[K, T]>}\n   */\n  entries() {\n    return entries(this)\n  }\n\n  /**\n   * @returns {IterableIterator<K>}\n   */\n  keys() {\n    return keys(this)\n  }\n\n  /**\n   * @returns {IterableIterator<T>}\n   */\n  values() {\n    return values(this)\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @implements {API.HashCollisionNode<T, K, C>}\n */\nclass HashCollisionNode {\n  /**\n   * @param {API.Edit|null} edit\n   * @param {number} count\n   * @param {API.CollisionEntries<T, K>} children\n   * @param {C} config\n   */\n  /* c8 ignore next 12 */\n  constructor(edit, count, children, config) {\n    this.edit = edit\n    this.count = count\n    this.children = children\n    this.config = config\n  }\n  get nodeArity() {\n    return /** @type {0} */ (0)\n  }\n  get dataArity() {\n    return this.count\n  }\n\n  /**\n   * @template X\n   * @param {API.Uint32} _shift\n   * @param {unknown} _path\n   * @param {K} key\n   * @param {X} notFound\n   * @returns {T|X}\n   */\n  /* c8 ignore next 3 */\n  lookup(_shift, _path, key, notFound) {\n    return lookupCollision(this, key, notFound)\n  }\n\n  /**\n   * @template {string} R\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} _shift\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K|R} key\n   * @param {T} value\n   * @param {{value:boolean}} addedLeaf\n   * @returns {API.HashCollisionNode<T, K | R, C>}\n   */\n  /* c8 ignore next 3 */\n  associate(edit, _shift, path, key, value, addedLeaf) {\n    return associateCollision(this, edit, path, key, value, addedLeaf)\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} _shift\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K} key\n   * @param {{value:boolean}} removedLeaf\n   * @returns {API.Node<T, K, C>}\n   */\n  /* c8 ignore next 3 */\n  dissociate(edit, _shift, path, key, removedLeaf) {\n    return dissociateCollision(this, edit, path, key, removedLeaf)\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @returns {this}\n   */\n  /* c8 ignore next 3 */\n  fork(edit = null) {\n    return /** @type {this} */ (forkCollision(this, edit))\n  }\n\n  /**\n   * @returns {IterableIterator<[K, T]>}\n   */\n  /* c8 ignore next 3 */\n  entries() {\n    return entries(this)\n  }\n\n  /**\n   * @returns {IterableIterator<K>}\n   */\n  /* c8 ignore next 3 */\n  keys() {\n    return keys(this)\n  }\n\n  /**\n   * @returns {IterableIterator<T>}\n   */\n  /* c8 ignore next 3 */\n  values() {\n    return values(this)\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @template X\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {K} name\n * @param {X} notFound\n * @returns {T|X}\n */\n/* c8 ignore next 8 */\nexport const lookupCollision = (node, name, notFound) => {\n  const { children: entries, count } = node\n  // find where entry with this name belongs\n  const n = findHashCollisionNodeIndex(entries, count, name)\n  // if entry name at this index matches given name return the value otherwise\n  // return `notFound` as we have no such entry.\n  return entries[n] === name ? /** @type {T} */ (entries[n + 1]) : notFound\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @template {string} R\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {ReturnType<C['Path']['from']>} key\n * @param {K|R} name\n * @param {T} value\n * @param {{value:boolean}} addedLeaf\n * @returns {API.HashCollisionNode<T, K | R, C>}\n */\n/* c8 ignore next 26 */\nexport const associateCollision = (node, edit, key, name, value, addedLeaf) => {\n  const { children, count } = node\n\n  const index = findHashCollisionNodeIndex(children, count, name)\n  // If entry at this index has a different name we fork the node and\n  // add a new entry.\n  if (children[index] !== name) {\n    const newNode = node.fork(edit)\n    addedLeaf.value = true\n    newNode.count += 1\n    newNode.children.splice(index, key, value)\n    return newNode\n  }\n  // If name is the same but value is not we fork the node and update\n  // the value\n  else if (children[index + 1] !== value) {\n    const newNode = node.fork(edit)\n    newNode.children[index + 1] = value\n    return newNode\n  }\n  // If we got this far entry with this exact name and value is already\n  // present making this a noop, so we return this node back.\n  else {\n    return node\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {ReturnType<C['Path']['from']>} hash\n * @param {K} name\n * @param {{value:boolean}} removedLeaf\n * @returns {API.Node<T, K, C>}\n */\n/* c8 ignore next 37 */\nexport const dissociateCollision = (node, edit, hash, name, removedLeaf) => {\n  const { children: entries, count, config } = node\n  const index = findHashCollisionNodeIndex(entries, count, name)\n  // If there is no entry with a the given name this is noop so we just\n  // return back this node.\n  if (entries[index] !== name) {\n    return node\n  } else {\n    removedLeaf.value = true\n    // If conflict contained only two entries removing one of them would\n    // leave us with no conflict which is why we create a new node with a\n    // an entry other than one that would correspond provided name\n    if (count === 2) {\n      const offset = index === 0 ? 2 : 0\n      return /** @type {API.BitmapIndexedNode<T, K, C>} */ (\n        associate(\n          create(config),\n          edit,\n          0,\n          hash,\n          /** @type {K} */ (entries[offset]),\n          /** @type {T} */ (entries[offset + 1]),\n          removedLeaf\n        )\n      )\n    }\n    // otherwise we got this far we have more than two colliding entries in\n    // which case we simply remove one corresponding to given `name`.\n    //\n    else {\n      const newNode = node.fork(edit)\n      newNode.children.splice(index, 2)\n      newNode.count -= 1\n      return newNode\n    }\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @returns {API.HashCollisionNode<T, K, C>}\n */\n/* c8 ignore next 12 */\nexport const forkCollision = (node, edit = null) => {\n  if (canEdit(node.edit, edit)) {\n    return node\n  } else {\n    return new HashCollisionNode(\n      edit,\n      node.count,\n      /** @type {API.CollisionEntries<T, K>} */ (node.children.slice()),\n      node.config\n    )\n  }\n}\n\n/**\n * Finds the index inside collision entries where given `key` belongs, which is\n * index where `key <= entries[index]` is `true`. If no index satisfies this\n * constraint index will be `entries.length` indicating that key belongs in the\n * last position.\n *\n * @template T\n * @template {string} K\n * @param {API.CollisionEntries<T, K>} entries\n * @param {number} count\n * @param {K} key\n */\n/* c8 ignore next 8 */\nconst findHashCollisionNodeIndex = (entries, count, key) => {\n  let index = 0\n  // increase index until we find a index where key <= entries[index]\n  while (index < count && entries[index] > key) {\n    index += 2\n  }\n  return index\n}\n\nconst defaultConfig = { bitWidth: 32, BitField, Path }\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Edit|null} [edit]\n * @param {C} config\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const create = (config, edit = null) =>\n  new BitmapIndexedNode(\n    edit,\n    config.BitField.empty(Math.pow(2, config.bitWidth)),\n    config.BitField.empty(Math.pow(2, config.bitWidth)),\n    /** @type {API.Children<T, K, C>} */ ([]),\n    config\n  )\n\n/**\n * @template T, U\n * @template {string} K\n * @param {API.BitmapIndexedNode<T, K>} node\n * @param {K} key\n * @param {U} notFound\n */\nexport const get = (node, key, notFound) =>\n  lookup(node, 0, node.config.Path.from(key), key, notFound)\n\n/**\n * @template T, U\n * @template {string} K\n * @template Bits, BitMap\n * @param {API.BitmapIndexedNode<T, K, API.Config<Bits, BitMap>>} node\n * @param {API.Uint32} depth\n * @param {Bits} path\n * @param {K} key\n * @param {U} notFound\n * @returns {T|U}\n */\nexport const lookup = (node, depth, path, key, notFound) => {\n  const { datamap, nodemap, config } = node\n  const { Path, BitField } = config\n  const offset = Path.at(path, depth)\n\n  // If bit is set in the data bitmap we have some key, value under the\n  // matching hash segment.\n  if (BitField.get(datamap, offset)) {\n    const index = BitField.popcount(datamap, offset)\n    // If key matches actual key in the map we found the the value\n    // otherwise we did not.\n    if (keyAt(node, index) === key) {\n      return valueAt(node, index)\n    } else {\n      return notFound\n    }\n  }\n  // If bit is set in the node bitmapt we have a node under the\n  // matching hash segment.\n  else if (BitField.get(nodemap, offset)) {\n    // Resolve node and continue lookup within it.\n    const child = resolveNode(node, offset)\n    return child.lookup(depth + 1, path, key, notFound)\n  }\n  // If we have neither node nor key-pair for this hash segment\n  // we return notFound.\n  else {\n    return notFound\n  }\n}\n\n/**\n * @template T, U\n * @template {string} K\n * @template {string} R\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {R} key\n * @param {T} value\n * @param {{ value: boolean }} addedLeaf\n * @returns {API.BitmapIndexedNode<T, K|R, C>}\n */\nexport const set = (node, edit, key, value, addedLeaf) =>\n  associate(node, edit, 0, node.config.Path.from(key), key, value, addedLeaf)\n\n/**\n * @template T\n * @template {string} K\n * @template {string} R\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {API.Uint32} depth\n * @param {ReturnType<C['Path']['from']>} path\n * @param {K|R} key\n * @param {T} value\n * @param {{value:boolean}} addedLeaf\n * @returns {API.BitmapIndexedNode<T, K | R, C>}\n */\nexport const associate = (node, edit, depth, path, key, value, addedLeaf) => {\n  const { datamap, nodemap, config } = node\n  const { Path, BitField } = config\n  const offset = Path.at(path, depth)\n  // If bit is set in the data bitmap we have some key, value under the\n  // matching hash segment.\n  if (BitField.get(datamap, offset)) {\n    const index = BitField.popcount(datamap, offset)\n    const found = keyAt(node, index)\n    // If we have entry with given name and value is the same return node\n    // as is, otherwise fork node and set the value.\n    if (key === found) {\n      return valueAt(node, index) === value\n        ? node\n        : forkAndSet(node, edit, index, value)\n    }\n    // Otherwise we need to create a branch to contain current key, value and\n    // one been passed.\n    else {\n      const branch = mergeTwoLeaves(\n        config,\n        edit,\n        depth + 1,\n        Path.from(found),\n        found,\n        valueAt(node, index),\n        path,\n        key,\n        value\n      )\n      addedLeaf.value = true\n\n      return migrateLeafToBranch(node, edit, offset, branch)\n    }\n  }\n  // If bit is set in the node bitmap we have a branch under the current\n  // hash slice.\n  else if (BitField.get(nodemap, offset)) {\n    const child = resolveNode(node, offset)\n    const newChild = child.associate(\n      edit,\n      depth + 1,\n      path,\n      key,\n      value,\n      addedLeaf\n    )\n\n    if (child === newChild) {\n      return node\n    } else {\n      return copyAndSetChild(node, edit, offset, newChild)\n    }\n  }\n  // If we have neither node nor a key-value for this hash segment. We copy\n  // current children and add new key-value pair\n  else {\n    const index = BitField.popcount(datamap, offset)\n    addedLeaf.value = true\n\n    /** @type {API.BitmapIndexedNode<T, K|R, C>} */\n    const newNode = node.fork(edit)\n\n    // Capture new entry in the data bitmap\n    newNode.datamap = BitField.set(datamap, offset)\n    newNode.children.splice(keyPosition(index), 0, key, value)\n    return newNode\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {K} key\n * @param {{ value: boolean }} removedLeaf\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nconst remove = (node, edit, key, removedLeaf) =>\n  dissociate(node, edit, 0, node.config.Path.from(key), key, removedLeaf)\n\nexport { remove as delete }\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} source\n * @param {API.Edit|null} edit\n * @param {API.Uint32} depth\n * @param {ReturnType<C['Path']['from']>} path\n * @param {K} key\n * @param {{value:boolean}} removedLeaf\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const dissociate = (source, edit, depth, path, key, removedLeaf) => {\n  const { datamap, nodemap, config } = source\n  const { BitField, Path } = config\n  const offset = Path.at(path, depth)\n  // If bit is set in the data bitmap we have an entry under the\n  // matching hash segment.\n  if (BitField.get(datamap, offset)) {\n    const index = BitField.popcount(datamap, offset)\n    // If key at a given index matches given `name` we fork a node and remove\n    // the entry\n    if (key === keyAt(source, index)) {\n      removedLeaf.value = true\n      const node = fork(source, edit)\n      // Update the bitmap\n      node.datamap = BitField.unset(source.datamap, offset)\n      // remove the child\n      node.children.splice(keyPosition(index), 2)\n      return node\n    }\n    // otherwise we don't have such entry so we return node back as is.\n    else {\n      return source\n    }\n  }\n  // If bit is set in the node bitmapt we have a node under the\n  // matching hash segment.\n  else if (BitField.get(nodemap, offset)) {\n    const node = resolveNode(source, offset)\n    const child = node.dissociate(edit, depth + 1, path, key, removedLeaf)\n    // if child has a single element we need to canonicalize\n    if (hasSingleLeaf(child)) {\n      // if source has a single child, we collapse and return the child\n      // otherwise we inline the child.\n      return hasSingleNode(source)\n        ? child\n        : inlineChild(source, edit, offset, child)\n    } else if (node === child) {\n      return source\n    } else {\n      return copyAndSetChild(source, edit, offset, child)\n    }\n  }\n  // If we have neither node nor a key-value for this hash segment this is a\n  // noop.\n  else {\n    return source\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {IterableIterator<[K, T]>}\n */\nexport const entries = function* ({ children }) {\n  let offset = 0\n  const count = children.length\n  while (offset < count) {\n    const key = children[offset]\n    if (typeof key === \"string\") {\n      offset += 1\n      const value = children[offset]\n      yield /** @type {[K, T]} */ ([key, value])\n      offset += 1\n    } else {\n      break\n    }\n  }\n\n  while (offset < count) {\n    const node = /** @type {API.BitmapIndexedNode<T, K, C>} */ (\n      children[offset]\n    )\n    yield* node.entries()\n    offset += 1\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const fork = (node, edit) => {\n  if (canEdit(node.edit, edit)) {\n    return node\n  } else {\n    const newNode = new BitmapIndexedNode(\n      edit,\n      node.datamap,\n      node.nodemap,\n      node.children.slice(),\n      node.config\n    )\n    return newNode\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {IterableIterator<K>}\n */\nexport const keys = function* ({ children }) {\n  let offset = 0\n  const count = children.length\n  while (offset < count) {\n    const key = children[offset]\n    if (typeof key === \"string\") {\n      yield /** @type {K} */ (key)\n      offset += 2\n    } else {\n      break\n    }\n  }\n\n  while (offset < count) {\n    const node = /** @type {API.BitmapIndexedNode<T, K>} */ (children[offset])\n    yield* node.keys()\n    offset += 1\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {IterableIterator<T>}\n */\nexport const values = function* ({ children }) {\n  let offset = 0\n  const count = children.length\n  while (offset < count) {\n    const key = children[offset]\n    if (typeof key === \"string\") {\n      offset += 1\n      yield /** @type {T} */ (children[offset])\n      offset += 1\n    } else {\n      break\n    }\n  }\n\n  while (offset < count) {\n    const node = /** @type {API.BitmapIndexedNode<T, K>} */ (children[offset])\n    yield* node.values()\n    offset += 1\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {T} value\n */\nexport const forkAndSet = (node, edit, offset, value) => {\n  const newNode = node.fork(edit)\n  newNode.children[valuePosition(offset)] = value\n  return newNode\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} source\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {API.Node<T, K, C>} child\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const inlineChild = (source, edit, offset, child) => {\n  const { datamap, nodemap, config } = source\n  const { BitField } = config\n  const node = fork(source, edit)\n\n  // remove the node that we are inlining\n  node.children.splice(nodePosition(source, offset), 1)\n  // add key-value pair where it wolud fall\n  node.children.splice(\n    keyPosition(BitField.popcount(datamap, offset)),\n    0,\n    child.children[0],\n    child.children[1]\n  )\n\n  node.datamap = BitField.set(datamap, offset)\n  node.nodemap = BitField.unset(nodemap, offset)\n\n  return node\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {API.Node<T, K, C>} child\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const copyAndSetChild = (node, edit, offset, child) => {\n  const newNode = fork(node, edit)\n  newNode.children[nodePosition(node, offset)] = child\n  return newNode\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} source\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {API.Node<T, K, C>} branch\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const migrateLeafToBranch = (source, edit, offset, branch) => {\n  const { nodemap, datamap, config } = source\n  const { BitField } = config\n  const index = BitField.popcount(datamap, offset)\n  // Previous id corresponds to the key position\n  const oldId = keyPosition(index)\n  const newId = nodePosition(source, offset)\n\n  const node = fork(source, edit)\n\n  // remove an old leaf\n  node.datamap = BitField.unset(datamap, offset)\n  node.children.splice(oldId, 2)\n\n  // add a new branch\n  node.nodemap = BitField.set(nodemap, offset)\n  node.children.splice(newId - 1, 0, branch)\n\n  return node\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {C} config\n * @param {API.Edit|null} edit\n * @param {number} depth\n * @param {ReturnType<C['Path']['from']>} oldPath\n * @param {K} oldKey\n * @param {T} oldValue\n * @param {ReturnType<C['Path']['from']>} newPath\n * @param {K} newKey\n * @param {T} newValue\n * @returns {API.Node<T, K, C>}\n */\nexport const mergeTwoLeaves = (\n  config,\n  edit,\n  depth,\n  oldPath,\n  oldKey,\n  oldValue,\n  newPath,\n  newKey,\n  newValue\n) => {\n  const { BitField, Path } = config\n  // If we have reached end of the path we can no longer create another\n  // `BitmapIndexedNode`, instead we create a node containing (hash) colliding\n  // entries\n  /* c8 ignore next 7 */\n  if (Path.size < depth) {\n    return new HashCollisionNode(\n      edit,\n      2,\n      [oldKey, oldValue, newKey, newValue],\n      config\n    )\n  } else {\n    const oldOffset = Path.at(oldPath, depth)\n    const newOffset = Path.at(newPath, depth)\n    // If offsets still match create another intermediery node and merge these\n    // two nodes at next depth level.\n    if (oldOffset === newOffset) {\n      return new BitmapIndexedNode(\n        edit,\n        BitField.empty(Math.pow(2, config.bitWidth)),\n        BitField.from([oldOffset], Math.pow(2, config.bitWidth)),\n        [\n          mergeTwoLeaves(\n            config,\n            edit,\n            depth + 1,\n            oldPath,\n            oldKey,\n            oldValue,\n            newPath,\n            newKey,\n            newValue\n          ),\n        ],\n        config\n      )\n    }\n    // otherwise create new node with both key-value pairs as it's children\n    else {\n      return new BitmapIndexedNode(\n        edit,\n        BitField.from([oldOffset, newOffset], Math.pow(2, config.bitWidth)),\n        BitField.empty(Math.pow(2, config.bitWidth)),\n        /** @type {API.Children<T, K, C>} */\n        (\n          // We insert child with a lower index first so that we can derive it's\n          // index on access via popcount\n          oldOffset < newOffset\n            ? [oldKey, oldValue, newKey, newValue]\n            : [newKey, newValue, oldKey, oldValue]\n        ),\n        config\n      )\n    }\n  }\n}\n\n/**\n * @template {string} K\n * @param {API.BitmapIndexedNode<unknown, K>} node\n * @param {number} index\n */\nexport const keyAt = ({ children }, index) =>\n  /** @type {K} */ (children[keyPosition(index)])\n\n/**\n * @param {number} index\n */\nexport const keyPosition = index => index * 2\n\n/**\n * @template T\n * @param {API.BitmapIndexedNode<T>} node\n * @param {number} index\n */\nexport const valueAt = ({ children }, index) =>\n  /** @type {T} */ (children[valuePosition(index)])\n\n/**\n * @param {number} index\n */\nexport const valuePosition = index => index * 2 + 1\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {number} offset\n * @returns {API.BitmapIndexedNode<T, K, C>|API.HashCollisionNode<T, K, C>}\n */\nexport const resolveNode = (node, offset) =>\n  /** @type {API.BitmapIndexedNode<T, K, C>|API.HashCollisionNode<T, K, C>} */ (\n    node.children[nodePosition(node, offset)]\n  )\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {number} offset\n */\nconst nodePosition = ({ children, nodemap, config }, offset) =>\n  children.length - 1 - config.BitField.popcount(nodemap, offset)\n\n/**\n * @param {API.Edit|null} owner\n * @param {API.Edit|null} editor\n */\nconst canEdit = (owner, editor) => owner != null && owner === editor\n\n/**\n * Returns `true` if node has a single entry. It also refines type to\n * `BitmapIndexedNode` because `HashCollisionNode` is normalized to\n * `BitmapIndexedNode` when it contains only a single entry.\n *\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {node is API.BitmapIndexedNode<T, K, C>}\n */\nconst hasSingleLeaf = node => node.nodeArity === 0 && node.dataArity === 1\n\n/**\n * Returns `true` if node has a single childe node and 0 child leaves.\n *\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @returns {node is API.BitmapIndexedNode<T, K, C>}\n */\nconst hasSingleNode = ({ config: { BitField }, datamap, nodemap }) =>\n  BitField.popcount(datamap) === 0 && BitField.popcount(nodemap) === 1\n", "import { bytes } from 'multiformats'\nimport { from } from 'multiformats/hashes/hasher'\n// @ts-expect-error no types\nimport mur from 'murmurhash3js-revisited'\n\n/**\n * @param {number} number\n * @returns {Uint8Array}\n */\nfunction fromNumberTo32BitBuf (number) {\n  const bytes = new Array(4)\n  for (let i = 0; i < 4; i++) {\n    bytes[i] = number & 0xff\n    number = number >> 8\n  }\n  return new Uint8Array(bytes)\n}\n\nexport const murmur332 = from({\n  name: 'murmur3-32',\n  code: 0x23,\n  encode: (input) => fromNumberTo32BitBuf(mur.x86.hash32(input))\n})\n\nexport const murmur3128 = from({\n  name: 'murmur3-128',\n  code: 0x22,\n  encode: (input) => bytes.fromHex(mur.x64.hash128(input))\n})\n\n// A special-use 0x22 that truncates 64 bits, specifically for use in the UnixFS HAMT\nexport const murmur364 = from({\n  name: 'murmur3-x64-64',\n  code: 0x22,\n  encode: (input) => bytes.fromHex(mur.x64.hash128(input)).subarray(0, 8)\n})\n", "import * as API from \"./api.js\"\nconst utf8 = new TextEncoder()\nimport { murmur364 } from \"@multiformats/murmur3\"\n\n/**\n * @param {Uint8Array} bytes\n */\n/* c8 ignore next 2 */\nexport const hash64 = bytes =>\n  /** @type {Uint8Array} */ (murmur364.encode(bytes))\n\n/**\n * @param {Partial<API.Options<Uint8Array>>} options\n * @returns {API.Path<Uint8Array>}\n */\n/* c8 ignore next 25 */\nexport const configure = ({ bitWidth = 8, hash = hash64 } = {}) => {\n  const hashSize = hash(new Uint8Array()).byteLength\n\n  /**\n   * @param {Uint8Array} path\n   * @param {number} depth\n   * @returns {API.Uint32}\n   */\n  const at = (path, depth) => {\n    const offset = depth * bitWidth\n    if (offset > hashSize) {\n      throw new RangeError(`Out of bounds`)\n    }\n\n    return toInt(path, offset, bitWidth)\n  }\n\n  /**\n   * @param {string} key\n   * @returns {Uint8Array}\n   */\n  const from = key => hash(utf8.encode(key))\n\n  return { from, at, size: Math.ceil((hashSize * 8) / bitWidth) }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset - bit offset\n * @param {number} count - number of bits to consume\n */\nexport const toInt = (bytes, offset, count) => {\n  let byteOffset = (offset / 8) | 0\n  let bitOffset = offset % 8\n  let desired = count\n  let bits = 0\n  while (desired > 0 && byteOffset < bytes.byteLength) {\n    const byte = bytes[byteOffset]\n    const available = 8 - bitOffset\n\n    const taking = available < desired ? available : desired\n    const bitsLeft = 8 - bitOffset - taking\n    // mask to turn of bits before bitOffset\n    const mask = 0xff >> bitOffset\n    // turn off offset bits and shift to drop remaining bit on the right\n    const value = (mask & byte) >> bitsLeft\n    bits = (bits << taking) + value\n\n    desired -= taking\n    byteOffset++\n    bitOffset = 0\n  }\n\n  return bits\n}\n", "import { bitCount, popcount as popcount32 } from \"./Uint32.js\"\nimport * as API from \"./api.js\"\n\n/**\n * @param {number} size\n */\nexport const empty = (size = 256) => {\n  if (size % 8 !== 0) {\n    throw new Error(`Must be multiple of 8`)\n  }\n\n  return new Uint8Array(size / 8)\n}\n\n/**\n * Creates bitfield with specific bits set.\n *\n * @param {number[]} bits\n * @param {number} [size]\n * @returns {Uint8Array}\n */\nexport const from = (bits, size) => {\n  let bitfield = empty(size)\n  for (const index of bits) {\n    const { byte, byteOffset, bitOffset } = at(bitfield, index)\n    bitfield[byteOffset] = byte | (1 << bitOffset)\n  }\n  return bitfield\n}\n\n/**\n * @param {Uint8Array} bitfield\n */\nexport const size = bitfield => bitfield.byteLength * 8\n\n/**\n * Compute offset for the given index\n *\n * @param {Uint8Array} bitfield\n * @param {number} index\n */\nconst at = (bitfield, index) => {\n  const byteOffset = bitfield.byteLength - 1 - ((index / 8) | 0)\n  const bitOffset = index % 8\n  const byte = bitfield[byteOffset]\n\n  return { byte, byteOffset, bitOffset }\n}\n\n/**\n * Set a particular bit.\n *\n * @param {Uint8Array} bytes\n * @param {number} index\n * @param {number} byte\n * @returns {Uint8Array}\n */\nconst setByte = (bytes, index, byte) => {\n  if (bytes[index] !== byte) {\n    const result = bytes.slice(0)\n    result[index] = byte\n    return result\n  }\n  return bytes\n}\n\n/**\n * Set a particular bit.\n *\n * @param {Uint8Array} bitfield\n * @param {number} index\n * @returns {Uint8Array}\n */\nexport const set = (bitfield, index) => {\n  const { byte, byteOffset, bitOffset } = at(bitfield, index)\n  return setByte(bitfield, byteOffset, byte | (1 << bitOffset))\n}\n\n/**\n * Unsets a particular bit.\n\n * @param {Uint8Array} bitfield\n * @param {number} index\n * @returns {Uint8Array}\n */\nexport const unset = (bitfield, index) => {\n  const { byte, byteOffset, bitOffset } = at(bitfield, index)\n  return setByte(bitfield, byteOffset, byte & (0xff ^ (1 << bitOffset)))\n}\n\n/**\n * Returns `true` if bit at given index is set.\n *\n * @param {Uint8Array} bitfield\n * @param {number} index\n */\nexport const get = (bitfield, index) => {\n  var { byte, bitOffset } = at(bitfield, index)\n  return ((byte >> bitOffset) & 0x1) !== 0\n}\n\n/**\n * @param {Uint8Array} bitfield\n */\nexport const toBytes = bitfield => bitfield\n\n/**\n * @param {Uint8Array} bytes\n */\nexport const fromBytes = bytes => bytes\n\n/**\n * @param {Uint8Array} bitfield\n * @param {number} index\n */\nexport const popcount = (bitfield, index = bitfield.byteLength * 8) => {\n  const { byteOffset, bitOffset, byte } = at(bitfield, index)\n\n  let count = popcount32(byte, bitOffset)\n  let offset = bitfield.byteLength - 1\n  while (offset > byteOffset) {\n    const byte = bitfield[offset]\n    count += bitCount(byte)\n    offset--\n  }\n\n  return count\n}\n\n/**\n * @param {Uint8Array} left\n * @param {Uint8Array} right\n */\nexport const or = (left, right) => {\n  const result = left.slice()\n  let offset = 0\n  while (offset < left.length) {\n    result[offset] |= right[offset]\n    offset++\n  }\n  return result\n}\n\n/**\n * @param {Uint8Array} left\n * @param {Uint8Array} right\n */\nexport const and = (left, right) => {\n  const result = left.slice()\n  let offset = 0\n  while (offset < left.length) {\n    result[offset] &= right[offset]\n    offset++\n  }\n  return result\n}\n\nexport { API }\n", "export * from \"./api.js\"\nimport * as Node from \"./node.js\"\nimport { create as createBitmapIndexedNode } from \"./node.js\"\nimport * as API from \"./api.js\"\nimport * as Uint32Path from \"./path/Uint32.js\"\nimport * as Uint8ArrayPath from \"./path/Uint8Array.js\"\nimport * as Uint32BitField from \"./bitfield/Uint32.js\"\nimport * as Uint8ArrayBitField from \"./bitfield/Uint8Array.js\"\n\nconst NOT_FOUND = new RangeError(\"Not Found\")\n\n/**\n * A `bitWidth` determines the number of bits of the hash to use for index\n * calculation at each level of the tree. In first layer will distribute\n * children by the first `bitWidth` bits of the key hash. In the next layer\n * next `bitWidth` number of bits of the key hash are used to determine\n * placement of it's children and so on. Each node in the tree will hold\n * `2 ** bitWidth` number of elements.\n *\n * For example when we insert an entry named `result` it will generate a\n * folowing hash (with murmur3 32) `442064690` which in binary would be\n *\n * ```\n * 11010010110010101111100110010\n * ```\n *\n * Which will correspond to a following key path\n *\n * ```\n * 11010/01011/00101/01111/10011/0010\n * ```\n *\n * Whis in decimals would be\n *\n * ```ts\n * 26/11/5/15/19/2'\n * ```\n *\n * If we then insert `fish` it would produce following path\n *\n * ```ts\n * 26/3/4/18/28/19/1\n * ```\n * @template [V=unknown]\n * @template {string} [K=string]\n * @template {API.Config} [C=API.Config<API.Uint32>]\n * @param {Partial<C>} [options]\n * @returns {API.PersistentHashMap<V, K, C>}\n */\nexport const empty = options => {\n  const config = configure(options)\n  return new PersistentHashMap(0, createBitmapIndexedNode(config, null), config)\n}\n\n/**\n * @template {API.Config} [C=API.Config<API.Uint32>]\n * @param {Partial<C>} config\n * @returns {C}\n */\nconst configure = ({\n  bitWidth = 5,\n  /* c8 ignore next 4 */\n  BitField = bitWidth === 5 ? Uint32BitField : Uint8ArrayBitField,\n  Path = bitWidth === 5\n    ? Uint32Path.configure({ bitWidth })\n    : Uint8ArrayPath.configure({ bitWidth }),\n} = {}) => /** @type {C} */ ({ bitWidth, BitField, Path })\n\n/**\n * Creates HashMap from the provided entries.\n *\n * @template [V=unknown]\n * @template {string} [K=string]\n * @template {API.Config} [C=API.Config<API.Uint32>]\n * @param {Iterable<[K, V]>} entries\n * @param {Partial<C>} [options]\n * @returns {API.PersistentHashMap<V, K, C>}\n */\nexport const from = (entries, options) => {\n  const node = /** @type {API.HashMapBuilder<V, K, C>} */ (builder(options))\n  for (const [key, value] of entries) {\n    node.set(key, value)\n  }\n\n  return node.build()\n}\n\n/**\n * @template T\n * @template {string} K\n * @param {API.HAMT<T, K>} hamt\n * @param {K} key\n */\nexport const has = (hamt, key) =>\n  Node.get(hamt.root, key, NOT_FOUND) !== NOT_FOUND\n\n/**\n * @template T\n * @template {string} K\n * @template [U=undefined]\n * @param {API.HAMT<T, K>} hamt\n * @param {K} key\n * @param {U} notFound\n * @returns {T|U}\n */\nexport const get = (hamt, key, notFound = /** @type {U} */ (undefined)) =>\n  Node.get(hamt.root, key, notFound)\n\n/**\n * @template {string} K\n * @template T\n * @template {API.Config} C\n * @param {Partial<C>} [options]\n * @returns {API.HashMapBuilder<T, K, C>}\n */\nexport const builder = options => {\n  const edit = {}\n  const config = configure(options)\n  return new HashMapBuilder(\n    edit,\n    0,\n    createBitmapIndexedNode(config, edit),\n    config\n  )\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @implements {API.PersistentHashMap<T, K, C>}\n */\nclass PersistentHashMap {\n  /**\n   *\n   * @param {number} count\n   * @param {API.BitmapIndexedNode<T, K, C>} root\n   * @param {C} config\n   */\n  constructor(count = 0, root, config) {\n    this.count = count\n    this.root = root\n    this.config = config\n  }\n\n  get size() {\n    return this.count\n  }\n\n  clone() {\n    return new PersistentHashMap(this.count, this.root, this.config)\n  }\n\n  /**\n   * @returns {API.PersistentHashMap<T, K, C>}\n   */\n  empty() {\n    return new PersistentHashMap(\n      0,\n      createBitmapIndexedNode(this.config, null),\n      this.config\n    )\n  }\n  /**\n   * @param {K} key\n   * @returns {boolean}\n   */\n  has(key) {\n    return has(this, key)\n  }\n  /**\n   * @param {K} key\n   * @returns {T|undefined}\n   */\n  get(key) {\n    return Node.get(this.root, key, undefined)\n  }\n  /**\n   * @template {string} R\n   * @param {R} key\n   * @param {T} value\n   * @returns {PersistentHashMap<T, K|R, C>}\n   */\n  set(key, value) {\n    const addedLeaf = { value: false }\n    const root = Node.set(this.root, null, key, value, addedLeaf)\n    if (root === this.root) {\n      return this\n    } else {\n      return new PersistentHashMap(\n        addedLeaf.value ? this.count + 1 : this.count,\n        root,\n        this.config\n      )\n    }\n  }\n  /**\n   * @param {K} key\n   */\n  delete(key) {\n    const root = Node.delete(this.root, null, key, { value: false })\n\n    if (root === this.root) {\n      return this\n    } else {\n      return new PersistentHashMap(this.count - 1, root, this.config)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  get bitField() {\n    return this.config.BitField.or(this.root.datamap, this.root.nodemap)\n  }\n\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  entries() {\n    return this.root.entries()\n  }\n  keys() {\n    return this.root.keys()\n  }\n  values() {\n    return this.root.values()\n  }\n\n  /**\n   * @returns {API.HashMapBuilder<T, K, C>}\n   */\n\n  createBuilder() {\n    return new HashMapBuilder({}, this.count, this.root, this.config)\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n */\nclass HashMapBuilder {\n  /**\n   * @param {API.Edit} edit\n   * @param {number} count\n   * @param {API.BitmapIndexedNode<T, K, C>} root\n   * @param {C} config\n   */\n  constructor(edit, count, root, config) {\n    /**\n     * @type {API.Edit|null}\n     * @private\n     */\n    this.edit = edit\n    /**\n     * @private\n     */\n    this.count = count\n    this.root = root\n    this.config = config\n  }\n\n  get size() {\n    if (this.edit) {\n      return this.count\n    } else {\n      throw new Error(`.size was accessed on the finalized builder`)\n    }\n  }\n  /**\n   * @template {string} R\n   * @param {R} key\n   * @param {T} value\n   * @returns {HashMapBuilder<T, K|R, C>}\n   */\n  set(key, value) {\n    if (this.edit) {\n      const addedLeaf = { value: false }\n      const root = Node.set(this.root, this.edit, key, value, addedLeaf)\n\n      if (this.root !== root) {\n        this.root = /** @type {API.BitmapIndexedNode<T, K, C>} */ (root)\n      }\n\n      if (addedLeaf.value) {\n        this.count += 1\n      }\n\n      return this\n    } else {\n      throw new Error(`.set was called on the finalized builder`)\n    }\n  }\n  /**\n   * @param {K} key\n   */\n  delete(key) {\n    if (this.edit) {\n      if (this.count === 0) {\n        return this\n      }\n      const removedLeaf = { value: false }\n      const root = Node.delete(this.root, this.edit, key, removedLeaf)\n\n      if (root !== this.root) {\n        this.root = root\n      }\n      if (removedLeaf.value) {\n        this.count -= 1\n      }\n      return this\n    } else {\n      throw new Error(`.delete was called on the finalized builder`)\n    }\n  }\n\n  build() {\n    if (this.edit) {\n      this.edit = null\n      return new PersistentHashMap(this.count, this.root, this.config)\n    } else {\n      throw new Error(`.build was called on the finalized builder`)\n    }\n  }\n}\n", "import * as API from \"./api.js\"\nimport { toInt } from \"./Uint8Array.js\"\nimport { murmur364 } from \"@multiformats/murmur3\"\nconst utf8 = new TextEncoder()\n\n/**\n * @param {Uint8Array} bytes\n */\nexport const hash64 = bytes =>\n  /** @type {Uint8Array} */ (murmur364.encode(bytes))\n\n/**\n * @param {Partial<API.Options<Uint8Array>>} options\n * @returns {API.Path<Uint8Array>}\n */\nexport const configure = ({ bitWidth = 8, hash = hash64 }) => {\n  const hashSize = hash(new Uint8Array()).byteLength\n  const options = { bitWidth, hash, hashSize }\n\n  /**\n   * @param {Uint8Array} path\n   * @param {number} depth\n   * @returns {API.Uint32}\n   */\n  const at = (path, depth) => read(path, depth, options)\n\n  /**\n   * @param {string} key\n   */\n  const from = key => utf8.encode(key)\n\n  return { at, from, size: Infinity }\n}\n\n/**\n * @param {Uint8Array} key\n * @param {number} depth\n * @param {object} options\n * @param {number} [options.bitWidth]\n * @param {number} options.hashSize\n * @param {(input:Uint8Array) => Uint8Array} options.hash\n */\nexport const read = (key, depth = 0, { bitWidth = 8, hash, hashSize }) => {\n  // key digest consists of infinite number of hash frames that are computed\n  // from key + frame n which looks like\n  // [hash(key), hash([key, 1]), hash([key, n])]\n  // You can think of the hash as concatination of all frames. Here we calculate\n  // frame bit size from hash size as we going to use that several times.\n  const frameBitSize = hashSize * 8\n\n  // We start with 0 digest and required `bitCount` corresponding to `bitWith`.\n  // In the loop we'll going to consume `bitCount` hash bits.\n  let digest = 0\n  let bitCount = bitWidth\n  // Calculate absolute bit offset within the key digest.\n  let bitOffset = bitWidth * depth\n  while (bitCount > 0) {\n    // We derive frame number based on current bit offset.\n    const frameOffset = (bitOffset / frameBitSize) >> 0\n    // Then we compute that hash frame\n    const frame =\n      frameOffset === 0 ? hash(key) : hash(appendByte(key, frameOffset))\n\n    // compute bit offset within the current frame\n    const offset =\n      frameBitSize <= bitOffset ? bitOffset % frameBitSize : bitOffset\n    // calculate number of bits remaining in this frame\n    const maxBits = frameBitSize - offset\n    // we will consume all required bits from frame if enough are available\n    // otherwise we consume whatever's available and continue rest in the next\n    // cycle(s).\n    const count = maxBits < bitCount ? maxBits : bitCount\n    digest = (digest << count) + toInt(frame, offset, count)\n    bitCount -= count\n    bitOffset += count\n  }\n\n  return digest\n}\n\n/**\n * @param {Uint8Array} source\n * @param {number} byte\n */\nconst appendByte = (source, byte) => {\n  const bytes = new Uint8Array(source.byteLength + 1).fill(\n    byte,\n    source.byteLength\n  )\n  bytes.set(source)\n  return bytes\n}\n", "import * as HAMT from \"./lib.js\"\nimport * as Node from \"./node.js\"\nimport * as Path from \"./path/InfiniteUint8Array.js\"\n\nexport * from \"./api.js\"\n\nexport { Path }\n\nexport const bitWidth = 8\nexport const config = {\n  bitWidth,\n  Path: Path.configure({ bitWidth }),\n}\n\n/**\n * @param {HAMT.PersistentHashMap} hamt\n */\nexport const tableSize = hamt => Math.pow(2, hamt.config.bitWidth)\n\n/**\n * @template [T=unknown]\n * @template {string} [K=string]\n * @template {HAMT.Config} [C=HAMT.Config<Uint8Array>]\n * @param {Partial<C>} options\n * @returns {HAMT.PersistentHashMap<T, K, C>}\n */\nexport const empty = (options = /** @type {C} */ (config)) =>\n  HAMT.empty(options)\n\n/**\n * @template [T=unknown]\n * @template {string} [K=string]\n * @template {HAMT.Config} [C=HAMT.Config<Uint8Array>]\n * @param {Partial<C>} options\n * @returns {HAMT.HashMapBuilder<T, K, C>}\n */\nexport const builder = (options = /** @type {C} */ (config)) =>\n  HAMT.builder(options)\n\n/**\n * @template [V=unknown]\n * @template {string} [K=string]\n * @template {HAMT.Config} [C=HAMT.Config<Uint8Array>]\n * @param {Iterable<[K, V]>} entries\n * @param {Partial<C>} options\n */\nexport const from = (entries, options = /** @type {C} */ (config)) =>\n  HAMT.from(entries, options)\n\n/**\n * @template T\n * @template {string} K\n * @template Bits, Bitmap\n * @param {HAMT.BitmapIndexedNode<T, K, HAMT.Config<Bits, Bitmap>>} hamt\n */\nexport const bitField = ({ datamap, nodemap, config: { BitField } }) =>\n  withoutLeadingZeros(BitField.toBytes(BitField.or(datamap, nodemap)))\n\n/**\n * @param {Uint8Array} bytes\n */\nconst withoutLeadingZeros = bytes => {\n  let offset = 0\n  while (offset < bytes.byteLength) {\n    if (bytes[offset] !== 0) {\n      return bytes.subarray(offset)\n    }\n    offset += 1\n  }\n  return bytes.subarray(offset)\n}\n\n/**\n * Maps HAMT node into IPFS UnixFS compatible format.\n *\n * @template T\n * @template {string} K\n * @template {HAMT.Config} C\n * @param {HAMT.BitmapIndexedNode<T, K, C>} root\n * @returns {IterableIterator<{prefix:string, key:K, value:T, node?:void}|{prefix:string, node:HAMT.BitmapIndexedNode<T, K, C>}>}\n */\nexport const iterate = function* (root) {\n  const { config, datamap, nodemap } = root\n  const { BitField: bitfield } = config\n  const size = bitfield.size(datamap)\n  let bitOffset = 0\n  let dataCount = 0\n  while (bitOffset < size) {\n    const prefix = bitOffset.toString(16).toUpperCase().padStart(2, \"0\")\n    if (bitfield.get(datamap, bitOffset)) {\n      const key = Node.keyAt(root, dataCount)\n      yield {\n        prefix,\n        key,\n        value: Node.valueAt(root, dataCount),\n      }\n      dataCount++\n    } else if (bitfield.get(nodemap, bitOffset)) {\n      yield {\n        prefix,\n        // UnixFS never contains hash collision nodes because it uses\n        // inifinite hashes\n        node: /** @type {HAMT.BitmapIndexedNode<T, K, C>} */ (\n          Node.resolveNode(root, bitOffset)\n        ),\n      }\n    }\n    bitOffset++\n  }\n}\n", "\nimport * as PermaMap from \"@perma/map\"\nimport * as UnixFSPermaMap from \"@perma/map/unixfs\"\nimport * as PB from \"@ipld/dag-pb\"\nimport { murmur364 } from \"@multiformats/murmur3\"\nimport { Block } from 'multiformats/block'\nimport * as API from \"./directory/api.js\"\nimport * as File from \"./file.js\"\nimport * as UnixFS from \"./codec.js\"\nimport { set, remove } from \"./directory.js\"\n\nexport * from \"./directory/api.js\"\nexport { set, remove } from \"./directory.js\"\n\nexport const configure = File.configure\nexport const defaults = File.defaults\n\n/**\n * @template [Layout=unknown]\n * @param {API.Options<Layout>} config\n * @returns {API.View<Layout>}\n */\nexport const create = ({ writer, settings = defaults(), metadata = {} }) =>\n  new HAMTDirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new HashMap(),\n    closed: false,\n  })\n\n/**\n * @template {API.State} Writer\n * @param {Writer} writer\n * @returns {Writer}\n */\nconst asWritable = writer => {\n  if (!writer.closed) {\n    return writer\n  } else {\n    throw new Error(\"Can not change written HAMT directory, but you can .fork() and make changes to it\")\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {{ state: API.State<Layout> }} view\n * @param {API.CloseOptions} options\n * @returns {Promise<UnixFS.DirectoryLink>}\n */\nexport const close = async (\n  view,\n  { closeWriter = false, releaseLock = false } = {}\n) => {\n  const { writer, settings, metadata } = asWritable(view.state)\n  view.state.closed = true\n\n  const { entries } = view.state\n  /* c8 ignore next 3 */\n  if (!(entries instanceof HashMap)) {\n    throw new Error(`not a HAMT: ${entries}`)\n  }\n\n  const hamt = entries.builder.build()\n  const blocks = iterateBlocks(hamt, hamt.root, settings)\n\n  /** @type {UnixFS.BlockView<UnixFS.DirectoryShard>?} */\n  let root = null\n  for await (const block of blocks) {\n    root = block\n    // we make sure that writer has some capacity for this write. If it\n    // does not we await.\n    if ((writer.desiredSize || 0) <= 0) {\n      await writer.ready\n    }\n    // once writer has some capacity we write a block, however we do not\n    // await completion as we don't care when it's taken off the stream.\n    writer.write(block)\n  }\n  /* c8 ignore next */\n  if (root == null) throw new Error(\"no root block yielded\")\n\n  if (closeWriter) {\n    await writer.close()\n  } else if (releaseLock) {\n    writer.releaseLock()\n  }\n\n  return {\n    cid: root.cid,\n    dagByteLength: UnixFS.cumulativeDagByteLength(root.bytes, root.value.entries),\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {UnixFSPermaMap.PersistentHashMap<API.EntryLink>} hamt\n * @param {UnixFSPermaMap.BitmapIndexedNode<API.EntryLink>} node\n * @param {API.EncoderSettings<Layout>} settings\n * @returns {AsyncIterableIterator<UnixFS.BlockView<UnixFS.DirectoryShard>>}\n */\nconst iterateBlocks = async function* (hamt, node, settings) {\n  /** @type {UnixFS.DirectoryEntryLink[]} */\n  const entries = []\n  for (const ent of UnixFSPermaMap.iterate(node)) {\n    if ('key' in ent) {\n      entries.push(/** @type {UnixFS.DirectoryEntryLink} */ ({\n        name: `${ent.prefix ?? ''}${ent.key ?? ''}`,\n        dagByteLength: ent.value.dagByteLength,\n        cid: ent.value.cid,\n      }))\n    } else {\n      /** @type {UnixFS.BlockView<UnixFS.DirectoryShard>?} */\n      let root = null\n      for await (const block of iterateBlocks(hamt, ent.node, settings)) {\n        yield block\n        root = block\n      }\n      /* c8 ignore next */\n      if (root == null) throw new Error(\"no root block yielded\")\n\n      entries.push(/** @type {UnixFS.ShardedDirectoryLink} */ ({\n        name: ent.prefix,\n        dagByteLength: UnixFS.cumulativeDagByteLength(root.bytes, root.value.entries),\n        cid: root.cid\n      }))\n    }\n  }\n\n  const shard = UnixFS.createDirectoryShard(\n    entries,\n    UnixFSPermaMap.bitField(node),\n    UnixFSPermaMap.tableSize(hamt),\n    murmur364.code\n  )\n  yield await encodeHAMTShardBlock(shard, settings)\n}\n\n/**\n * @template {unknown} Layout\n * @param {UnixFS.DirectoryShard} shard\n * @param {API.EncoderSettings<Layout>} settings\n * @returns {Promise<UnixFS.BlockView<UnixFS.DirectoryShard>>}\n */\nasync function encodeHAMTShardBlock (shard, settings) {\n  const bytes = UnixFS.encodeHAMTShard(shard)\n  const hash = await settings.hasher.digest(bytes)\n  const cid = settings.linker.createLink(PB.code, hash)\n  // @ts-ignore Link is not CID\n  return new Block({ cid, bytes, value: shard })\n}\n\n/**\n * @template L1, L2\n * @param {API.View<L1>} state\n * @param {Partial<API.Options<L1|L2>>} options\n * @returns {API.View<L1|L2>}\n */\nexport const fork = (\n  { state },\n  {\n    writer = state.writer,\n    metadata = state.metadata,\n    settings = state.settings,\n  } = {}\n) =>\n  new HAMTDirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new HashMap(UnixFSPermaMap.from(state.entries.entries()).createBuilder()),\n    closed: false,\n  })\n\n/**\n * @template [Layout=unknown]\n * @implements {API.View<Layout>}\n */\nclass HAMTDirectoryWriter {\n  /**\n   * @param {API.State<Layout>} state\n   */\n  constructor(state) {\n    this.state = state\n  }\n  get writer() {\n    return this.state.writer\n  }\n  get settings() {\n    return this.state.settings\n  }\n\n  /**\n   * @param {string} name\n   * @param {UnixFS.FileLink | UnixFS.DirectoryLink} link\n   * @param {API.WriteOptions} [options]\n   */\n\n  set(name, link, options) {\n    return set(this, name, link, options)\n  }\n\n  /**\n   * @param {string} name\n   */\n  remove(name) {\n    return remove(this, name)\n  }\n\n  /**\n   * @template L\n   * @param {Partial<API.Options<L>>} [options]\n   * @returns {API.View<Layout|L>}\n   */\n  fork(options) {\n    return fork(this, options)\n  }\n\n  /**\n   * @param {API.CloseOptions} [options]\n   * @returns {Promise<UnixFS.DirectoryLink>}\n   */\n  close(options) {\n    return close(this, options)\n  }\n\n  entries() {\n    return this.state.entries.entries()\n  }\n  /**\n   * @param {string} name\n   */\n  has(name) {\n    return this.state.entries.has(name)\n  }\n  get size() {\n    return this.state.entries.size\n  }\n}\n\n/**\n * @implements {Map<string, API.EntryLink>}\n */\nclass HashMap extends Map {\n  /**\n   * @param {UnixFSPermaMap.HashMapBuilder} [builder]\n   */\n  constructor (builder = UnixFSPermaMap.builder()) {\n    super()\n    /** @type {UnixFSPermaMap.HashMapBuilder} */\n    this.builder = builder\n  }\n\n  clear() {\n    this.builder = UnixFSPermaMap.builder()\n  }\n\n  /**\n   * @param {string} key\n   */\n  delete(key) {\n    const { root } = this.builder\n    this.builder.delete(key)\n    return this.builder.root !== root\n  }\n\n  /**\n   * @param {(value: API.EntryLink, key: string, map: Map<string, API.EntryLink>) => void} callbackfn\n   * @param {any} [thisArg]\n   */\n  forEach(callbackfn, thisArg = this) {\n    for (const [k, v] of this.builder.root.entries()) {\n      callbackfn.call(thisArg, v, k, this)\n    }\n  }\n\n  /**\n   * @param {string} key\n   */\n  get(key) {\n    return PermaMap.get(this.builder, key)\n  }\n\n  /**\n   * @param {string} key\n   */\n  has(key) {\n    return PermaMap.has(this.builder, key)\n  }\n\n  /**\n   * @param {string} key \n   * @param {API.EntryLink} value \n   */\n  set(key, value) {\n    this.builder.set(key, value)\n    return this\n  }\n\n  get size () {\n    return this.builder.size\n  }\n\n  [Symbol.iterator]() {\n    return this.builder.root.entries()\n  }\n\n  entries() {\n    return this.builder.root.entries()\n  }\n\n  keys() {\n    return this.builder.root.keys()\n  }\n\n  values() {\n    return this.builder.root.values()\n  }\n}\n", "import * as API from \"./api.js\"\nimport * as File from \"./file.js\"\nimport * as Directory from \"./directory.js\"\n\nexport * from \"./api.js\"\n\nexport { encode, decode, NodeType, code } from \"./codec.js\"\nexport {\n  create as createFileWriter,\n  close as closeFile,\n  write,\n  configure,\n  defaults,\n  UnixFSLeaf,\n  UnixFSRawLeaf,\n} from \"./file.js\"\nexport {\n  create as createDirectoryWriter,\n  close as closeDirectory,\n  fork as forkDirectory,\n  set,\n  remove,\n} from \"./directory.js\"\nexport {\n  create as createShardedDirectoryWriter,\n  close as closeShardedDirectory,\n  fork as forkShardedDirectory,\n} from \"./sharded-directory.js\"\n\n/**\n * @template [Layout=unknown]\n * @param {API.Options<Layout>} options\n * @returns {API.View<Layout>}\n */\nexport const createWriter = ({ writable, settings = File.defaults() }) =>\n  new FileSystemWriter({\n    writer: writable.getWriter(),\n    settings,\n  })\n\n/**\n * @template {{writer:API.BlockWriter}} View\n * @param {View} view\n * @param {API.CloseOptions} options\n */\nexport const close = async (\n  view,\n  { releaseLock = true, closeWriter = true } = {}\n) => {\n  if (closeWriter) {\n    await view.writer.close()\n  } else if (releaseLock) {\n    view.writer.releaseLock()\n  }\n\n  return view\n}\n\n/**\n * @template [Layout=unknown]\n * @implemets {API.View<Layout>}\n */\nclass FileSystemWriter {\n  /**\n   * @param {object} options\n   * @param {API.BlockWriter} options.writer\n   * @param {Partial<API.EncoderSettings<Layout>>} options.settings\n   */\n  constructor({ writer, settings }) {\n    this.writer = writer\n    this.settings = File.configure(settings)\n  }\n\n  /**\n   * @template [L=unknown]\n   * @param {API.WriterOptions<L|Layout>} config\n   */\n  createFileWriter({ settings = this.settings, metadata } = {}) {\n    return File.create({\n      writer: this.writer,\n      settings,\n      metadata,\n    })\n  }\n\n  /**\n   * @template [L=unknown]\n   * @param {API.WriterOptions<L|Layout>} config\n   */\n  createDirectoryWriter({ settings = this.settings, metadata } = {}) {\n    return Directory.create({\n      writer: this.writer,\n      settings,\n      metadata,\n    })\n  }\n\n  /**\n   * @param {API.CloseOptions} [options]\n   */\n  close(options) {\n    return close(this, options)\n  }\n}\n\n// BlockSizeLimit specifies the maximum size an imported block can have.\n// @see https://github.com/ipfs/go-unixfs/blob/68c015a6f317ed5e21a4870f7c423a4b38b90a96/importer/helpers/helpers.go#L7-L8\nexport const BLOCK_SIZE_LIMIT = 1048576 // 1 MB\nexport const defaultCapacity = BLOCK_SIZE_LIMIT * 100\n\n/**\n * Creates `QueuingStrategy` that can fit blocks with total size up to given\n * byteLength.\n *\n * @param {number} byteLength\n * @returns {Required<QueuingStrategy<API.Block>>}\n */\nexport const withCapacity = (byteLength = defaultCapacity) => ({\n  highWaterMark: byteLength,\n  size: block => block.bytes.length,\n})\n", "import errCode from 'err-code'\nimport last from 'it-last'\nimport { CID } from 'multiformats/cid'\nimport resolve from './resolvers/index.js'\nimport type { PBNode } from '@ipld/dag-pb'\nimport type { Bucket } from 'hamt-sharding'\nimport type { Blockstore } from 'interface-blockstore'\nimport type { UnixFS } from 'ipfs-unixfs'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\nexport interface ExportProgress {\n  /**\n   * How many bytes of the file have been read\n   */\n  bytesRead: bigint\n\n  /**\n   * How many bytes of the file will be read - n.b. this may be\n   * smaller than `fileSize` if `offset`/`length` have been\n   * specified\n   */\n  totalBytes: bigint\n\n  /**\n   * The size of the file being read - n.b. this may be\n   * larger than `total` if `offset`/`length` has been\n   * specified\n   */\n  fileSize: bigint\n}\n\nexport interface ExportWalk {\n  cid: CID\n}\n\n/**\n * Progress events emitted by the exporter\n */\nexport type ExporterProgressEvents =\n  ProgressEvent<'unixfs:exporter:progress:unixfs:file', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:progress:unixfs:raw', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:progress:raw', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:progress:identity', ExportProgress> |\n  ProgressEvent<'unixfs:exporter:walk:file', ExportWalk> |\n  ProgressEvent<'unixfs:exporter:walk:directory', ExportWalk> |\n  ProgressEvent<'unixfs:exporter:walk:hamt-sharded-directory', ExportWalk> |\n  ProgressEvent<'unixfs:exporter:walk:raw', ExportWalk>\n\nexport interface ExporterOptions extends ProgressOptions<ExporterProgressEvents> {\n  offset?: number\n  length?: number\n  signal?: AbortSignal\n}\n\nexport interface Exportable<T> {\n  type: 'file' | 'directory' | 'object' | 'raw' | 'identity'\n  name: string\n  path: string\n  cid: CID\n  depth: number\n  size: bigint\n  content: (options?: ExporterOptions) => AsyncGenerator<T, void, unknown>\n}\n\nexport interface UnixFSFile extends Exportable<Uint8Array> {\n  type: 'file'\n  unixfs: UnixFS\n  node: PBNode\n}\n\nexport interface UnixFSDirectory extends Exportable<UnixFSEntry> {\n  type: 'directory'\n  unixfs: UnixFS\n  node: PBNode\n}\n\nexport interface ObjectNode extends Exportable<any> {\n  type: 'object'\n  node: Uint8Array\n}\n\nexport interface RawNode extends Exportable<Uint8Array> {\n  type: 'raw'\n  node: Uint8Array\n}\n\nexport interface IdentityNode extends Exportable<Uint8Array> {\n  type: 'identity'\n  node: Uint8Array\n}\n\nexport type UnixFSEntry = UnixFSFile | UnixFSDirectory | ObjectNode | RawNode | IdentityNode\n\nexport interface NextResult {\n  cid: CID\n  name: string\n  path: string\n  toResolve: string[]\n}\n\nexport interface ResolveResult {\n  entry: UnixFSEntry\n  next?: NextResult\n}\n\nexport interface Resolve { (cid: CID, name: string, path: string, toResolve: string[], depth: number, blockstore: ReadableStorage, options: ExporterOptions): Promise<ResolveResult> }\nexport interface Resolver { (cid: CID, name: string, path: string, toResolve: string[], resolve: Resolve, depth: number, blockstore: ReadableStorage, options: ExporterOptions): Promise<ResolveResult> }\n\nexport type UnixfsV1FileContent = AsyncIterable<Uint8Array> | Iterable<Uint8Array>\nexport type UnixfsV1DirectoryContent = AsyncIterable<UnixFSEntry> | Iterable<UnixFSEntry>\nexport type UnixfsV1Content = UnixfsV1FileContent | UnixfsV1DirectoryContent\nexport interface UnixfsV1Resolver { (cid: CID, node: PBNode, unixfs: UnixFS, path: string, resolve: Resolve, depth: number, blockstore: ReadableStorage): (options: ExporterOptions) => UnixfsV1Content }\n\nexport interface ShardTraversalContext {\n  hamtDepth: number\n  rootBucket: Bucket<boolean>\n  lastBucket: Bucket<boolean>\n}\n\nexport type ReadableStorage = Pick<Blockstore, 'get'>\n\nconst toPathComponents = (path: string = ''): string[] => {\n  // split on / unless escaped with \\\n  return (path\n    .trim()\n    .match(/([^\\\\^/]|\\\\\\/)+/g) ?? [])\n    .filter(Boolean)\n}\n\nconst cidAndRest = (path: string | Uint8Array | CID): { cid: CID, toResolve: string[] } => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: CID.decode(path),\n      toResolve: []\n    }\n  }\n\n  const cid = CID.asCID(path)\n  if (cid != null) {\n    return {\n      cid,\n      toResolve: []\n    }\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6)\n    }\n\n    const output = toPathComponents(path)\n\n    return {\n      cid: CID.parse(output[0]),\n      toResolve: output.slice(1)\n    }\n  }\n\n  throw errCode(new Error(`Unknown path type ${path}`), 'ERR_BAD_PATH')\n}\n\nexport async function * walkPath (path: string | CID, blockstore: ReadableStorage, options: ExporterOptions = {}): AsyncGenerator<UnixFSEntry, void, any> {\n  let {\n    cid,\n    toResolve\n  } = cidAndRest(path)\n  let name = cid.toString()\n  let entryPath = name\n  const startingDepth = toResolve.length\n\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, blockstore, options)\n\n    if (result.entry == null && result.next == null) {\n      throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND')\n    }\n\n    if (result.entry != null) {\n      yield result.entry\n    }\n\n    if (result.next == null) {\n      return\n    }\n\n    // resolve further parts\n    toResolve = result.next.toResolve\n    cid = result.next.cid\n    name = result.next.name\n    entryPath = result.next.path\n  }\n}\n\nexport async function exporter (path: string | CID, blockstore: ReadableStorage, options: ExporterOptions = {}): Promise<UnixFSEntry> {\n  const result = await last(walkPath(path, blockstore, options))\n\n  if (result == null) {\n    throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND')\n  }\n\n  return result\n}\n\nexport async function * recursive (path: string | CID, blockstore: ReadableStorage, options: ExporterOptions = {}): AsyncGenerator<UnixFSEntry, void, any> {\n  const node = await exporter(path, blockstore, options)\n\n  if (node == null) {\n    return\n  }\n\n  yield node\n\n  if (node.type === 'directory') {\n    for await (const child of recurse(node, options)) {\n      yield child\n    }\n  }\n\n  async function * recurse (node: UnixFSDirectory, options: ExporterOptions): AsyncGenerator<UnixFSEntry, void, any> {\n    for await (const file of node.content(options)) {\n      yield file\n\n      if (file instanceof Uint8Array) {\n        continue\n      }\n\n      if (file.type === 'directory') {\n        yield * recurse(file, options)\n      }\n    }\n  }\n}\n", "function isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Returns the last item of an (async) iterable, unless empty, in which case\n * return `undefined`\n */\nfunction last <T> (source: Iterable<T>): T | undefined\nfunction last <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T | undefined>\nfunction last <T> (source: Iterable<T> | AsyncIterable<T>): Promise<T | undefined> | T | undefined {\n  if (isAsyncIterable(source)) {\n    return (async () => {\n      let res\n\n      for await (const entry of source) {\n        res = entry\n      }\n\n      return res\n    })()\n  }\n\n  let res\n\n  for (const entry of source) {\n    res = entry\n  }\n\n  return res\n}\n\nexport default last\n", "import * as dagCbor from '@ipld/dag-cbor'\nimport * as dagPb from '@ipld/dag-pb'\nimport errCode from 'err-code'\nimport * as raw from 'multiformats/codecs/raw'\nimport { identity } from 'multiformats/hashes/identity'\nimport dagCborResolver from './dag-cbor.js'\nimport identifyResolver from './identity.js'\nimport rawResolver from './raw.js'\nimport dagPbResolver from './unixfs-v1/index.js'\nimport type { Resolve, Resolver } from '../index.js'\n\nconst resolvers: Record<number, Resolver> = {\n  [dagPb.code]: dagPbResolver,\n  [raw.code]: rawResolver,\n  [dagCbor.code]: dagCborResolver,\n  [identity.code]: identifyResolver\n}\n\nconst resolve: Resolve = async (cid, name, path, toResolve, depth, blockstore, options) => {\n  const resolver = resolvers[cid.code]\n\n  if (resolver == null) {\n    throw errCode(new Error(`No resolver for code ${cid.code}`), 'ERR_NO_RESOLVER')\n  }\n\n  return resolver(cid, name, path, toResolve, resolve, depth, blockstore, options)\n}\n\nexport default resolve\n", "import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code = 0x0\nconst name = 'identity'\n\n/** @type {(input:Uint8Array) => Uint8Array} */\nconst encode = coerce\n\n/**\n * @param {Uint8Array} input\n * @returns {Digest.Digest<typeof code, number>}\n */\nconst digest = (input) => Digest.create(code, encode(input))\n\nexport const identity = { code, name, encode, digest }\n", "import * as dagCbor from '@ipld/dag-cbor'\nimport errCode from 'err-code'\nimport { CID } from 'multiformats/cid'\nimport type { Resolver } from '../index.js'\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const object = dagCbor.decode<any>(block)\n  let subObject = object\n  let subPath = path\n\n  while (toResolve.length > 0) {\n    const prop = toResolve[0]\n\n    if (prop in subObject) {\n      // remove the bit of the path we have resolved\n      toResolve.shift()\n      subPath = `${subPath}/${prop}`\n\n      const subObjectCid = CID.asCID(subObject[prop])\n      if (subObjectCid != null) {\n        return {\n          entry: {\n            type: 'object',\n            name,\n            path,\n            cid,\n            node: block,\n            depth,\n            size: BigInt(block.length),\n            content: async function * () {\n              yield object\n            }\n          },\n          next: {\n            cid: subObjectCid,\n            name: prop,\n            path: subPath,\n            toResolve\n          }\n        }\n      }\n\n      subObject = subObject[prop]\n    } else {\n      // cannot resolve further\n      throw errCode(new Error(`No property named ${prop} found in cbor node ${cid}`), 'ERR_NO_PROP')\n    }\n  }\n\n  return {\n    entry: {\n      type: 'object',\n      name,\n      path,\n      cid,\n      node: block,\n      depth,\n      size: BigInt(block.length),\n      content: async function * () {\n        yield object\n      }\n    }\n  }\n}\n\nexport default resolve\n", "import errCode from 'err-code'\nimport * as mh from 'multiformats/hashes/digest'\nimport { CustomProgressEvent } from 'progress-events'\nimport extractDataFromBlock from '../utils/extract-data-from-block.js'\nimport validateOffsetAndLength from '../utils/validate-offset-and-length.js'\nimport type { ExporterOptions, Resolver, ExportProgress } from '../index.js'\n\nconst rawContent = (node: Uint8Array): ((options?: ExporterOptions) => AsyncGenerator<Uint8Array, void, undefined>) => {\n  async function * contentGenerator (options: ExporterOptions = {}): AsyncGenerator<Uint8Array, void, undefined> {\n    const {\n      start,\n      end\n    } = validateOffsetAndLength(node.length, options.offset, options.length)\n\n    const buf = extractDataFromBlock(node, 0n, start, end)\n\n    options.onProgress?.(new CustomProgressEvent<ExportProgress>('unixfs:exporter:progress:identity', {\n      bytesRead: BigInt(buf.byteLength),\n      totalBytes: end - start,\n      fileSize: BigInt(node.byteLength)\n    }))\n\n    yield buf\n  }\n\n  return contentGenerator\n}\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  if (toResolve.length > 0) {\n    throw errCode(new Error(`No link named ${path} found in raw node ${cid}`), 'ERR_NOT_FOUND')\n  }\n  const buf = mh.decode(cid.multihash.bytes)\n\n  return {\n    entry: {\n      type: 'identity',\n      name,\n      path,\n      cid,\n      content: rawContent(buf.digest),\n      depth,\n      size: BigInt(buf.digest.length),\n      node: buf.digest\n    }\n  }\n}\n\nexport default resolve\n", "\n/**\n * Progress events are emitted during long running operations\n */\nexport interface ProgressEvent<T extends string = any, D = unknown> {\n  /**\n   * The event type\n   */\n  type: T\n\n  /**\n   * Context-specific event information\n   */\n  detail: D\n}\n\n/**\n * An implementation of the ProgressEvent interface, this is essentially\n * a typed `CustomEvent` with a `type` property that lets us disambiguate\n * events passed to `progress` callbacks.\n */\nexport class CustomProgressEvent<D = unknown, T extends string = any> extends Event implements ProgressEvent<T, D> {\n  // @ts-expect-error type is a property of Event, we just declare it here for use as a type disambiguator\n  public type: T\n  public detail: D\n\n  constructor (type: T, detail?: any) {\n    super(type)\n\n    this.detail = detail\n  }\n}\n\n/**\n * Define an `onProgress` callback that can be invoked with `ProgressEvent`s\n *\n * @example\n *\n * ```typescript\n * type MyOperationProgressEvents =\n *   ProgressEvent<'operation:start'> |\n *   ProgressEvent<'operation:success', Result> |\n *   ProgressEvent<'operation:error', Error>\n *\n * export interface MyOperationOptions extends ProgressOptions<MyOperationProgressEvents> {\n *  // define options here\n * }\n * ```\n */\nexport interface ProgressOptions<Event extends ProgressEvent = any> {\n  onProgress?: (evt: Event) => void\n}\n", "function extractDataFromBlock (block: Uint8Array, blockStart: bigint, requestedStart: bigint, requestedEnd: bigint): Uint8Array {\n  const blockLength = BigInt(block.length)\n  const blockEnd = BigInt(blockStart + blockLength)\n\n  if (requestedStart >= blockEnd || requestedEnd < blockStart) {\n    // If we are looking for a byte range that is starts after the start of the block,\n    // return an empty block.  This can happen when internal nodes contain data\n    return new Uint8Array(0)\n  }\n\n  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {\n    // If the end byte is in the current block, truncate the block to the end byte\n    block = block.subarray(0, Number(requestedEnd - blockStart))\n  }\n\n  if (requestedStart >= blockStart && requestedStart < blockEnd) {\n    // If the start byte is in the current block, skip to the start byte\n    block = block.subarray(Number(requestedStart - blockStart))\n  }\n\n  return block\n}\n\nexport default extractDataFromBlock\n", "import errCode from 'err-code'\n\nconst validateOffsetAndLength = (size: number | bigint, offset: number | bigint = 0, length: number | bigint = size): { start: bigint, end: bigint } => {\n  const fileSize = BigInt(size)\n  const start = BigInt(offset ?? 0)\n  let end = BigInt(length)\n\n  if (end !== fileSize) {\n    end = start + end\n  }\n\n  if (end > fileSize) {\n    end = fileSize\n  }\n\n  if (start < 0n) {\n    throw errCode(new Error('Offset must be greater than or equal to 0'), 'ERR_INVALID_PARAMS')\n  }\n\n  if (start > fileSize) {\n    throw errCode(new Error('Offset must be less than the file size'), 'ERR_INVALID_PARAMS')\n  }\n\n  if (end < 0n) {\n    throw errCode(new Error('Length must be greater than or equal to 0'), 'ERR_INVALID_PARAMS')\n  }\n\n  if (end > fileSize) {\n    throw errCode(new Error('Length must be less than the file size'), 'ERR_INVALID_PARAMS')\n  }\n\n  return {\n    start,\n    end\n  }\n}\n\nexport default validateOffsetAndLength\n", "import errCode from 'err-code'\nimport { CustomProgressEvent } from 'progress-events'\nimport extractDataFromBlock from '../utils/extract-data-from-block.js'\nimport validateOffsetAndLength from '../utils/validate-offset-and-length.js'\nimport type { ExporterOptions, Resolver, ExportProgress } from '../index.js'\n\nconst rawContent = (node: Uint8Array): ((options?: ExporterOptions) => AsyncGenerator<Uint8Array, void, undefined>) => {\n  async function * contentGenerator (options: ExporterOptions = {}): AsyncGenerator<Uint8Array, void, undefined> {\n    const {\n      start,\n      end\n    } = validateOffsetAndLength(node.length, options.offset, options.length)\n\n    const buf = extractDataFromBlock(node, 0n, start, end)\n\n    options.onProgress?.(new CustomProgressEvent<ExportProgress>('unixfs:exporter:progress:raw', {\n      bytesRead: BigInt(buf.byteLength),\n      totalBytes: end - start,\n      fileSize: BigInt(node.byteLength)\n    }))\n\n    yield buf\n  }\n\n  return contentGenerator\n}\n\nconst resolve: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  if (toResolve.length > 0) {\n    throw errCode(new Error(`No link named ${path} found in raw node ${cid}`), 'ERR_NOT_FOUND')\n  }\n\n  const block = await blockstore.get(cid, options)\n\n  return {\n    entry: {\n      type: 'raw',\n      name,\n      path,\n      cid,\n      content: rawContent(block),\n      depth,\n      size: BigInt(block.length),\n      node: block\n    }\n  }\n}\n\nexport default resolve\n", "import { decode, type PBNode } from '@ipld/dag-pb'\nimport errCode from 'err-code'\nimport { UnixFS } from 'ipfs-unixfs'\nimport findShardCid from '../../utils/find-cid-in-shard.js'\nimport contentDirectory from './content/directory.js'\nimport contentFile from './content/file.js'\nimport contentHamtShardedDirectory from './content/hamt-sharded-directory.js'\nimport type { Resolver, UnixfsV1Resolver } from '../../index.js'\nimport type { CID } from 'multiformats/cid'\n\nconst findLinkCid = (node: PBNode, name: string): CID | undefined => {\n  const link = node.Links.find(link => link.Name === name)\n\n  return link?.Hash\n}\n\nconst contentExporters: Record<string, UnixfsV1Resolver> = {\n  raw: contentFile,\n  file: contentFile,\n  directory: contentDirectory,\n  'hamt-sharded-directory': contentHamtShardedDirectory,\n  metadata: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => []\n  },\n  symlink: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => []\n  }\n}\n\n// @ts-expect-error types are wrong\nconst unixFsResolver: Resolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options)\n  const node = decode(block)\n  let unixfs\n  let next\n\n  if (name == null) {\n    name = cid.toString()\n  }\n\n  if (node.Data == null) {\n    throw errCode(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS')\n  }\n\n  try {\n    unixfs = UnixFS.unmarshal(node.Data)\n  } catch (err: any) {\n    // non-UnixFS dag-pb node? It could happen.\n    throw errCode(err, 'ERR_NOT_UNIXFS')\n  }\n\n  if (path == null) {\n    path = name\n  }\n\n  if (toResolve.length > 0) {\n    let linkCid\n\n    if (unixfs?.type === 'hamt-sharded-directory') {\n      // special case - unixfs v1 hamt shards\n      linkCid = await findShardCid(node, toResolve[0], blockstore)\n    } else {\n      linkCid = findLinkCid(node, toResolve[0])\n    }\n\n    if (linkCid == null) {\n      throw errCode(new Error('file does not exist'), 'ERR_NOT_FOUND')\n    }\n\n    // remove the path component we have resolved\n    const nextName = toResolve.shift()\n    const nextPath = `${path}/${nextName}`\n\n    next = {\n      cid: linkCid,\n      toResolve,\n      name: nextName ?? '',\n      path: nextPath\n    }\n  }\n\n  const content = contentExporters[unixfs.type](cid, node, unixfs, path, resolve, depth, blockstore)\n\n  if (content == null) {\n    throw errCode(new Error('could not find content exporter'), 'ERR_NOT_FOUND')\n  }\n\n  if (unixfs.isDirectory()) {\n    return {\n      entry: {\n        type: 'directory',\n        name,\n        path,\n        cid,\n        content,\n        unixfs,\n        depth,\n        node,\n        size: unixfs.fileSize()\n      },\n      next\n    }\n  }\n\n  return {\n    entry: {\n      type: 'file',\n      name,\n      path,\n      cid,\n      content,\n      unixfs,\n      depth,\n      node,\n      size: unixfs.fileSize()\n    },\n    next\n  }\n}\n\nexport default unixFsResolver\n", "import errcode from 'err-code'\nimport { Data as PBData } from './unixfs.js'\n\nexport interface Mtime {\n  secs: bigint\n  nsecs?: number\n}\n\nexport type MtimeLike = Mtime | { Seconds: number, FractionalNanoseconds?: number } | [number, number] | Date\n\nconst types: Record<string, string> = {\n  Raw: 'raw',\n  Directory: 'directory',\n  File: 'file',\n  Metadata: 'metadata',\n  Symlink: 'symlink',\n  HAMTShard: 'hamt-sharded-directory'\n}\n\nconst dirTypes = [\n  'directory',\n  'hamt-sharded-directory'\n]\n\nconst DEFAULT_FILE_MODE = parseInt('0644', 8)\nconst DEFAULT_DIRECTORY_MODE = parseInt('0755', 8)\n\nexport interface UnixFSOptions {\n  type?: string\n  data?: Uint8Array\n  blockSizes?: bigint[]\n  hashType?: bigint\n  fanout?: bigint\n  mtime?: Mtime\n  mode?: number\n}\n\nclass UnixFS {\n  /**\n   * Decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md\n   */\n  static unmarshal (marshaled: Uint8Array): UnixFS {\n    const message = PBData.decode(marshaled)\n\n    const data = new UnixFS({\n      type: types[message.Type != null ? message.Type.toString() : 'File'],\n      data: message.Data,\n      blockSizes: message.blocksizes,\n      mode: message.mode,\n      mtime: message.mtime != null\n        ? {\n            secs: message.mtime.Seconds ?? 0n,\n            nsecs: message.mtime.FractionalNanoseconds\n          }\n        : undefined\n    })\n\n    // make sure we honour the original mode\n    data._originalMode = message.mode ?? 0\n\n    return data\n  }\n\n  public type: string\n  public data?: Uint8Array\n  public blockSizes: bigint[]\n  public hashType?: bigint\n  public fanout?: bigint\n  public mtime?: Mtime\n\n  private _mode?: number\n  private _originalMode: number\n\n  constructor (options: UnixFSOptions = {\n    type: 'file'\n  }) {\n    const {\n      type,\n      data,\n      blockSizes,\n      hashType,\n      fanout,\n      mtime,\n      mode\n    } = options\n\n    if (type != null && !Object.values(types).includes(type)) {\n      throw errcode(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE')\n    }\n\n    this.type = type ?? 'file'\n    this.data = data\n    this.hashType = hashType\n    this.fanout = fanout\n    this.blockSizes = blockSizes ?? []\n    this._originalMode = 0\n    this.mode = mode\n    this.mtime = mtime\n  }\n\n  set mode (mode: number | undefined) {\n    if (mode == null) {\n      this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE\n    } else {\n      this._mode = (mode & 0xFFF)\n    }\n  }\n\n  get mode (): number | undefined {\n    return this._mode\n  }\n\n  isDirectory (): boolean {\n    return dirTypes.includes(this.type)\n  }\n\n  addBlockSize (size: bigint): void {\n    this.blockSizes.push(size)\n  }\n\n  removeBlockSize (index: number): void {\n    this.blockSizes.splice(index, 1)\n  }\n\n  /**\n   * Returns `0n` for directories or `data.length + sum(blockSizes)` for everything else\n   */\n  fileSize (): bigint {\n    if (this.isDirectory()) {\n      // dirs don't have file size\n      return 0n\n    }\n\n    let sum = 0n\n    this.blockSizes.forEach((size) => {\n      sum += size\n    })\n\n    if (this.data != null) {\n      sum += BigInt(this.data.length)\n    }\n\n    return sum\n  }\n\n  /**\n   * encode to protobuf Uint8Array\n   */\n  marshal (): Uint8Array {\n    let type\n\n    switch (this.type) {\n      case 'raw': type = PBData.DataType.Raw; break\n      case 'directory': type = PBData.DataType.Directory; break\n      case 'file': type = PBData.DataType.File; break\n      case 'metadata': type = PBData.DataType.Metadata; break\n      case 'symlink': type = PBData.DataType.Symlink; break\n      case 'hamt-sharded-directory': type = PBData.DataType.HAMTShard; break\n      default:\n        throw errcode(new Error(`Type: ${type} is not valid`), 'ERR_INVALID_TYPE')\n    }\n\n    let data = this.data\n\n    if (this.data == null || this.data.length === 0) {\n      data = undefined\n    }\n\n    let mode\n\n    if (this.mode != null) {\n      mode = (this._originalMode & 0xFFFFF000) | (this.mode ?? 0)\n\n      if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {\n        mode = undefined\n      }\n\n      if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {\n        mode = undefined\n      }\n    }\n\n    let mtime\n\n    if (this.mtime != null) {\n      mtime = {\n        Seconds: this.mtime.secs,\n        FractionalNanoseconds: this.mtime.nsecs\n      }\n    }\n\n    return PBData.encode({\n      Type: type,\n      Data: data,\n      filesize: this.isDirectory() ? undefined : this.fileSize(),\n      blocksizes: this.blockSizes,\n      hashType: this.hashType,\n      fanout: this.fanout,\n      mode,\n      mtime\n    })\n  }\n}\n\nexport { UnixFS }\n", "// @ts-expect-error no types\nimport ReaderClass from 'protobufjs/src/reader.js'\n// @ts-expect-error no types\nimport ReaderBufferClass from 'protobufjs/src/reader_buffer.js'\n// @ts-expect-error no types\nimport util from 'protobufjs/src/util/minimal.js'\n// @ts-expect-error no types\nimport WriterClass from 'protobufjs/src/writer.js'\n// @ts-expect-error no types\nimport WriterBufferClass from 'protobufjs/src/writer_buffer.js'\nimport type { Reader, Writer } from './index.js'\n\nfunction configure (): void {\n  util._configure()\n  ReaderClass._configure(ReaderBufferClass)\n  WriterClass._configure(WriterBufferClass)\n}\n\n// Set up buffer utility according to the environment\nconfigure()\n\n// monkey patch the reader to add native bigint support\nconst methods = [\n  'uint64', 'int64', 'sint64', 'fixed64', 'sfixed64'\n]\n\nfunction patchReader (obj: any): any {\n  for (const method of methods) {\n    if (obj[method] == null) {\n      continue\n    }\n\n    const original = obj[method]\n    obj[method] = function (): bigint {\n      return BigInt(original.call(this).toString())\n    }\n  }\n\n  return obj\n}\n\nexport function reader (buf: Uint8Array): Reader {\n  return patchReader(new ReaderClass(buf))\n}\n\nfunction patchWriter (obj: any): any {\n  for (const method of methods) {\n    if (obj[method] == null) {\n      continue\n    }\n\n    const original = obj[method]\n    obj[method] = function (val: bigint) {\n      return original.call(this, val.toString())\n    }\n  }\n\n  return obj\n}\n\nexport function writer (): Writer {\n  return patchWriter(WriterClass.create())\n}\n", "import { reader } from './utils.js'\nimport type { Codec } from './codec.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport function decodeMessage <T> (buf: Uint8Array | Uint8ArrayList, codec: Codec<T>): T {\n  const r = reader(buf instanceof Uint8Array ? buf : buf.subarray())\n\n  return codec.decode(r)\n}\n", "import { writer } from './utils.js'\nimport type { Codec } from './codec.js'\n\nexport function encodeMessage <T> (message: T, codec: Codec<T>): Uint8Array {\n  const w = writer()\n\n  codec.encode(message, w, {\n    lengthDelimited: false\n  })\n\n  return w.finish()\n}\n", "import type { Writer, Reader } from './index.js'\n\n// https://developers.google.com/protocol-buffers/docs/encoding#structure\nexport enum CODEC_TYPES {\n  VARINT = 0,\n  BIT64,\n  LENGTH_DELIMITED,\n  START_GROUP,\n  END_GROUP,\n  BIT32\n}\n\nexport interface EncodeOptions {\n  lengthDelimited?: boolean\n  writeDefaults?: boolean\n}\n\nexport interface EncodeFunction<T> {\n  (value: Partial<T>, writer: Writer, opts?: EncodeOptions): void\n}\n\nexport interface DecodeFunction<T> {\n  (reader: Reader, length?: number): T\n}\n\nexport interface Codec<T> {\n  name: string\n  type: CODEC_TYPES\n  encode: EncodeFunction<T>\n  decode: DecodeFunction<T>\n}\n\nexport function createCodec <T> (name: string, type: CODEC_TYPES, encode: EncodeFunction<T>, decode: DecodeFunction<T>): Codec<T> {\n  return {\n    name,\n    type,\n    encode,\n    decode\n  }\n}\n", "import { createCodec, CODEC_TYPES } from '../codec.js'\nimport type { DecodeFunction, EncodeFunction, Codec } from '../codec.js'\n\nexport function enumeration <T> (v: any): Codec<T> {\n  function findValue (val: string | number): number {\n    // Use the reverse mapping to look up the enum key for the stored value\n    // https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings\n    if (v[val.toString()] == null) {\n      throw new Error('Invalid enum value')\n    }\n\n    return v[val]\n  }\n\n  const encode: EncodeFunction<number | string> = function enumEncode (val, writer) {\n    const enumValue = findValue(val)\n\n    writer.int32(enumValue)\n  }\n\n  const decode: DecodeFunction<number | string> = function enumDecode (reader) {\n    const val = reader.int32()\n\n    return findValue(val)\n  }\n\n  // @ts-expect-error yeah yeah\n  return createCodec('enum', CODEC_TYPES.VARINT, encode, decode)\n}\n", "import { createCodec, CODEC_TYPES, type EncodeOptions, type Codec } from '../codec.js'\nimport type { Reader, Writer } from '../index.js'\n\nexport interface Factory<A, T> {\n  new (obj: A): T\n}\n\nexport function message <T> (encode: (obj: Partial<T>, writer: Writer, opts?: EncodeOptions) => void, decode: (reader: Reader, length?: number) => T): Codec<T> {\n  return createCodec('message', CODEC_TYPES.LENGTH_DELIMITED, encode, decode)\n}\n", "/* eslint-disable import/export */\n/* eslint-disable complexity */\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */\n/* eslint-disable @typescript-eslint/no-empty-interface */\n\nimport { enumeration, encodeMessage, decodeMessage, message } from 'protons-runtime'\nimport type { Codec } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface Data {\n  Type?: Data.DataType\n  Data?: Uint8Array\n  filesize?: bigint\n  blocksizes: bigint[]\n  hashType?: bigint\n  fanout?: bigint\n  mode?: number\n  mtime?: UnixTime\n}\n\nexport namespace Data {\n  export enum DataType {\n    Raw = 'Raw',\n    Directory = 'Directory',\n    File = 'File',\n    Metadata = 'Metadata',\n    Symlink = 'Symlink',\n    HAMTShard = 'HAMTShard'\n  }\n\n  enum __DataTypeValues {\n    Raw = 0,\n    Directory = 1,\n    File = 2,\n    Metadata = 3,\n    Symlink = 4,\n    HAMTShard = 5\n  }\n\n  export namespace DataType {\n    export const codec = (): Codec<DataType> => {\n      return enumeration<DataType>(__DataTypeValues)\n    }\n  }\n\n  let _codec: Codec<Data>\n\n  export const codec = (): Codec<Data> => {\n    if (_codec == null) {\n      _codec = message<Data>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Type != null) {\n          w.uint32(8)\n          Data.DataType.codec().encode(obj.Type, w)\n        }\n\n        if (obj.Data != null) {\n          w.uint32(18)\n          w.bytes(obj.Data)\n        }\n\n        if (obj.filesize != null) {\n          w.uint32(24)\n          w.uint64(obj.filesize)\n        }\n\n        if (obj.blocksizes != null) {\n          for (const value of obj.blocksizes) {\n            w.uint32(32)\n            w.uint64(value)\n          }\n        }\n\n        if (obj.hashType != null) {\n          w.uint32(40)\n          w.uint64(obj.hashType)\n        }\n\n        if (obj.fanout != null) {\n          w.uint32(48)\n          w.uint64(obj.fanout)\n        }\n\n        if (obj.mode != null) {\n          w.uint32(56)\n          w.uint32(obj.mode)\n        }\n\n        if (obj.mtime != null) {\n          w.uint32(66)\n          UnixTime.codec().encode(obj.mtime, w)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {\n          blocksizes: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.Type = Data.DataType.codec().decode(reader)\n              break\n            case 2:\n              obj.Data = reader.bytes()\n              break\n            case 3:\n              obj.filesize = reader.uint64()\n              break\n            case 4:\n              obj.blocksizes.push(reader.uint64())\n              break\n            case 5:\n              obj.hashType = reader.uint64()\n              break\n            case 6:\n              obj.fanout = reader.uint64()\n              break\n            case 7:\n              obj.mode = reader.uint32()\n              break\n            case 8:\n              obj.mtime = UnixTime.codec().decode(reader, reader.uint32())\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Data>): Uint8Array => {\n    return encodeMessage(obj, Data.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Data => {\n    return decodeMessage(buf, Data.codec())\n  }\n}\n\nexport interface UnixTime {\n  Seconds?: bigint\n  FractionalNanoseconds?: number\n}\n\nexport namespace UnixTime {\n  let _codec: Codec<UnixTime>\n\n  export const codec = (): Codec<UnixTime> => {\n    if (_codec == null) {\n      _codec = message<UnixTime>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Seconds != null) {\n          w.uint32(8)\n          w.int64(obj.Seconds)\n        }\n\n        if (obj.FractionalNanoseconds != null) {\n          w.uint32(21)\n          w.fixed32(obj.FractionalNanoseconds)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.Seconds = reader.int64()\n              break\n            case 2:\n              obj.FractionalNanoseconds = reader.fixed32()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<UnixTime>): Uint8Array => {\n    return encodeMessage(obj, UnixTime.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): UnixTime => {\n    return decodeMessage(buf, UnixTime.codec())\n  }\n}\n\nexport interface Metadata {\n  MimeType?: string\n}\n\nexport namespace Metadata {\n  let _codec: Codec<Metadata>\n\n  export const codec = (): Codec<Metadata> => {\n    if (_codec == null) {\n      _codec = message<Metadata>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.MimeType != null) {\n          w.uint32(10)\n          w.string(obj.MimeType)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1:\n              obj.MimeType = reader.string()\n              break\n            default:\n              reader.skipType(tag & 7)\n              break\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<Metadata>): Uint8Array => {\n    return encodeMessage(obj, Metadata.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList): Metadata => {\n    return decodeMessage(buf, Metadata.codec())\n  }\n}\n", "// @ts-expect-error\nimport SparseArray from 'sparse-array'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport type { InfiniteHash } from './consumable-hash.js'\n\nexport interface BucketChild<V> {\n  key: string\n  value: V\n  hash: InfiniteHash\n}\n\ninterface SA<B> {\n  length: number\n  compactArray: () => B[]\n  get: (i: number) => B\n  set: (i: number, value: B) => void\n  reduce: <A> (fn: (acc: A, curr: B, index: number) => A, initial: A) => B\n  find: (fn: (item: B) => boolean) => B | undefined\n  bitField: () => number[]\n  unset: (i: number) => void\n}\n\nexport interface BucketPosition<T> {\n  bucket: Bucket<T>\n  pos: number\n  hash: InfiniteHash\n  existingChild?: BucketChild<T>\n}\n\nexport interface BucketOptions {\n  bits: number\n  hash: (value: Uint8Array | InfiniteHash) => InfiniteHash\n}\n\nexport class Bucket<T> {\n  _options: BucketOptions\n  _popCount: number\n  _parent?: Bucket<T>\n  _posAtParent: number\n  _children: SA<Bucket<T> | BucketChild<T>>\n\n  key: string | null\n\n  constructor (options: BucketOptions, parent?: Bucket<T>, posAtParent = 0) {\n    this._options = options\n    this._popCount = 0\n    this._parent = parent\n    this._posAtParent = posAtParent\n    this._children = new SparseArray()\n    this.key = null\n  }\n\n  async put (key: string, value: T) {\n    const place = await this._findNewBucketAndPos(key)\n\n    await place.bucket._putAt(place, key, value)\n  }\n\n  async get (key: string) {\n    const child = await this._findChild(key)\n\n    if (child != null) {\n      return child.value\n    }\n  }\n\n  async del (key: string) {\n    const place = await this._findPlace(key)\n    const child = place.bucket._at(place.pos)\n\n    if (child != null && child.key === key) {\n      place.bucket._delAt(place.pos)\n    }\n  }\n\n  leafCount (): number {\n    const children = this._children.compactArray()\n\n    return children.reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount()\n      }\n\n      return acc + 1\n    }, 0)\n  }\n\n  childrenCount () {\n    return this._children.length\n  }\n\n  onlyChild () {\n    return this._children.get(0)\n  }\n\n  * eachLeafSeries (): Iterable<BucketChild<T>> {\n    const children = this._children.compactArray()\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        yield * child.eachLeafSeries()\n      } else {\n        yield child\n      }\n    }\n  }\n\n  serialize (map: (value: BucketChild<T>, index: number) => T, reduce: (reduced: any) => any) {\n    const acc: T[] = []\n    // serialize to a custom non-sparse representation\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child != null) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce))\n        } else {\n          acc.push(map(child, index))\n        }\n      }\n      return acc\n    }, acc))\n  }\n\n  async asyncTransform (asyncMap: (value: BucketChild<T>) => Promise<T[]>, asyncReduce: (reduced: any) => Promise<any>) {\n    return await asyncTransformBucket(this, asyncMap, asyncReduce)\n  }\n\n  toJSON () {\n    return this.serialize(mapNode, reduceNodes)\n  }\n\n  prettyPrint () {\n    return JSON.stringify(this.toJSON(), null, '  ')\n  }\n\n  tableSize () {\n    return Math.pow(2, this._options.bits)\n  }\n\n  async _findChild (key: string) {\n    const result = await this._findPlace(key)\n    const child = result.bucket._at(result.pos)\n\n    if (child instanceof Bucket) {\n      // should not be possible, this._findPlace should always\n      // return a location for a child, not a bucket\n      return undefined\n    }\n\n    if (child != null && child.key === key) {\n      return child\n    }\n  }\n\n  async _findPlace (key: string | InfiniteHash): Promise<BucketPosition<T>> {\n    const hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key)\n    const index = await hashValue.take(this._options.bits)\n\n    const child = this._children.get(index)\n\n    if (child instanceof Bucket) {\n      return await child._findPlace(hashValue)\n    }\n\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue,\n      existingChild: child\n    }\n  }\n\n  async _findNewBucketAndPos (key: string | InfiniteHash): Promise<BucketPosition<T>> {\n    const place = await this._findPlace(key)\n\n    if ((place.existingChild != null) && place.existingChild.key !== key) {\n      // conflict\n      const bucket = new Bucket(this._options, place.bucket, place.pos)\n      place.bucket._putObjectAt(place.pos, bucket)\n\n      // put the previous value\n      const newPlace = await bucket._findPlace(place.existingChild.hash)\n      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value)\n\n      return await bucket._findNewBucketAndPos(place.hash)\n    }\n\n    // no conflict, we found the place\n    return place\n  }\n\n  _putAt (place: BucketPosition<T>, key: string, value: T) {\n    this._putObjectAt(place.pos, {\n      key: key,\n      value: value,\n      hash: place.hash\n    })\n  }\n\n  _putObjectAt (pos: number, object: Bucket<T> | BucketChild<T>) {\n    if (this._children.get(pos) == null) {\n      this._popCount++\n    }\n    this._children.set(pos, object)\n  }\n\n  _delAt (pos: number) {\n    if (pos === -1) {\n      throw new Error('Invalid position')\n    }\n\n    if (this._children.get(pos) != null) {\n      this._popCount--\n    }\n    this._children.unset(pos)\n    this._level()\n  }\n\n  _level () {\n    if (this._parent != null && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists)\n\n        if ((onlyChild != null) && !(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash\n          hash.untake(this._options.bits)\n          const place = {\n            pos: this._posAtParent,\n            hash: hash,\n            bucket: this._parent\n          }\n          this._parent._putAt(place, onlyChild.key, onlyChild.value)\n        }\n      } else {\n        this._parent._delAt(this._posAtParent)\n      }\n    }\n  }\n\n  _at (index: number) {\n    return this._children.get(index)\n  }\n}\n\nfunction exists (o: any) {\n  return Boolean(o)\n}\n\nfunction mapNode (node: any, _: number) {\n  return node.key\n}\n\nfunction reduceNodes (nodes: any) {\n  return nodes\n}\n\nasync function asyncTransformBucket<T> (bucket: Bucket<T>, asyncMap: (value: BucketChild<T>) => Promise<T[]>, asyncReduce: (reduced: any) => Promise<any>) {\n  const output = []\n\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce)\n    } else {\n      const mappedChildren = await asyncMap(child)\n\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      })\n    }\n  }\n\n  return await asyncReduce(output)\n}\n", "// @ts-check\n\nimport { from } from './base.js'\nimport { fromString, toString } from '../bytes.js'\n\nexport const identity = from({\n  prefix: '\\x00',\n  name: 'identity',\n  encode: (buf) => toString(buf),\n  decode: (str) => fromString(str)\n})\n", "// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n})\n", "// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n})\n", "import { baseX } from './base.js'\n\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n})\n", "// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n})\n\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n})\n", "import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n", "// @ts-check\n\nimport { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n", "import { from } from './base.js'\n\nconst alphabet = Array.from('\uD83D\uDE80\uD83E\uDE90\u2604\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\u2600\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\u2764\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\u263A\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\u270C\u2728\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\u2763\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\u270B\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\u2B50\u2705\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\u2714\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\u2639\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\u261D\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\u26BD\uD83E\uDD19\u2615\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\u26A1\uD83C\uDF1E\uD83C\uDF88\u274C\u270A\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\u2708\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\u25B6\u27A1\u2753\uD83D\uDC8E\uD83D\uDCB8\u2B07\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\u26A0\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\u260E\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\u2744\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42')\nconst alphabetBytesToChars = /** @type {string[]} */ (alphabet.reduce((p, c, i) => { p[i] = c; return p }, /** @type {string[]} */([])))\nconst alphabetCharsToBytes = /** @type {number[]} */ (alphabet.reduce((p, c, i) => { p[/** @type {number} */ (c.codePointAt(0))] = i; return p }, /** @type {number[]} */([])))\n\n/**\n * @param {Uint8Array} data\n * @returns {string}\n */\nfunction encode (data) {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c]\n    return p\n  }, '')\n}\n\n/**\n * @param {string} str\n * @returns {Uint8Array}\n */\nfunction decode (str) {\n  const byts = []\n  for (const char of str) {\n    const byt = alphabetCharsToBytes[/** @type {number} */ (char.codePointAt(0))]\n    if (byt === undefined) {\n      throw new Error(`Non-base256emoji character: ${char}`)\n    }\n    byts.push(byt)\n  }\n  return new Uint8Array(byts)\n}\n\nexport const base256emoji = from({\n  prefix: '\uD83D\uDE80',\n  name: 'base256emoji',\n  encode,\n  decode\n})\n", "import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\n\nconst code = 0x0\nconst name = 'identity'\n\n/** @type {(input:Uint8Array) => Uint8Array} */\nconst encode = coerce\n\n/**\n * @param {Uint8Array} input\n * @returns {Digest.Digest<typeof code, number>}\n */\nconst digest = (input) => Digest.create(code, encode(input))\n\nexport const identity = { code, name, encode, digest }\n", "// @ts-check\n\n/**\n * @template T\n * @typedef {import('./interface.js').ByteView<T>} ByteView\n */\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const name = 'json'\nexport const code = 0x0200\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => textEncoder.encode(JSON.stringify(node))\n\n/**\n * @template T\n * @param {ByteView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => JSON.parse(textDecoder.decode(data))\n", "// @ts-check\n\nimport * as identityBase from './bases/identity.js'\nimport * as base2 from './bases/base2.js'\nimport * as base8 from './bases/base8.js'\nimport * as base10 from './bases/base10.js'\nimport * as base16 from './bases/base16.js'\nimport * as base32 from './bases/base32.js'\nimport * as base36 from './bases/base36.js'\nimport * as base58 from './bases/base58.js'\nimport * as base64 from './bases/base64.js'\nimport * as base256emoji from './bases/base256emoji.js'\nimport * as sha2 from './hashes/sha2.js'\nimport * as identity from './hashes/identity.js'\n\nimport * as raw from './codecs/raw.js'\nimport * as json from './codecs/json.js'\n\nimport { CID, hasher, digest, varint, bytes } from './index.js'\n\nconst bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji }\nconst hashes = { ...sha2, ...identity }\nconst codecs = { raw, json }\n\nexport { CID, hasher, digest, varint, bytes, hashes, bases, codecs }\n", "\n/**\n * To guarantee Uint8Array semantics, convert nodejs Buffers\n * into vanilla Uint8Arrays\n */\nexport function asUint8Array (buf: Uint8Array): Uint8Array {\n  if (globalThis.Buffer != null) {\n    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength)\n  }\n\n  return buf\n}\n", "import { asUint8Array } from './util/as-uint8array.js'\n\n/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc (size: number = 0): Uint8Array {\n  if (globalThis.Buffer?.alloc != null) {\n    return asUint8Array(globalThis.Buffer.alloc(size))\n  }\n\n  return new Uint8Array(size)\n}\n\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe (size: number = 0): Uint8Array {\n  if (globalThis.Buffer?.allocUnsafe != null) {\n    return asUint8Array(globalThis.Buffer.allocUnsafe(size))\n  }\n\n  return new Uint8Array(size)\n}\n", "import type { MultibaseCodec } from 'multiformats'\nimport { bases } from 'multiformats/basics'\nimport { allocUnsafe } from '../alloc.js'\n\nfunction createCodec (name: string, prefix: string, encode: (buf: Uint8Array) => string, decode: (str: string) => Uint8Array): MultibaseCodec<any> {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: {\n      decode\n    }\n  }\n}\n\nconst string = createCodec('utf8', 'u', (buf) => {\n  const decoder = new TextDecoder('utf8')\n  return 'u' + decoder.decode(buf)\n}, (str) => {\n  const encoder = new TextEncoder()\n  return encoder.encode(str.substring(1))\n})\n\nconst ascii = createCodec('ascii', 'a', (buf) => {\n  let string = 'a'\n\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i])\n  }\n  return string\n}, (str) => {\n  str = str.substring(1)\n  const buf = allocUnsafe(str.length)\n\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i)\n  }\n\n  return buf\n})\n\nexport type SupportedEncodings = 'utf8' | 'utf-8' | 'hex' | 'latin1' | 'ascii' | 'binary' | keyof typeof bases\n\nconst BASES: Record<SupportedEncodings, MultibaseCodec<any>> = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii: ascii,\n  binary: ascii,\n\n  ...bases\n}\n\nexport default BASES\n", "import bases, { SupportedEncodings } from './util/bases.js'\nimport { asUint8Array } from './util/as-uint8array.js'\n\nexport type { SupportedEncodings }\n\n/**\n * Create a `Uint8Array` from the passed string\n *\n * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function fromString (string: string, encoding: SupportedEncodings = 'utf8'): Uint8Array {\n  const base = bases[encoding]\n\n  if (base == null) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`)\n  }\n\n  if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {\n    return asUint8Array(globalThis.Buffer.from(string, 'utf-8'))\n  }\n\n  // add multibase prefix\n  return base.decoder.decode(`${base.prefix}${string}`) // eslint-disable-line @typescript-eslint/restrict-template-expressions\n}\n", "const START_MASKS = [\n  0b11111111,\n  0b11111110,\n  0b11111100,\n  0b11111000,\n  0b11110000,\n  0b11100000,\n  0b11000000,\n  0b10000000\n]\n\nconst STOP_MASKS = [\n  0b00000001,\n  0b00000011,\n  0b00000111,\n  0b00001111,\n  0b00011111,\n  0b00111111,\n  0b01111111,\n  0b11111111\n]\n\nexport class ConsumableBuffer {\n  _value: Uint8Array\n  _currentBytePos: number\n  _currentBitPos: number\n\n  constructor (value: Uint8Array) {\n    this._value = value\n    this._currentBytePos = value.length - 1\n    this._currentBitPos = 7\n  }\n\n  availableBits () {\n    return this._currentBitPos + 1 + this._currentBytePos * 8\n  }\n\n  totalBits () {\n    return this._value.length * 8\n  }\n\n  take (bits: number) {\n    let pendingBits = bits\n    let result = 0\n    while (pendingBits > 0 && this._haveBits()) {\n      const byte = this._value[this._currentBytePos]\n      const availableBits = this._currentBitPos + 1\n      const taking = Math.min(availableBits, pendingBits)\n      const value = byteBitsToInt(byte, availableBits - taking, taking)\n      result = (result << taking) + value\n\n      pendingBits -= taking\n\n      this._currentBitPos -= taking\n      if (this._currentBitPos < 0) {\n        this._currentBitPos = 7\n        this._currentBytePos--\n      }\n    }\n\n    return result\n  }\n\n  untake (bits: number) {\n    this._currentBitPos += bits\n    while (this._currentBitPos > 7) {\n      this._currentBitPos -= 8\n      this._currentBytePos += 1\n    }\n  }\n\n  _haveBits () {\n    return this._currentBytePos >= 0\n  }\n}\n\nfunction byteBitsToInt (byte: number, start: number, length: number) {\n  const mask = maskFor(start, length)\n  return (byte & mask) >>> start\n}\n\nfunction maskFor (start: number, length: number) {\n  return START_MASKS[start] & STOP_MASKS[Math.min(length + start - 1, 7)]\n}\n", "import { allocUnsafe } from './alloc.js'\nimport { asUint8Array } from './util/as-uint8array.js'\n\n/**\n * Returns a new Uint8Array created by concatenating the passed ArrayLikes\n */\nexport function concat (arrays: Array<ArrayLike<number>>, length?: number): Uint8Array {\n  if (length == null) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0)\n  }\n\n  const output = allocUnsafe(length)\n  let offset = 0\n\n  for (const arr of arrays) {\n    output.set(arr, offset)\n    offset += arr.length\n  }\n\n  return asUint8Array(output)\n}\n", "import { ConsumableBuffer } from './consumable-buffer.js'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\n\nexport function wrapHash (hashFn: (value: Uint8Array) => Promise<Uint8Array>) {\n  function hashing (value: InfiniteHash | Uint8Array) {\n    if (value instanceof InfiniteHash) {\n      // already a hash. return it\n      return value\n    } else {\n      return new InfiniteHash(value, hashFn)\n    }\n  }\n\n  return hashing\n}\n\nexport class InfiniteHash {\n  _value: Uint8Array\n  _hashFn: (value: Uint8Array) => Promise<Uint8Array>\n  _depth: number\n  _availableBits: number\n  _currentBufferIndex: number\n  _buffers: ConsumableBuffer[]\n\n  constructor (value: Uint8Array, hashFn: (value: Uint8Array) => Promise<Uint8Array>) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error('can only hash Uint8Arrays')\n    }\n\n    this._value = value\n    this._hashFn = hashFn\n    this._depth = -1\n    this._availableBits = 0\n    this._currentBufferIndex = 0\n    this._buffers = []\n  }\n\n  async take (bits: number) {\n    let pendingBits = bits\n\n    while (this._availableBits < pendingBits) {\n      await this._produceMoreBits()\n    }\n\n    let result = 0\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const available = Math.min(hash.availableBits(), pendingBits)\n      const took = hash.take(available)\n      result = (result << available) + took\n      pendingBits -= available\n      this._availableBits -= available\n\n      if (hash.availableBits() === 0) {\n        this._currentBufferIndex++\n      }\n    }\n\n    return result\n  }\n\n  untake (bits: number) {\n    let pendingBits = bits\n\n    while (pendingBits > 0) {\n      const hash = this._buffers[this._currentBufferIndex]\n      const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits)\n      hash.untake(availableForUntake)\n      pendingBits -= availableForUntake\n      this._availableBits += availableForUntake\n\n      if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {\n        this._depth--\n        this._currentBufferIndex--\n      }\n    }\n  }\n\n  async _produceMoreBits () {\n    this._depth++\n\n    const value = this._depth > 0 ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value\n    const hashValue = await this._hashFn(value)\n    const buffer = new ConsumableBuffer(hashValue)\n\n    this._buffers.push(buffer)\n    this._availableBits += buffer.availableBits()\n  }\n}\n", "import { Bucket } from './bucket.js'\nimport type { BucketOptions, BucketPosition, BucketChild } from './bucket.js'\nimport { wrapHash } from './consumable-hash.js'\n\ninterface UserBucketOptions {\n  hashFn: (value: Uint8Array) => Promise<Uint8Array>\n  bits?: number\n}\n\nexport function createHAMT<T> (options: UserBucketOptions) {\n  if (options == null || options.hashFn == null) {\n    throw new Error('please define an options.hashFn')\n  }\n\n  const bucketOptions = {\n    bits: options.bits ?? 8,\n    hash: wrapHash(options.hashFn)\n  }\n\n  return new Bucket<T>(bucketOptions)\n}\n\nexport { Bucket }\nexport type { BucketOptions, BucketPosition, BucketChild }\n", "import { decode, type PBLink, type PBNode } from '@ipld/dag-pb'\nimport { murmur3128 } from '@multiformats/murmur3'\nimport { Bucket, type BucketPosition, createHAMT } from 'hamt-sharding'\nimport type { ExporterOptions, ShardTraversalContext, ReadableStorage } from '../index.js'\nimport type { CID } from 'multiformats/cid'\n\n// FIXME: this is copy/pasted from ipfs-unixfs-importer/src/options.js\nconst hashFn = async function (buf: Uint8Array): Promise<Uint8Array> {\n  return (await murmur3128.encode(buf))\n    // Murmur3 outputs 128 bit but, accidentally, IPFS Go's\n    // implementation only uses the first 64, so we must do the same\n    // for parity..\n    .slice(0, 8)\n    // Invert buffer because that's how Go impl does it\n    .reverse()\n}\n\nconst addLinksToHamtBucket = async (links: PBLink[], bucket: Bucket<boolean>, rootBucket: Bucket<boolean>): Promise<void> => {\n  await Promise.all(\n    links.map(async link => {\n      if (link.Name == null) {\n        // TODO(@rvagg): what do? this is technically possible\n        throw new Error('Unexpected Link without a Name')\n      }\n      if (link.Name.length === 2) {\n        const pos = parseInt(link.Name, 16)\n\n        bucket._putObjectAt(pos, new Bucket({\n          hash: rootBucket._options.hash,\n          bits: rootBucket._options.bits\n        }, bucket, pos))\n        return\n      }\n\n      await rootBucket.put(link.Name.substring(2), true)\n    })\n  )\n}\n\nconst toPrefix = (position: number): string => {\n  return position\n    .toString(16)\n    .toUpperCase()\n    .padStart(2, '0')\n    .substring(0, 2)\n}\n\nconst toBucketPath = (position: BucketPosition<boolean>): Array<Bucket<boolean>> => {\n  let bucket = position.bucket\n  const path = []\n\n  while (bucket._parent != null) {\n    path.push(bucket)\n\n    bucket = bucket._parent\n  }\n\n  path.push(bucket)\n\n  return path.reverse()\n}\n\nconst findShardCid = async (node: PBNode, name: string, blockstore: ReadableStorage, context?: ShardTraversalContext, options?: ExporterOptions): Promise<CID | undefined> => {\n  if (context == null) {\n    const rootBucket = createHAMT<boolean>({\n      hashFn\n    })\n\n    context = {\n      rootBucket,\n      hamtDepth: 1,\n      lastBucket: rootBucket\n    }\n  }\n\n  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket)\n\n  const position = await context.rootBucket._findNewBucketAndPos(name)\n  let prefix = toPrefix(position.pos)\n  const bucketPath = toBucketPath(position)\n\n  if (bucketPath.length > context.hamtDepth) {\n    context.lastBucket = bucketPath[context.hamtDepth]\n\n    prefix = toPrefix(context.lastBucket._posAtParent)\n  }\n\n  const link = node.Links.find(link => {\n    if (link.Name == null) {\n      return false\n    }\n\n    const entryPrefix = link.Name.substring(0, 2)\n    const entryName = link.Name.substring(2)\n\n    if (entryPrefix !== prefix) {\n      // not the entry or subshard we're looking for\n      return false\n    }\n\n    if (entryName !== '' && entryName !== name) {\n      // not the entry we're looking for\n      return false\n    }\n\n    return true\n  })\n\n  if (link == null) {\n    return\n  }\n\n  if (link.Name != null && link.Name.substring(2) === name) {\n    return link.Hash\n  }\n\n  context.hamtDepth++\n\n  const block = await blockstore.get(link.Hash, options)\n  node = decode(block)\n\n  return findShardCid(node, name, blockstore, context, options)\n}\n\nexport default findShardCid\n", "interface Peek <T> {\n  peek: () => IteratorResult<T, undefined>\n}\n\ninterface AsyncPeek <T> {\n  peek: () => Promise<IteratorResult<T, undefined>>\n}\n\ninterface Push <T> {\n  push: (value: T) => void\n}\n\ntype Peekable <T> = Iterable<T> & Peek<T> & Push<T> & Iterator<T>\n\ntype AsyncPeekable <T> = AsyncIterable<T> & AsyncPeek<T> & Push<T> & AsyncIterator<T>\n\nfunction peekable <T> (iterable: Iterable<T>): Peekable<T>\nfunction peekable <T> (iterable: AsyncIterable<T>): AsyncPeekable<T>\nfunction peekable <T> (iterable: Iterable<T> | AsyncIterable<T>): Peekable<T> | AsyncPeekable<T> {\n  // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n  const [iterator, symbol] = iterable[Symbol.asyncIterator] != null\n    // @ts-expect-error can't use Symbol.asyncIterator to index iterable since it might be Iterable\n    ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator]\n    // @ts-expect-error can't use Symbol.iterator to index iterable since it might be AsyncIterable\n    : [iterable[Symbol.iterator](), Symbol.iterator]\n\n  const queue: any[] = []\n\n  // @ts-expect-error can't use symbol to index peekable\n  return {\n    peek: () => {\n      return iterator.next()\n    },\n    push: (value: any) => {\n      queue.push(value)\n    },\n    next: () => {\n      if (queue.length > 0) {\n        return {\n          done: false,\n          value: queue.shift()\n        }\n      }\n\n      return iterator.next()\n    },\n    [symbol] () {\n      return this\n    }\n  }\n}\n\nexport default peekable\n", "import peek from 'it-peekable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Filters the passed (async) iterable by using the filter function\n */\nfunction filter <T> (source: Iterable<T>, fn: (val: T) => Promise<boolean>): AsyncGenerator<T, void, undefined>\nfunction filter <T> (source: Iterable<T>, fn: (val: T) => boolean): Generator<T, void, undefined>\nfunction filter <T> (source: Iterable<T> | AsyncIterable<T>, fn: (val: T) => boolean | Promise<boolean>): AsyncGenerator<T, void, undefined>\nfunction filter <T> (source: Iterable<T> | AsyncIterable<T>, fn: (val: T) => boolean | Promise<boolean>): Generator<T, void, undefined> | AsyncGenerator<T, void, undefined> {\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const entry of source) {\n        if (await fn(entry)) {\n          yield entry\n        }\n      }\n    })()\n  }\n\n  // if mapping function returns a promise we have to return an async generator\n  const peekable = peek(source)\n  const { value, done } = peekable.next()\n\n  if (done === true) {\n    return (function * () {}())\n  }\n\n  const res = fn(value)\n\n  // @ts-expect-error .then is not present on O\n  if (typeof res.then === 'function') {\n    return (async function * () {\n      if (await res) {\n        yield value\n      }\n\n      for await (const entry of peekable) {\n        if (await fn(entry)) {\n          yield entry\n        }\n      }\n    })()\n  }\n\n  const func = fn as (val: T) => boolean\n\n  return (function * () {\n    if (res === true) {\n      yield value\n    }\n\n    for (const entry of peekable) {\n      if (func(entry)) {\n        yield entry\n      }\n    }\n  })()\n}\n\nexport default filter\n", "import peek from 'it-peekable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Takes an (async) iterable and returns one with each item mapped by the passed\n * function\n */\nfunction map <I, O> (source: Iterable<I>, func: (val: I) => Promise<O>): AsyncGenerator<O, void, undefined>\nfunction map <I, O> (source: Iterable<I>, func: (val: I) => O): Generator<O, void, undefined>\nfunction map <I, O> (source: AsyncIterable<I> | Iterable<I>, func: (val: I) => O | Promise<O>): AsyncGenerator<O, void, undefined>\nfunction map <I, O> (source: AsyncIterable<I> | Iterable<I>, func: (val: I) => O | Promise<O>): AsyncGenerator<O, void, undefined> | Generator<O, void, undefined> {\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const val of source) {\n        yield func(val)\n      }\n    })()\n  }\n\n  // if mapping function returns a promise we have to return an async generator\n  const peekable = peek(source)\n  const { value, done } = peekable.next()\n\n  if (done === true) {\n    return (function * () {}())\n  }\n\n  const res = func(value)\n\n  // @ts-expect-error .then is not present on O\n  if (typeof res.then === 'function') {\n    return (async function * () {\n      yield await res\n\n      for await (const val of peekable) {\n        yield func(val)\n      }\n    })()\n  }\n\n  const fn = func as (val: I) => O\n\n  return (function * () {\n    yield res as O\n\n    for (const val of peekable) {\n      yield fn(val)\n    }\n  })()\n}\n\nexport default map\n", "export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n", "/* global EventTarget Event */\n\nimport defer from 'p-defer'\n\ninterface Operation<T> {\n  done: boolean\n  ok: boolean\n  err: Error\n  value: T\n}\n\nconst CustomEvent = globalThis.CustomEvent ?? Event\n\nexport interface ParallelOptions {\n  /**\n   * How many jobs to execute in parallel (default: )\n   */\n  concurrency?: number\n  ordered?: boolean\n}\n\n/**\n * Takes an (async) iterator that emits promise-returning functions,\n * invokes them in parallel and emits the results as they become available but\n * in the same order as the input\n */\nexport default async function * parallel <T> (source: Iterable<() => Promise<T>> | AsyncIterable<() => Promise<T>>, options: ParallelOptions = {}): AsyncGenerator<T, void, undefined> {\n  let concurrency = options.concurrency ?? Infinity\n\n  if (concurrency < 1) {\n    concurrency = Infinity\n  }\n\n  const ordered = options.ordered == null ? false : options.ordered\n  const emitter = new EventTarget()\n\n  const ops: Array<Operation<T>> = []\n  let slotAvailable = defer()\n  let resultAvailable = defer()\n  let sourceFinished = false\n  let sourceErr: Error | undefined\n  let opErred = false\n\n  emitter.addEventListener('task-complete', () => {\n    resultAvailable.resolve()\n  })\n\n  void Promise.resolve().then(async () => {\n    try {\n      for await (const task of source) {\n        if (ops.length === concurrency) {\n          slotAvailable = defer()\n          await slotAvailable.promise\n        }\n\n        if (opErred) {\n          break\n        }\n\n        const op: any = {\n          done: false\n        }\n        ops.push(op)\n\n        task()\n          .then(result => {\n            op.done = true\n            op.ok = true\n            op.value = result\n            emitter.dispatchEvent(new CustomEvent('task-complete'))\n          }, err => {\n            op.done = true\n            op.err = err\n            emitter.dispatchEvent(new CustomEvent('task-complete'))\n          })\n      }\n\n      sourceFinished = true\n      emitter.dispatchEvent(new CustomEvent('task-complete'))\n    } catch (err: any) {\n      sourceErr = err\n      emitter.dispatchEvent(new CustomEvent('task-complete'))\n    }\n  })\n\n  function valuesAvailable (): boolean {\n    if (ordered) {\n      return ops[0]?.done\n    }\n\n    return Boolean(ops.find(op => op.done))\n  }\n\n  function * yieldOrderedValues (): Generator<T, void, unknown> {\n    while ((ops.length > 0) && ops[0].done) {\n      const op = ops[0]\n      ops.shift()\n\n      if (op.ok) {\n        yield op.value\n      } else {\n        // allow the source to exit\n        opErred = true\n        slotAvailable.resolve()\n\n        throw op.err\n      }\n\n      slotAvailable.resolve()\n    }\n  }\n\n  function * yieldUnOrderedValues (): Generator<T, void, unknown> {\n    // more values can become available while we wait for `yield`\n    // to return control to this function\n    while (valuesAvailable()) {\n      for (let i = 0; i < ops.length; i++) {\n        if (ops[i].done) {\n          const op = ops[i]\n          ops.splice(i, 1)\n          i--\n\n          if (op.ok) {\n            yield op.value\n          } else {\n            opErred = true\n            slotAvailable.resolve()\n\n            throw op.err\n          }\n\n          slotAvailable.resolve()\n        }\n      }\n    }\n  }\n\n  while (true) {\n    if (!valuesAvailable()) {\n      resultAvailable = defer()\n      await resultAvailable.promise\n    }\n\n    if (sourceErr != null) {\n      // the source threw an error, propagate it\n      throw sourceErr\n    }\n\n    if (ordered) {\n      yield * yieldOrderedValues()\n    } else {\n      yield * yieldUnOrderedValues()\n    }\n\n    if (sourceFinished && ops.length === 0) {\n      // not waiting for any results and no more tasks so we are done\n      break\n    }\n  }\n}\n", "// ported from https://www.npmjs.com/package/fast-fifo\n\nexport interface Next<T> {\n  done?: boolean\n  error?: Error\n  value?: T\n}\n\nclass FixedFIFO<T> {\n  public buffer: Array<Next<T> | undefined>\n  private readonly mask: number\n  private top: number\n  private btm: number\n  public next: FixedFIFO<T> | null\n\n  constructor (hwm: number) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) {\n      throw new Error('Max size for a FixedFIFO should be a power of two')\n    }\n\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  push (data: Next<T>): boolean {\n    if (this.buffer[this.top] !== undefined) {\n      return false\n    }\n\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n\n    return true\n  }\n\n  shift (): Next<T> | undefined {\n    const last = this.buffer[this.btm]\n\n    if (last === undefined) {\n      return undefined\n    }\n\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  isEmpty (): boolean {\n    return this.buffer[this.btm] === undefined\n  }\n}\n\nexport interface FIFOOptions {\n  /**\n   * When the queue reaches this size, it will be split into head/tail parts\n   */\n  splitLimit?: number\n}\n\nexport class FIFO<T> {\n  public size: number\n  private readonly hwm: number\n  private head: FixedFIFO<T>\n  private tail: FixedFIFO<T>\n\n  constructor (options: FIFOOptions = {}) {\n    this.hwm = options.splitLimit ?? 16\n    this.head = new FixedFIFO<T>(this.hwm)\n    this.tail = this.head\n    this.size = 0\n  }\n\n  calculateSize (obj: any): number {\n    if (obj?.byteLength != null) {\n      return obj.byteLength\n    }\n\n    return 1\n  }\n\n  push (val: Next<T>): void {\n    if (val?.value != null) {\n      this.size += this.calculateSize(val.value)\n    }\n\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO<T>(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift (): Next<T> | undefined {\n    let val = this.tail.shift()\n\n    if (val === undefined && (this.tail.next != null)) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      val = this.tail.shift()\n    }\n\n    if (val?.value != null) {\n      this.size -= this.calculateSize(val.value)\n    }\n\n    return val\n  }\n\n  isEmpty (): boolean {\n    return this.head.isEmpty()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\n\nimport deferred from 'p-defer'\nimport { FIFO, type Next } from './fifo.js'\n\nexport class AbortError extends Error {\n  type: string\n  code: string\n\n  constructor (message?: string, code?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\ninterface BasePushable<T> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end: (err?: Error) => this\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push: (value: T) => this\n\n  /**\n   * Returns a promise that resolves when the underlying queue becomes empty (e.g.\n   * this.readableLength === 0).\n   *\n   * If an AbortSignal is passed as an option and that signal aborts, it only\n   * causes the returned promise to reject - it does not end the pushable.\n   */\n  onEmpty: (options?: AbortOptions) => Promise<void>\n\n  /**\n   * This property contains the number of bytes (or objects) in the queue ready to be read.\n   *\n   * If `objectMode` is true, this is the number of objects in the queue, if false it's the\n   * total number of bytes in the queue.\n   */\n  readableLength: number\n}\n\n/**\n * An iterable that you can push values into.\n */\nexport interface Pushable<T, R = void, N = unknown> extends AsyncGenerator<T, R, N>, BasePushable<T> {}\n\n/**\n * Similar to `pushable`, except it yields multiple buffered chunks at a time. All values yielded from the iterable will be arrays.\n */\nexport interface PushableV<T, R = void, N = unknown> extends AsyncGenerator<T[], R, N>, BasePushable<T> {}\n\nexport interface Options {\n  /**\n   * A boolean value that means non-`Uint8Array`s will be passed to `.push`, default: `false`\n   */\n  objectMode?: boolean\n\n  /**\n   * A function called after *all* values have been yielded from the iterator (including\n   * buffered values). In the case when the iterator is ended with an error it will be\n   * passed the error as a parameter.\n   */\n  onEnd?: (err?: Error) => void\n}\n\nexport interface DoneResult { done: true }\nexport interface ValueResult<T> { done: false, value: T }\nexport type NextResult<T> = ValueResult<T> | DoneResult\n\ninterface getNext<T, V = T> { (buffer: FIFO<T>): NextResult<V> }\n\nexport interface ObjectPushableOptions extends Options {\n  objectMode: true\n}\n\nexport interface BytePushableOptions extends Options {\n  objectMode?: false\n}\n\n/**\n * Create a new async iterable. The values yielded from calls to `.next()`\n * or when used in a `for await of`loop are \"pushed\" into the iterable.\n * Returns an async iterable object with additional methods.\n */\nexport function pushable<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): Pushable<T>\nexport function pushable<T> (options: ObjectPushableOptions): Pushable<T>\nexport function pushable<T> (options: Options = {}): Pushable<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T> => {\n    const next: Next<T> | undefined = buffer.shift()\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    if (next.error != null) {\n      throw next.error\n    }\n\n    return {\n      done: next.done === true,\n      // @ts-expect-error if done is false, value will be present\n      value: next.value\n    }\n  }\n\n  return _pushable<T, T, Pushable<T>>(getNext, options)\n}\n\nexport function pushableV<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): PushableV<T>\nexport function pushableV<T> (options: ObjectPushableOptions): PushableV<T>\nexport function pushableV<T> (options: Options = {}): PushableV<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T[]> => {\n    let next: Next<T> | undefined\n    const values: T[] = []\n\n    while (!buffer.isEmpty()) {\n      next = buffer.shift()\n\n      if (next == null) {\n        break\n      }\n\n      if (next.error != null) {\n        throw next.error\n      }\n\n      if (next.done === false) {\n        // @ts-expect-error if done is false value should be pushed\n        values.push(next.value)\n      }\n    }\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    return {\n      done: next.done === true,\n      value: values\n    }\n  }\n\n  return _pushable<T, T[], PushableV<T>>(getNext, options)\n}\n\nfunction _pushable<PushType, ValueType, ReturnType> (getNext: getNext<PushType, ValueType>, options?: Options): ReturnType {\n  options = options ?? {}\n  let onEnd = options.onEnd\n  let buffer = new FIFO<PushType>()\n  let pushable: any\n  let onNext: ((next: Next<PushType>) => ReturnType) | null\n  let ended: boolean\n  let drain = deferred()\n\n  const waitNext = async (): Promise<NextResult<ValueType>> => {\n    try {\n      if (!buffer.isEmpty()) {\n        return getNext(buffer)\n      }\n\n      if (ended) {\n        return { done: true }\n      }\n\n      return await new Promise<NextResult<ValueType>>((resolve, reject) => {\n        onNext = (next: Next<PushType>) => {\n          onNext = null\n          buffer.push(next)\n\n          try {\n            resolve(getNext(buffer))\n          } catch (err) {\n            reject(err)\n          }\n\n          return pushable\n        }\n      })\n    } finally {\n      if (buffer.isEmpty()) {\n        // settle promise in the microtask queue to give consumers a chance to\n        // await after calling .push\n        queueMicrotask(() => {\n          drain.resolve()\n          drain = deferred()\n        })\n      }\n    }\n  }\n\n  const bufferNext = (next: Next<PushType>): ReturnType => {\n    if (onNext != null) {\n      return onNext(next)\n    }\n\n    buffer.push(next)\n    return pushable\n  }\n\n  const bufferError = (err: Error): ReturnType => {\n    buffer = new FIFO()\n\n    if (onNext != null) {\n      return onNext({ error: err })\n    }\n\n    buffer.push({ error: err })\n    return pushable\n  }\n\n  const push = (value: PushType): ReturnType => {\n    if (ended) {\n      return pushable\n    }\n\n    // @ts-expect-error `byteLength` is not declared on PushType\n    if (options?.objectMode !== true && value?.byteLength == null) {\n      throw new Error('objectMode was not true but tried to push non-Uint8Array value')\n    }\n\n    return bufferNext({ done: false, value })\n  }\n  const end = (err?: Error): ReturnType => {\n    if (ended) return pushable\n    ended = true\n\n    return (err != null) ? bufferError(err) : bufferNext({ done: true })\n  }\n  const _return = (): DoneResult => {\n    buffer = new FIFO()\n    end()\n\n    return { done: true }\n  }\n  const _throw = (err: Error): DoneResult => {\n    end(err)\n\n    return { done: true }\n  }\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next: waitNext,\n    return: _return,\n    throw: _throw,\n    push,\n    end,\n    get readableLength (): number {\n      return buffer.size\n    },\n    onEmpty: async (options?: AbortOptions) => {\n      const signal = options?.signal\n      signal?.throwIfAborted()\n\n      if (buffer.isEmpty()) {\n        return\n      }\n\n      let cancel: Promise<void> | undefined\n      let listener: (() => void) | undefined\n\n      if (signal != null) {\n        cancel = new Promise((resolve, reject) => {\n          listener = () => {\n            reject(new AbortError())\n          }\n\n          signal.addEventListener('abort', listener)\n        })\n      }\n\n      try {\n        await Promise.race([\n          drain.promise,\n          cancel\n        ])\n      } finally {\n        if (listener != null && signal != null) {\n          signal?.removeEventListener('abort', listener)\n        }\n      }\n    }\n  }\n\n  if (onEnd == null) {\n    return pushable\n  }\n\n  const _pushable = pushable\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next () {\n      return _pushable.next()\n    },\n    throw (err: Error) {\n      _pushable.throw(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    return () {\n      _pushable.return()\n\n      if (onEnd != null) {\n        onEnd()\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    push,\n    end (err: Error) {\n      _pushable.end(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return pushable\n    },\n    get readableLength () {\n      return _pushable.readableLength\n    }\n  }\n\n  return pushable\n}\n", "import { pushable } from 'it-pushable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\n/**\n * Treat one or more iterables as a single iterable.\n *\n * Nb. sources are iterated over in parallel so the\n * order of emitted items is not guaranteed.\n */\nfunction merge <T> (...sources: Array<Iterable<T>>): Generator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  const syncSources: Array<Iterable<T>> = []\n\n  for (const source of sources) {\n    if (!isAsyncIterable(source)) {\n      syncSources.push(source)\n    }\n  }\n\n  if (syncSources.length === sources.length) {\n    // all sources are synchronous\n    return (function * () {\n      for (const source of syncSources) {\n        yield * source\n      }\n    })()\n  }\n\n  return (async function * () {\n    const output = pushable<T>({\n      objectMode: true\n    })\n\n    void Promise.resolve().then(async () => {\n      try {\n        await Promise.all(\n          sources.map(async (source) => {\n            for await (const item of source) {\n              output.push(item)\n            }\n          })\n        )\n\n        output.end()\n      } catch (err: any) {\n        output.end(err)\n      }\n    })\n\n    yield * output\n  })()\n}\n\nexport default merge\n", "import { pushable } from 'it-pushable'\nimport merge from 'it-merge'\nimport type { Duplex, Transform, Sink } from 'it-stream-types'\n\ninterface SourceFn<A = any> { (): A }\n\ntype PipeSource<A = any> =\n  Iterable<A> |\n  AsyncIterable<A> |\n  SourceFn<A> |\n  Duplex<A, any, any>\n\ntype PipeTransform<A = any, B = any> =\n  Transform<A, B> |\n  Duplex<B, A>\n\ntype PipeSink<A = any, B = any> =\n  Sink<A, B> |\n  Duplex<any, A, B>\n\ntype PipeOutput<A> =\n  A extends Sink<any> ? ReturnType<A> :\n    A extends Duplex<any, any, any> ? ReturnType<A['sink']> :\n      never\n\n// single item pipe output includes pipe source types\ntype SingleItemPipeOutput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Duplex<any, any, any> ? A['source'] :\n          PipeOutput<A>\n\ntype PipeFnInput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Transform<any, any> ? ReturnType<A> :\n          A extends Duplex<any, any, any> ? A['source'] :\n            never\n\n// one item, just a pass-through\nexport function pipe<\n  A extends PipeSource\n> (\n  source: A\n): SingleItemPipeOutput<A>\n\n// two items, source to sink\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeSink<PipeFnInput<A>>\n> (\n  source: A,\n  sink: B\n): PipeOutput<B>\n\n// three items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeSink<PipeFnInput<B>>\n> (\n  source: A,\n  transform1: B,\n  sink: C\n): PipeOutput<C>\n\n// many items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeSink<PipeFnInput<C>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  sink: D\n): PipeOutput<D>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeSink<PipeFnInput<D>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  sink: E\n): PipeOutput<E>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeSink<PipeFnInput<E>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  sink: F\n): PipeOutput<F>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeSink<PipeFnInput<F>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  sink: G\n): PipeOutput<G>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeSink<PipeFnInput<G>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  sink: H\n): PipeOutput<H>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeSink<PipeFnInput<H>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  sink: I\n): PipeOutput<I>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeSink<PipeFnInput<I>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  sink: J\n): PipeOutput<J>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeSink<PipeFnInput<J>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  sink: K\n): PipeOutput<K>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeTransform<PipeFnInput<J>>,\n  L extends PipeSink<PipeFnInput<K>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  transform10: K,\n  sink: L\n): PipeOutput<L>\n\nexport function pipe (first: any, ...rest: any[]): any {\n  if (first == null) {\n    throw new Error('Empty pipeline')\n  }\n\n  // Duplex at start: wrap in function and return duplex source\n  if (isDuplex(first)) {\n    const duplex = first\n    first = () => duplex.source\n  // Iterable at start: wrap in function\n  } else if (isIterable(first) || isAsyncIterable(first)) {\n    const source = first\n    first = () => source\n  }\n\n  const fns = [first, ...rest]\n\n  if (fns.length > 1) {\n    // Duplex at end: use duplex sink\n    if (isDuplex(fns[fns.length - 1])) {\n      fns[fns.length - 1] = fns[fns.length - 1].sink\n    }\n  }\n\n  if (fns.length > 2) {\n    // Duplex in the middle, consume source with duplex sink and return duplex source\n    for (let i = 1; i < fns.length - 1; i++) {\n      if (isDuplex(fns[i])) {\n        fns[i] = duplexPipelineFn(fns[i])\n      }\n    }\n  }\n\n  return rawPipe(...fns)\n}\n\nexport const rawPipe = (...fns: any): any => {\n  let res\n  while (fns.length > 0) {\n    res = fns.shift()(res)\n  }\n  return res\n}\n\nconst isAsyncIterable = (obj: any): obj is AsyncIterable<unknown> => {\n  return obj?.[Symbol.asyncIterator] != null\n}\n\nconst isIterable = (obj: any): obj is Iterable<unknown> => {\n  return obj?.[Symbol.iterator] != null\n}\n\nconst isDuplex = (obj: any): obj is Duplex => {\n  if (obj == null) {\n    return false\n  }\n\n  return obj.sink != null && obj.source != null\n}\n\nconst duplexPipelineFn = (duplex: Duplex<any, any, any>) => {\n  return (source: any) => {\n    const p = duplex.sink(source)\n\n    if (p?.then != null) {\n      const stream = pushable<any>({\n        objectMode: true\n      })\n      p.then(() => {\n        stream.end()\n      }, (err: Error) => {\n        stream.end(err)\n      })\n\n      let sourceWrap: () => Iterable<any> | AsyncIterable<any>\n      const source = duplex.source\n\n      if (isAsyncIterable(source)) {\n        sourceWrap = async function * () {\n          yield * source\n          stream.end()\n        }\n      } else if (isIterable(source)) {\n        sourceWrap = function * () {\n          yield * source\n          stream.end()\n        }\n      } else {\n        throw new Error('Unknown duplex source type - must be Iterable or AsyncIterable')\n      }\n\n      return merge(stream, sourceWrap())\n    }\n\n    return duplex.source\n  }\n}\n", "import filter from 'it-filter'\nimport map from 'it-map'\nimport parallel from 'it-parallel'\nimport { pipe } from 'it-pipe'\nimport { CustomProgressEvent } from 'progress-events'\nimport type { ExporterOptions, ExportWalk, UnixfsV1DirectoryContent, UnixfsV1Resolver } from '../../../index.js'\n\nconst directoryContent: UnixfsV1Resolver = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  async function * yieldDirectoryContent (options: ExporterOptions = {}): UnixfsV1DirectoryContent {\n    const offset = options.offset ?? 0\n    const length = options.length ?? node.Links.length\n    const links = node.Links.slice(offset, length)\n\n    options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:directory', {\n      cid\n    }))\n\n    yield * pipe(\n      links,\n      source => map(source, link => {\n        return async () => {\n          const linkName = link.Name ?? ''\n          const linkPath = `${path}/${linkName}`\n          const result = await resolve(link.Hash, linkName, linkPath, [], depth + 1, blockstore, options)\n          return result.entry\n        }\n      }),\n      source => parallel(source, { ordered: true }),\n      source => filter(source, entry => entry != null)\n    )\n  }\n\n  return yieldDirectoryContent\n}\n\nexport default directoryContent\n", "import * as dagPb from '@ipld/dag-pb'\nimport errCode from 'err-code'\nimport { UnixFS } from 'ipfs-unixfs'\nimport map from 'it-map'\nimport parallel from 'it-parallel'\nimport { pipe } from 'it-pipe'\nimport { type Pushable, pushable } from 'it-pushable'\nimport * as raw from 'multiformats/codecs/raw'\nimport PQueue from 'p-queue'\nimport { CustomProgressEvent } from 'progress-events'\nimport extractDataFromBlock from '../../../utils/extract-data-from-block.js'\nimport validateOffsetAndLength from '../../../utils/validate-offset-and-length.js'\nimport type { ExporterOptions, UnixfsV1FileContent, UnixfsV1Resolver, ReadableStorage, ExportProgress, ExportWalk } from '../../../index.js'\n\nasync function walkDAG (blockstore: ReadableStorage, node: dagPb.PBNode | Uint8Array, queue: Pushable<Uint8Array>, streamPosition: bigint, start: bigint, end: bigint, options: ExporterOptions): Promise<void> {\n  // a `raw` node\n  if (node instanceof Uint8Array) {\n    const buf = extractDataFromBlock(node, streamPosition, start, end)\n\n    queue.push(buf)\n\n    return\n  }\n\n  if (node.Data == null) {\n    throw errCode(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS')\n  }\n\n  let file: UnixFS\n\n  try {\n    file = UnixFS.unmarshal(node.Data)\n  } catch (err: any) {\n    throw errCode(err, 'ERR_NOT_UNIXFS')\n  }\n\n  // might be a unixfs `raw` node or have data on intermediate nodes\n  if (file.data != null) {\n    const data = file.data\n    const buf = extractDataFromBlock(data, streamPosition, start, end)\n\n    queue.push(buf)\n\n    streamPosition += BigInt(buf.byteLength)\n  }\n\n  const childOps: Array<{ link: dagPb.PBLink, blockStart: bigint }> = []\n\n  if (node.Links.length !== file.blockSizes.length) {\n    throw errCode(new Error('Inconsistent block sizes and dag links'), 'ERR_NOT_UNIXFS')\n  }\n\n  for (let i = 0; i < node.Links.length; i++) {\n    const childLink = node.Links[i]\n    const childStart = streamPosition // inclusive\n    const childEnd = childStart + file.blockSizes[i] // exclusive\n\n    if ((start >= childStart && start < childEnd) || // child has offset byte\n        (end >= childStart && end <= childEnd) || // child has end byte\n        (start < childStart && end > childEnd)) { // child is between offset and end bytes\n      childOps.push({\n        link: childLink,\n        blockStart: streamPosition\n      })\n    }\n\n    streamPosition = childEnd\n\n    if (streamPosition > end) {\n      break\n    }\n  }\n\n  await pipe(\n    childOps,\n    (source) => map(source, (op) => {\n      return async () => {\n        const block = await blockstore.get(op.link.Hash, options)\n\n        return {\n          ...op,\n          block\n        }\n      }\n    }),\n    (source) => parallel(source, {\n      ordered: true\n    }),\n    async (source) => {\n      for await (const { link, block, blockStart } of source) {\n        let child: dagPb.PBNode | Uint8Array\n        switch (link.Hash.code) {\n          case dagPb.code:\n            child = dagPb.decode(block)\n            break\n          case raw.code:\n            child = block\n            break\n          default:\n            queue.end(errCode(new Error(`Unsupported codec: ${link.Hash.code}`), 'ERR_NOT_UNIXFS'))\n            return\n        }\n\n        // create a queue for this child - we use a queue instead of recursion\n        // to avoid overflowing the stack\n        const childQueue = new PQueue({\n          concurrency: 1\n        })\n        // if any of the child jobs error, end the read queue with the error\n        childQueue.on('error', error => {\n          queue.end(error)\n        })\n\n        // if the job rejects the 'error' event will be emitted on the child queue\n        void childQueue.add(async () => {\n          options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:file', {\n            cid: link.Hash\n          }))\n\n          await walkDAG(blockstore, child, queue, blockStart, start, end, options)\n        })\n\n        // wait for this child to complete before moving on to the next\n        await childQueue.onIdle()\n      }\n    }\n  )\n\n  if (streamPosition >= end) {\n    queue.end()\n  }\n}\n\nconst fileContent: UnixfsV1Resolver = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  async function * yieldFileContent (options: ExporterOptions = {}): UnixfsV1FileContent {\n    const fileSize = unixfs.fileSize()\n\n    if (fileSize === undefined) {\n      throw new Error('File was a directory')\n    }\n\n    const {\n      start,\n      end\n    } = validateOffsetAndLength(fileSize, options.offset, options.length)\n\n    if (end === 0n) {\n      return\n    }\n\n    let read = 0n\n    const wanted = end - start\n    const queue = pushable()\n\n    options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:file', {\n      cid\n    }))\n\n    void walkDAG(blockstore, node, queue, 0n, start, end, options)\n      .catch(err => {\n        queue.end(err)\n      })\n\n    for await (const buf of queue) {\n      if (buf == null) {\n        continue\n      }\n\n      read += BigInt(buf.byteLength)\n\n      if (read > wanted) {\n        queue.end()\n        throw errCode(new Error('Read too many bytes - the file size reported by the UnixFS data in the root node may be incorrect'), 'ERR_OVER_READ')\n      }\n\n      if (read === wanted) {\n        queue.end()\n      }\n\n      options.onProgress?.(new CustomProgressEvent<ExportProgress>('unixfs:exporter:progress:unixfs:file', {\n        bytesRead: read,\n        totalBytes: wanted,\n        fileSize\n      }))\n\n      yield buf\n    }\n\n    if (read < wanted) {\n      throw errCode(new Error('Traversed entire DAG but did not read enough bytes'), 'ERR_UNDER_READ')\n    }\n  }\n\n  return yieldFileContent\n}\n\nexport default fileContent\n", "var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _PQueue_instances, _PQueue_carryoverConcurrencyCount, _PQueue_isIntervalIgnored, _PQueue_intervalCount, _PQueue_intervalCap, _PQueue_interval, _PQueue_intervalEnd, _PQueue_intervalId, _PQueue_timeoutId, _PQueue_queue, _PQueue_queueClass, _PQueue_pending, _PQueue_concurrency, _PQueue_isPaused, _PQueue_throwOnTimeout, _PQueue_doesIntervalAllowAnother_get, _PQueue_doesConcurrentAllowAnother_get, _PQueue_next, _PQueue_onResumeInterval, _PQueue_isIntervalPaused_get, _PQueue_tryToStartAnother, _PQueue_initializeIntervalIfNeeded, _PQueue_onInterval, _PQueue_processQueue, _PQueue_throwOnAbort, _PQueue_onEvent;\nimport EventEmitter from 'eventemitter3';\nimport pTimeout, { TimeoutError } from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nThe error thrown by `queue.add()` when a job is aborted before it is run. See `signal`.\n*/\nexport class AbortError extends Error {\n}\n/**\nPromise queue with concurrency control.\n*/\nexport default class PQueue extends EventEmitter {\n    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`\n    constructor(options) {\n        var _a, _b, _c, _d;\n        super();\n        _PQueue_instances.add(this);\n        _PQueue_carryoverConcurrencyCount.set(this, void 0);\n        _PQueue_isIntervalIgnored.set(this, void 0);\n        _PQueue_intervalCount.set(this, 0);\n        _PQueue_intervalCap.set(this, void 0);\n        _PQueue_interval.set(this, void 0);\n        _PQueue_intervalEnd.set(this, 0);\n        _PQueue_intervalId.set(this, void 0);\n        _PQueue_timeoutId.set(this, void 0);\n        _PQueue_queue.set(this, void 0);\n        _PQueue_queueClass.set(this, void 0);\n        _PQueue_pending.set(this, 0);\n        // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n        _PQueue_concurrency.set(this, void 0);\n        _PQueue_isPaused.set(this, void 0);\n        _PQueue_throwOnTimeout.set(this, void 0);\n        /**\n        Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.\n    \n        Applies to each future operation.\n        */\n        Object.defineProperty(this, \"timeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverConcurrencyCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            ...options,\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''}\\` (${typeof options.interval})`);\n        }\n        __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, options.carryoverConcurrencyCount, \"f\");\n        __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, \"f\");\n        __classPrivateFieldSet(this, _PQueue_intervalCap, options.intervalCap, \"f\");\n        __classPrivateFieldSet(this, _PQueue_interval, options.interval, \"f\");\n        __classPrivateFieldSet(this, _PQueue_queue, new options.queueClass(), \"f\");\n        __classPrivateFieldSet(this, _PQueue_queueClass, options.queueClass, \"f\");\n        this.concurrency = options.concurrency;\n        this.timeout = options.timeout;\n        __classPrivateFieldSet(this, _PQueue_throwOnTimeout, options.throwOnTimeout === true, \"f\");\n        __classPrivateFieldSet(this, _PQueue_isPaused, options.autoStart === false, \"f\");\n    }\n    get concurrency() {\n        return __classPrivateFieldGet(this, _PQueue_concurrency, \"f\");\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        __classPrivateFieldSet(this, _PQueue_concurrency, newConcurrency, \"f\");\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n    }\n    async add(function_, options = {}) {\n        options = {\n            timeout: this.timeout,\n            throwOnTimeout: __classPrivateFieldGet(this, _PQueue_throwOnTimeout, \"f\"),\n            ...options,\n        };\n        return new Promise((resolve, reject) => {\n            __classPrivateFieldGet(this, _PQueue_queue, \"f\").enqueue(async () => {\n                var _a;\n                var _b, _c;\n                __classPrivateFieldSet(this, _PQueue_pending, (_b = __classPrivateFieldGet(this, _PQueue_pending, \"f\"), _b++, _b), \"f\");\n                __classPrivateFieldSet(this, _PQueue_intervalCount, (_c = __classPrivateFieldGet(this, _PQueue_intervalCount, \"f\"), _c++, _c), \"f\");\n                try {\n                    // TODO: Use options.signal?.throwIfAborted() when targeting Node.js 18\n                    if ((_a = options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {\n                        // TODO: Use ABORT_ERR code when targeting Node.js 16 (https://nodejs.org/docs/latest-v16.x/api/errors.html#abort_err)\n                        throw new AbortError('The task was aborted.');\n                    }\n                    let operation = function_({ signal: options.signal });\n                    if (options.timeout) {\n                        operation = pTimeout(Promise.resolve(operation), options.timeout);\n                    }\n                    if (options.signal) {\n                        operation = Promise.race([operation, __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_throwOnAbort).call(this, options.signal)]);\n                    }\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    if (error instanceof TimeoutError && !options.throwOnTimeout) {\n                        resolve();\n                        return;\n                    }\n                    reject(error);\n                    this.emit('error', error);\n                }\n                finally {\n                    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_next).call(this);\n                }\n            }, options);\n            this.emit('add');\n            __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this);\n        });\n    }\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!__classPrivateFieldGet(this, _PQueue_isPaused, \"f\")) {\n            return this;\n        }\n        __classPrivateFieldSet(this, _PQueue_isPaused, false, \"f\");\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        __classPrivateFieldSet(this, _PQueue_isPaused, true, \"f\");\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet(this, _PQueue_queueClass, \"f\"))(), \"f\");\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'empty');\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size < limit) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'next', () => __classPrivateFieldGet(this, _PQueue_queue, \"f\").size < limit);\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (__classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n            return;\n        }\n        await __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onEvent).call(this, 'idle');\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return __classPrivateFieldGet(this, _PQueue_queue, \"f\").size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return __classPrivateFieldGet(this, _PQueue_queue, \"f\").filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return __classPrivateFieldGet(this, _PQueue_pending, \"f\");\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return __classPrivateFieldGet(this, _PQueue_isPaused, \"f\");\n    }\n}\n_PQueue_carryoverConcurrencyCount = new WeakMap(), _PQueue_isIntervalIgnored = new WeakMap(), _PQueue_intervalCount = new WeakMap(), _PQueue_intervalCap = new WeakMap(), _PQueue_interval = new WeakMap(), _PQueue_intervalEnd = new WeakMap(), _PQueue_intervalId = new WeakMap(), _PQueue_timeoutId = new WeakMap(), _PQueue_queue = new WeakMap(), _PQueue_queueClass = new WeakMap(), _PQueue_pending = new WeakMap(), _PQueue_concurrency = new WeakMap(), _PQueue_isPaused = new WeakMap(), _PQueue_throwOnTimeout = new WeakMap(), _PQueue_instances = new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function _PQueue_doesIntervalAllowAnother_get() {\n    return __classPrivateFieldGet(this, _PQueue_isIntervalIgnored, \"f\") || __classPrivateFieldGet(this, _PQueue_intervalCount, \"f\") < __classPrivateFieldGet(this, _PQueue_intervalCap, \"f\");\n}, _PQueue_doesConcurrentAllowAnother_get = function _PQueue_doesConcurrentAllowAnother_get() {\n    return __classPrivateFieldGet(this, _PQueue_pending, \"f\") < __classPrivateFieldGet(this, _PQueue_concurrency, \"f\");\n}, _PQueue_next = function _PQueue_next() {\n    var _a;\n    __classPrivateFieldSet(this, _PQueue_pending, (_a = __classPrivateFieldGet(this, _PQueue_pending, \"f\"), _a--, _a), \"f\");\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this);\n    this.emit('next');\n}, _PQueue_onResumeInterval = function _PQueue_onResumeInterval() {\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onInterval).call(this);\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_initializeIntervalIfNeeded).call(this);\n    __classPrivateFieldSet(this, _PQueue_timeoutId, undefined, \"f\");\n}, _PQueue_isIntervalPaused_get = function _PQueue_isIntervalPaused_get() {\n    const now = Date.now();\n    if (__classPrivateFieldGet(this, _PQueue_intervalId, \"f\") === undefined) {\n        const delay = __classPrivateFieldGet(this, _PQueue_intervalEnd, \"f\") - now;\n        if (delay < 0) {\n            // Act as the interval was done\n            // We don't need to resume it here because it will be resumed on line 160\n            __classPrivateFieldSet(this, _PQueue_intervalCount, (__classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, \"f\")) ? __classPrivateFieldGet(this, _PQueue_pending, \"f\") : 0, \"f\");\n        }\n        else {\n            // Act as the interval is pending\n            if (__classPrivateFieldGet(this, _PQueue_timeoutId, \"f\") === undefined) {\n                __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(() => {\n                    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onResumeInterval).call(this);\n                }, delay), \"f\");\n            }\n            return true;\n        }\n    }\n    return false;\n}, _PQueue_tryToStartAnother = function _PQueue_tryToStartAnother() {\n    if (__classPrivateFieldGet(this, _PQueue_queue, \"f\").size === 0) {\n        // We can clear the interval (\"pause\")\n        // Because we can redo it later (\"resume\")\n        if (__classPrivateFieldGet(this, _PQueue_intervalId, \"f\")) {\n            clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, \"f\"));\n        }\n        __classPrivateFieldSet(this, _PQueue_intervalId, undefined, \"f\");\n        this.emit('empty');\n        if (__classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0) {\n            this.emit('idle');\n        }\n        return false;\n    }\n    if (!__classPrivateFieldGet(this, _PQueue_isPaused, \"f\")) {\n        const canInitializeInterval = !__classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_isIntervalPaused_get);\n        if (__classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet(this, _PQueue_instances, \"a\", _PQueue_doesConcurrentAllowAnother_get)) {\n            const job = __classPrivateFieldGet(this, _PQueue_queue, \"f\").dequeue();\n            if (!job) {\n                return false;\n            }\n            this.emit('active');\n            job();\n            if (canInitializeInterval) {\n                __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_initializeIntervalIfNeeded).call(this);\n            }\n            return true;\n        }\n    }\n    return false;\n}, _PQueue_initializeIntervalIfNeeded = function _PQueue_initializeIntervalIfNeeded() {\n    if (__classPrivateFieldGet(this, _PQueue_isIntervalIgnored, \"f\") || __classPrivateFieldGet(this, _PQueue_intervalId, \"f\") !== undefined) {\n        return;\n    }\n    __classPrivateFieldSet(this, _PQueue_intervalId, setInterval(() => {\n        __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_onInterval).call(this);\n    }, __classPrivateFieldGet(this, _PQueue_interval, \"f\")), \"f\");\n    __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet(this, _PQueue_interval, \"f\"), \"f\");\n}, _PQueue_onInterval = function _PQueue_onInterval() {\n    if (__classPrivateFieldGet(this, _PQueue_intervalCount, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_pending, \"f\") === 0 && __classPrivateFieldGet(this, _PQueue_intervalId, \"f\")) {\n        clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, \"f\"));\n        __classPrivateFieldSet(this, _PQueue_intervalId, undefined, \"f\");\n    }\n    __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, \"f\") ? __classPrivateFieldGet(this, _PQueue_pending, \"f\") : 0, \"f\");\n    __classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_processQueue).call(this);\n}, _PQueue_processQueue = function _PQueue_processQueue() {\n    // eslint-disable-next-line no-empty\n    while (__classPrivateFieldGet(this, _PQueue_instances, \"m\", _PQueue_tryToStartAnother).call(this)) { }\n}, _PQueue_throwOnAbort = async function _PQueue_throwOnAbort(signal) {\n    return new Promise((_resolve, reject) => {\n        signal.addEventListener('abort', () => {\n            // TODO: Reject with signal.throwIfAborted() when targeting Node.js 18\n            // TODO: Use ABORT_ERR code when targeting Node.js 16 (https://nodejs.org/docs/latest-v16.x/api/errors.html#abort_err)\n            reject(new AbortError('The task was aborted.'));\n        }, { once: true });\n    });\n}, _PQueue_onEvent = async function _PQueue_onEvent(event, filter) {\n    return new Promise(resolve => {\n        const listener = () => {\n            if (filter && !filter()) {\n                return;\n            }\n            this.off(event, listener);\n            resolve();\n        };\n        this.on(event, listener);\n    });\n};\n", "export class TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\n/**\nAn error to be thrown when the request is aborted by AbortController.\nDOMException is thrown instead of this Error when DOMException is available.\n*/\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\n/**\nTODO: Remove AbortError and just throw DOMException when targeting Node 18.\n*/\nconst getDOMException = errorMessage => globalThis.DOMException === undefined ?\n\tnew AbortError(errorMessage) :\n\tnew DOMException(errorMessage);\n\n/**\nTODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\n*/\nconst getAbortedReason = signal => {\n\tconst reason = signal.reason === undefined ?\n\t\tgetDOMException('This operation was aborted.') :\n\t\tsignal.reason;\n\n\treturn reason instanceof Error ? reason : getDOMException(reason);\n};\n\nexport default function pTimeout(promise, milliseconds, fallback, options) {\n\tlet timer;\n\n\tconst cancelablePromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n\t\t\tthrow new TypeError(`Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``);\n\t\t}\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\tresolve(promise);\n\t\t\treturn;\n\t\t}\n\n\t\toptions = {\n\t\t\tcustomTimers: {setTimeout, clearTimeout},\n\t\t\t...options\n\t\t};\n\n\t\tif (options.signal) {\n\t\t\tconst {signal} = options;\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t}\n\n\t\t\tsignal.addEventListener('abort', () => {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t});\n\t\t}\n\n\t\ttimer = options.customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (typeof fallback === 'function') {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst message = typeof fallback === 'string' ? fallback : `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\tconst timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\treject(timeoutError);\n\t\t}, milliseconds);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tresolve(await promise);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t} finally {\n\t\t\t\toptions.customTimers.clearTimeout.call(undefined, timer);\n\t\t\t}\n\t\t})();\n\t});\n\n\tcancelablePromise.clear = () => {\n\t\tclearTimeout(timer);\n\t\ttimer = undefined;\n\t};\n\n\treturn cancelablePromise;\n}\n", "// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nexport default function lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = Math.trunc(count / 2);\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\n", "var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _PriorityQueue_queue;\nimport lowerBound from './lower-bound.js';\nexport default class PriorityQueue {\n    constructor() {\n        _PriorityQueue_queue.set(this, []);\n    }\n    enqueue(run, options) {\n        options = {\n            priority: 0,\n            ...options,\n        };\n        const element = {\n            priority: options.priority,\n            run,\n        };\n        if (this.size && __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\")[this.size - 1].priority >= options.priority) {\n            __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").push(element);\n            return;\n        }\n        const index = lowerBound(__classPrivateFieldGet(this, _PriorityQueue_queue, \"f\"), element, (a, b) => b.priority - a.priority);\n        __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").splice(index, 0, element);\n    }\n    dequeue() {\n        const item = __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").shift();\n        return item === null || item === void 0 ? void 0 : item.run;\n    }\n    filter(options) {\n        return __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return __classPrivateFieldGet(this, _PriorityQueue_queue, \"f\").length;\n    }\n}\n_PriorityQueue_queue = new WeakMap();\n", "import { decode, type PBNode } from '@ipld/dag-pb'\nimport map from 'it-map'\nimport parallel from 'it-parallel'\nimport { pipe } from 'it-pipe'\nimport { CustomProgressEvent } from 'progress-events'\nimport type { ExporterOptions, Resolve, UnixfsV1DirectoryContent, UnixfsV1Resolver, ReadableStorage, ExportWalk } from '../../../index.js'\n\nconst hamtShardedDirectoryContent: UnixfsV1Resolver = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  function yieldHamtDirectoryContent (options: ExporterOptions = {}): UnixfsV1DirectoryContent {\n    options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:hamt-sharded-directory', {\n      cid\n    }))\n\n    return listDirectory(node, path, resolve, depth, blockstore, options)\n  }\n\n  return yieldHamtDirectoryContent\n}\n\nasync function * listDirectory (node: PBNode, path: string, resolve: Resolve, depth: number, blockstore: ReadableStorage, options: ExporterOptions): UnixfsV1DirectoryContent {\n  const links = node.Links\n\n  const results = pipe(\n    links,\n    source => map(source, link => {\n      return async () => {\n        const name = link.Name != null ? link.Name.substring(2) : null\n\n        if (name != null && name !== '') {\n          const result = await resolve(link.Hash, name, `${path}/${name}`, [], depth + 1, blockstore, options)\n\n          return { entries: result.entry == null ? [] : [result.entry] }\n        } else {\n          // descend into subshard\n          const block = await blockstore.get(link.Hash, options)\n          node = decode(block)\n\n          options.onProgress?.(new CustomProgressEvent<ExportWalk>('unixfs:exporter:walk:hamt-sharded-directory', {\n            cid: link.Hash\n          }))\n\n          return { entries: listDirectory(node, path, resolve, depth, blockstore, options) }\n        }\n      }\n    }),\n    source => parallel(source, { ordered: true })\n  )\n\n  for await (const { entries } of results) {\n    yield * entries\n  }\n}\n\nexport default hamtShardedDirectoryContent\n", "// from https://github.com/web3-storage/w3up/blob/main/packages/upload-client/src/unixfs.js#L165\nimport * as UnixFS from '@ipld/unixfs'\nimport * as raw from 'multiformats/codecs/raw'\nimport { withMaxChunkSize } from '@ipld/unixfs/file/chunker/fixed'\nimport { withWidth } from '@ipld/unixfs/file/layout/balanced'\n\nimport type { View } from '@ipld/unixfs'\nimport { AnyBlock, AnyLink, DocFileMeta } from './types'\n// import type { Block } from 'multiformats/dist/types/src/block'\n\nimport { exporter, ReadableStorage } from 'ipfs-unixfs-exporter'\n\n// /** @param {import('@ipld/unixfs').View} writer */\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\nconst queuingStrategy = UnixFS.withCapacity()\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\nconst settings = UnixFS.configure({\n  fileChunkEncoder: raw,\n  smallFileEncoder: raw,\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\n  chunker: withMaxChunkSize(1024 * 1024),\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\n  fileLayout: withWidth(1024)\n})\n\nexport async function encodeFile(blob: BlobLike): Promise<{ cid: AnyLink; blocks: AnyBlock[] }> {\n  const readable = createFileEncoderStream(blob)\n  const blocks = await collect(readable)\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n  return { cid: blocks.at(-1).cid, blocks }\n}\n\nexport async function decodeFile(blocks: unknown, cid: AnyLink, meta: DocFileMeta): Promise<File> {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\n  const entry = await exporter(cid.toString(), blocks as ReadableStorage, { length: meta.size })\n  const chunks = []\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n  for await (const chunk of entry.content()) chunks.push(chunk as Buffer)\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return new File(chunks, entry.name, { type: meta.type, lastModified: 0 })\n}\n\nfunction createFileEncoderStream(blob: BlobLike) {\n  /** @type {TransformStream<import('@ipld/unixfs').Block, import('@ipld/unixfs').Block>} */\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n  const { readable, writable } = new TransformStream({}, queuingStrategy)\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n  const unixfsWriter = UnixFS.createWriter({ writable, settings })\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\n  const fileBuilder = new UnixFSFileBuilder('', blob)\n  void (async () => {\n    await fileBuilder.finalize(unixfsWriter)\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n    await unixfsWriter.close()\n  })()\n  return readable\n}\n\nasync function collect<T>(collectable: ReadableStream<T>): Promise<T[]> {\n  // /** @type {T[]} */\n  const chunks: T[] = []\n  await collectable.pipeTo(\n    new WritableStream({\n      write(chunk) {\n        chunks.push(chunk)\n      }\n    })\n  )\n  return chunks\n}\n\nclass UnixFSFileBuilder {\n  #file\n  name: string\n  constructor(name: string, file: BlobLike) {\n    this.name = name\n    this.#file = file\n  }\n\n  async finalize(writer: View) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n    const unixfsFileWriter = UnixFS.createFileWriter(writer)\n    await this.#file.stream().pipeTo(\n      new WritableStream({\n        async write(chunk) {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n          await unixfsFileWriter.write(chunk as Uint8Array)\n        }\n      })\n    )\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n    return await unixfsFileWriter.close()\n  }\n}\n\n// ts-unused-exports:disable-next-line\nexport interface BlobLike {\n  /**\n   * Returns a ReadableStream which yields the Blob data.\n   */\n  stream: () => ReadableStream\n}\n", "import type { CID } from 'multiformats'\nimport { encode, decode, Block } from 'multiformats/block'\nimport { parse } from 'multiformats/link'\nimport { sha256 as hasher } from 'multiformats/hashes/sha2'\nimport * as codec from '@ipld/dag-cbor'\nimport { put, get, entries, EventData, root } from '@alanshaw/pail/crdt'\nimport { EventFetcher, vis } from '@alanshaw/pail/clock'\nimport { LoggingFetcher, Transaction } from './transaction'\nimport type { TransactionBlockstore } from './transaction'\nimport type { DocUpdate, ClockHead, AnyLink, DocValue, BulkResult, ChangesOptions, Doc, DocFileMeta, FileResult, DocFiles, BlockFetcher } from './types'\nimport { decodeFile, encodeFile } from './files'\nimport { DbLoader } from './loaders'\n\nexport async function applyBulkUpdateToCrdt(\n  tblocks: Transaction,\n  head: ClockHead,\n  updates: DocUpdate[],\n  options?: object\n): Promise<BulkResult> {\n  let result\n  for (const update of updates) {\n    const link = await writeDocContent(tblocks, update)\n    result = await put(tblocks, head, update.key, link, options)\n    const resRoot = result.root.toString()\n    const isReturned = result.additions.some(a => a.cid.toString() === resRoot)\n    if (!isReturned) {\n      const hasRoot = await tblocks.get(result.root) // is a db-wide get\n      if (!hasRoot) {\n        throw new Error(`missing root in additions: ${result.additions.length} ${resRoot} keys: ${updates.map(u => u.key).toString()}`)\n\n        // make sure https://github.com/alanshaw/pail/pull/20 is applied\n        result.head = head\n      }\n    }\n    for (const { cid, bytes } of [...result.additions, ...result.removals, result.event]) {\n      tblocks.putSync(cid, bytes)\n    }\n    head = result.head\n  }\n  return { head }\n}\n\n// this whole thing can get pulled outside of the write queue\nasync function writeDocContent(blocks: Transaction, update: DocUpdate): Promise<AnyLink> {\n  let value: DocValue\n  if (update.del) {\n    value = { del: true }\n  } else {\n    await processFiles(blocks, update.value as Doc)\n    value = { doc: update.value }\n  }\n  const block = await encode({ value, hasher, codec })\n  blocks.putSync(block.cid, block.bytes)\n  return block.cid\n}\n\nasync function processFiles(blocks: Transaction, doc: Doc) {\n  if (doc._files) {\n    await processFileset(blocks, doc._files)\n  }\n  if (doc._publicFiles) {\n    await processFileset(blocks, doc._publicFiles, true)\n  }\n}\n\nasync function processFileset(blocks: Transaction, files: DocFiles, publicFiles = false) {\n  const dbBlockstore = blocks.parent as TransactionBlockstore\n  const t = new Transaction(dbBlockstore)\n  // dbBlockstore.transactions.add(t)\n  const didPut = []\n  // let totalSize = 0\n  for (const filename in files) {\n    if (File === files[filename].constructor) {\n      const file = files[filename] as File\n\n      // totalSize += file.size\n      const { cid, blocks: fileBlocks } = await encodeFile(file)\n      didPut.push(filename)\n      for (const block of fileBlocks) {\n        t.putSync(block.cid, block.bytes)\n      }\n      files[filename] = { cid, type: file.type, size: file.size } as DocFileMeta\n    }\n  }\n  // todo option to bypass this limit\n  // if (totalSize > 1024 * 1024 * 1) throw new Error('Sync limit for files in a single update is 1MB')\n  if (didPut.length) {\n    const car = await dbBlockstore.loader?.commit(t, { files } as FileResult, { public: publicFiles })\n    if (car) {\n      for (const name of didPut) {\n        files[name] = { car, ...files[name] } as DocFileMeta\n      }\n    }\n  }\n}\n\nexport async function getValueFromCrdt(blocks: TransactionBlockstore, head: ClockHead, key: string): Promise<DocValue> {\n  if (!head.length) throw new Error('Getting from an empty database')\n  const link = await get(blocks, head, key)\n  if (!link) throw new Error(`Missing key ${key}`)\n  return await getValueFromLink(blocks, link)\n}\n\nexport function readFiles(blocks: TransactionBlockstore | LoggingFetcher, { doc }: DocValue) {\n  if (!doc) return\n  if (doc._files) {\n    readFileset(blocks, doc._files)\n  }\n  if (doc._publicFiles) {\n    readFileset(blocks, doc._publicFiles, true)\n  }\n}\n\nfunction readFileset(blocks: TransactionBlockstore | LoggingFetcher, files: DocFiles, isPublic = false) {\n  for (const filename in files) {\n    const fileMeta = files[filename] as DocFileMeta\n    if (fileMeta.cid) {\n      // if (!blocks.loader) throw new Error('Missing loader')\n      if (isPublic) { fileMeta.url = `https://${fileMeta.cid.toString()}.ipfs.w3s.link/` }\n      if (fileMeta.car && blocks.loader) {\n        const ld = blocks.loader as DbLoader\n        fileMeta.file = async () => await decodeFile({\n          get: async (cid: AnyLink) => {\n            const reader = await ld.loadFileCar(fileMeta.car!, isPublic)\n            const block = await reader.get(cid as CID)\n            if (!block) throw new Error(`Missing block ${cid.toString()}`)\n            return block.bytes\n          }\n        }, fileMeta.cid, fileMeta)\n      }\n    }\n    files[filename] = fileMeta\n  }\n}\n\nasync function getValueFromLink(blocks: TransactionBlockstore | LoggingFetcher, link: AnyLink): Promise<DocValue> {\n  const block = await blocks.get(link)\n  if (!block) throw new Error(`Missing linked block ${link.toString()}`)\n  const { value } = (await decode({ bytes: block.bytes, hasher, codec })) as { value: DocValue }\n  readFiles(blocks, value)\n  return value\n}\n\nclass DirtyEventFetcher<T> extends EventFetcher<T> {\n  // @ts-ignore\n  async get(link) {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      return await super.get(link)\n    } catch (e) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n      console.error('missing event', link.toString(), e)\n      return ({ value: null })\n    }\n  }\n}\n\nexport async function clockChangesSince(\n  blocks: TransactionBlockstore | LoggingFetcher,\n  head: ClockHead,\n  since: ClockHead,\n  opts: ChangesOptions\n): Promise<{ result: DocUpdate[], head: ClockHead }> {\n  const eventsFetcher = (opts.dirty ? new DirtyEventFetcher<EventData>(blocks) : new EventFetcher<EventData>(blocks)) as EventFetcher<EventData>\n  const keys: Set<string> = new Set()\n  const updates = await gatherUpdates(blocks, eventsFetcher, head, since, [], keys, new Set<string>(), opts.limit || Infinity)\n  return { result: updates.reverse(), head }\n}\n\nasync function gatherUpdates(\n  blocks: TransactionBlockstore | LoggingFetcher,\n  eventsFetcher: EventFetcher<EventData>,\n  head: ClockHead,\n  since: ClockHead,\n  updates: DocUpdate[] = [],\n  keys: Set<string>, didLinks: Set<string>,\n  limit: number\n): Promise<DocUpdate[]> {\n  if (limit <= 0) return updates\n  const sHead = head.map(l => l.toString())\n  for (const link of since) {\n    if (sHead.includes(link.toString())) {\n      return updates\n    }\n  }\n  for (const link of head) {\n    if (didLinks.has(link.toString())) continue\n    didLinks.add(link.toString())\n    const { value: event } = await eventsFetcher.get(link)\n    if (!event) continue\n    const { key, value } = event.data\n    if (keys.has(key)) {\n      if (event.parents) {\n        updates = await gatherUpdates(blocks, eventsFetcher, event.parents, since, updates, keys, didLinks, limit)\n      }\n    } else {\n      keys.add(key)\n      const docValue = await getValueFromLink(blocks, value)\n      updates.push({ key, value: docValue.doc, del: docValue.del, clock: link })\n      limit--\n      if (event.parents) {\n        updates = await gatherUpdates(blocks, eventsFetcher, event.parents, since, updates, keys, didLinks, limit)\n      }\n    }\n  }\n  return updates\n}\n\nexport async function * getAllEntries(blocks: TransactionBlockstore | LoggingFetcher, head: ClockHead) {\n  // return entries(blocks, head)\n  for await (const [key, link] of entries(blocks, head)) {\n    const docValue = await getValueFromLink(blocks, link)\n    yield { key, value: docValue.doc, del: docValue.del } as DocUpdate\n  }\n}\n\nexport async function * clockVis(blocks: TransactionBlockstore, head: ClockHead) {\n  for await (const line of vis(blocks, head)) {\n    yield line\n  }\n}\n\nlet isCompacting = false\nexport async function doCompact(blocks: TransactionBlockstore, head: ClockHead) {\n  if (isCompacting) {\n    return\n  }\n  isCompacting = true\n  const blockLog = new LoggingFetcher(blocks)\n\n  for (const cid of head) {\n    const bl = await blockLog.get(cid)\n    if (!bl) throw new Error('Missing head block: ' + cid.toString())\n  }\n\n  // for await (const blk of  blocks.entries()) {\n  //   const bl = await blockLog.get(blk.cid)\n  //   if (!bl) throw new Error('Missing tblock: ' + blk.cid.toString())\n  // }\n\n  // todo maybe remove\n  // for await (const blk of blocks.loader!.entries()) {\n  //   const bl = await blockLog.get(blk.cid)\n  //   if (!bl) throw new Error('Missing db block: ' + blk.cid.toString())\n  // }\n\n  for await (const entry of getAllEntries(blockLog, head)) {\n    // result.push(entry)\n  }\n\n  for await (const [, link] of entries(blockLog, head)) {\n    const bl = await blockLog.get(link)\n    if (!bl) throw new Error('Missing entry block: ' + link.toString())\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for await (const _line of vis(blockLog, head)) {\n    void 1\n  }\n\n  const result = await root(blockLog, head)\n  for (const { cid, bytes } of [...result.additions, ...result.removals]) {\n    blockLog.loggedBlocks.putSync(cid, bytes)\n  }\n\n  await clockChangesSince(blockLog, head, [], {})\n\n  const done = await blocks.commitCompaction(blockLog.loggedBlocks, head)\n  isCompacting = false\n  return done\n}\n\nexport async function getThatBlock({ bytes }: {cid: string, bytes: string }) {\n  const realBytes = Uint8Array.from(atob(bytes), c => c.charCodeAt(0))\n  const { cid, value } = await decode({ bytes: realBytes, codec, hasher })\n  return new Block({ cid, value, bytes: realBytes })\n}\n\nexport async function getBlock(blocks: BlockFetcher, cidString: string) {\n  const block = await blocks.get(parse(cidString))\n  if (!block) throw new Error(`Missing block ${cidString}`)\n  const { cid, value } = await decode({ bytes: block.bytes, codec, hasher })\n  return new Block({ cid, value, bytes: block.bytes })\n}\n", "import type { CarReader } from '@ipld/car'\nimport type {\n  AnyLink,\n  BulkResult,\n  CarCommit,\n  DbCarHeader,\n  FileCarHeader,\n  FileResult,\n  FireproofOptions,\n  IdxCarHeader,\n  IdxMeta,\n  IdxMetaMap\n} from './types'\nimport type { CRDT } from './crdt'\nimport type { CRDTClock } from './crdt-clock'\nimport { Loader, Connection } from './loader'\nimport { index } from './index'\nimport type { DataStore as AbstractDataStore } from './store'\n\nimport { DataStore } from './store-browser'\nimport { doCompact } from './crdt-helpers'\nimport { TransactionBlockstore } from './transaction'\n\nexport class IdxLoader extends Loader {\n  // declare ready: Promise<IdxCarHeader>\n  crdt: CRDT\n\n  static defaultHeader = { cars: [], compact: [], indexes: new Map() as Map<string, IdxMeta> }\n  defaultHeader = IdxLoader.defaultHeader\n\n  constructor(name: string, crdt: CRDT, opts?: FireproofOptions) {\n    super(name, opts)\n    this.crdt = crdt\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async _applyCarHeader(header: IdxCarHeader) {\n    for (const [name, idx] of Object.entries(header.indexes)) {\n      index({ _crdt: this.crdt }, name, undefined, idx as IdxMeta)\n    }\n  }\n\n  protected makeCarHeader(\n    { indexes }: IndexerResult,\n    cars: AnyLink[],\n    compact: boolean = false\n  ): IdxCarHeader {\n    return compact ? { indexes, cars: [], compact: cars } : { indexes, cars, compact: [] }\n  }\n}\nexport type IndexerResult = CarCommit & IdxMetaMap\n\nexport class DbLoader extends Loader {\n  // declare ready: Promise<DbCarHeader> // todo this will be a map of headers by branch name\n  static defaultHeader = { cars: [], compact: [], head: [] }\n  defaultHeader = DbLoader.defaultHeader\n\n  clock: CRDTClock\n  awaitingCompact = false\n  compacting: Promise<AnyLink | void> = Promise.resolve()\n  writing: Promise<BulkResult | void> = Promise.resolve()\n\n  remoteFileStore: AbstractDataStore | undefined\n  fileStore: DataStore\n\n  constructor(name: string, clock: CRDTClock, opts?: FireproofOptions) {\n    super(name, opts)\n    this.fileStore = new DataStore(this.name)\n    this.clock = clock\n  }\n\n  async _readyForMerge() {\n    // await this.ready\n    await this.compacting\n  }\n\n  async _setWaitForWrite(_writingFn: () => Promise<any>) {\n    const wr = this.writing\n    this.writing = wr.then(async () => {\n      await _writingFn()\n      return wr\n    })\n    return this.writing.then(() => {})\n  }\n\n  async compact(blocks: TransactionBlockstore) {\n    await this.ready\n    if (this.carLog.length < 2) return\n    if (this.awaitingCompact) return\n    this.awaitingCompact = true\n    const compactingFn = async () => {\n      // await this.writing\n      if (this.isCompacting) {\n        return\n      }\n\n      if (this.isWriting) {\n        return\n      }\n\n      this.isCompacting = true\n      const compactHead = this.clock.head\n      const compactingResult = await doCompact(blocks, this.clock.head)\n      await this.clock.applyHead(compactHead, compactHead, null)\n      return compactingResult\n    }\n    this.compacting = this._setWaitForWrite(compactingFn)\n    this.compacting.finally(() => {\n      this.isCompacting = false\n      this.awaitingCompact = false\n    })\n    await this.compacting\n  }\n\n  async loadFileCar(cid: AnyLink, isPublic = false): Promise<CarReader> {\n    return await this.storesLoadCar(cid, this.fileStore, this.remoteFileStore, isPublic)\n  }\n\n  protected async _applyCarHeader(carHeader: DbCarHeader, snap = false) {\n    if (snap) {\n      await this.clock.applyHead(carHeader.head, this.clock.head)\n    } else {\n      await this.clock.applyHead(carHeader.head, [])\n    }\n  }\n\n  protected makeCarHeader(\n    result: BulkResult | FileResult,\n    cars: AnyLink[],\n    compact: boolean = false\n  ): DbCarHeader | FileCarHeader {\n    if (isFileResult(result)) {\n      const files = [] as AnyLink[]\n\n      for (const [, meta] of Object.entries(result.files)) {\n        files.push(meta.cid)\n      }\n      return { files } as FileCarHeader\n    } else {\n      const { head } = result\n      return compact ? { head, cars: [], compact: cars } : { head, cars, compact: [] }\n    }\n  }\n}\n\nexport function isFileResult(\n  result: IndexerResult | BulkResult | FileResult\n): result is FileResult {\n  return result && (result as FileResult).files !== undefined\n}\n", "import { MemoryBlockstore } from '@alanshaw/pail/block'\nimport {\n  BlockFetcher, AnyBlock, AnyLink, BulkResult, ClockHead,\n  IdxMeta, CarCommit, CarMakeable, FireproofOptions\n} from './types'\nimport { DbLoader, IdxLoader } from './loaders'\n// import { CID } from 'multiformats'\nimport { CRDT } from './crdt'\nimport { CRDTClock } from './crdt-clock'\n\nexport class Transaction extends MemoryBlockstore implements CarMakeable {\n  parent: FireproofBlockstore\n  constructor(parent: FireproofBlockstore) {\n    super()\n    parent.transactions.add(this)\n    this.parent = parent\n  }\n\n  async get(cid: AnyLink): Promise<AnyBlock | undefined> {\n    return this.parent.get(cid)\n  }\n\n  async superGet(cid: AnyLink): Promise<AnyBlock | undefined> {\n    return super.get(cid)\n  }\n}\n\nabstract class FireproofBlockstore implements BlockFetcher {\n  ready: Promise<void>\n  name: string | null = null\n\n  loader: DbLoader | IdxLoader | null = null\n  opts: FireproofOptions = {}\n\n  transactions: Set<Transaction> = new Set()\n\n  constructor(name: string | null, loader?: DbLoader | IdxLoader, opts?: FireproofOptions) {\n    this.opts = opts || this.opts\n    if (name) {\n      this.name = name\n      if (!loader) throw new Error('missing loader')\n      this.loader = loader\n      this.ready = this.loader.ready\n    } else {\n      this.ready = Promise.resolve() // Promise.reject(new Error('implement default header in subclass'))\n    }\n  }\n\n  abstract transaction(\n    fn: (t: Transaction) => Promise<IdxMeta | BulkResult>,\n    indexes?: Map<string, IdxMeta>,\n    opts?: { noLoader: boolean }\n  ): Promise<BulkResultCar | IdxMetaCar>\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async put() {\n    throw new Error('use a transaction to put')\n  }\n\n  async get(cid: AnyLink): Promise<AnyBlock | undefined> {\n    if (!cid) throw new Error('required cid')\n    for (const f of this.transactions) {\n      const v = await f.superGet(cid)\n      if (v) return v\n    }\n    if (!this.loader) return\n    return await this.loader.getBlock(cid)\n  }\n\n  async commitCompaction(t: Transaction, head: ClockHead) {\n    const did = await this.loader!.commit(t, { head }, { compact: true, noLoader: true })\n    // this.transactions.clear()\n    // this.transactions.add(t)\n    return did\n  }\n\n  async *entries(): AsyncIterableIterator<AnyBlock> {\n    const seen: Set<string> = new Set()\n    for (const t of this.transactions) {\n      for await (const blk of t.entries()) {\n        if (seen.has(blk.cid.toString())) continue\n        seen.add(blk.cid.toString())\n        yield blk\n      }\n    }\n  }\n\n  protected async executeTransaction<T, R>(\n    fn: (t: Transaction) => Promise<T>,\n    commitHandler: (t: Transaction, done: T) => Promise<{ car?: AnyLink; done: R }>\n  ): Promise<R> {\n    const t = new Transaction(this)\n    const done: T = await fn(t)\n    const { car, done: result } = await commitHandler(t, done)\n    return car ? { ...result, car } : result\n  }\n}\n\nexport class IndexBlockstore extends FireproofBlockstore {\n  // declare ready: Promise<IdxCarHeader>\n\n  constructor(name: string | null, crdt: CRDT, opts?: FireproofOptions) {\n    if (name) {\n      super(name, new IdxLoader(name, crdt, opts), opts)\n    } else {\n      super(null)\n      // this.ready = Promise.resolve(IdxLoader.defaultHeader as IdxCarHeader)\n    }\n  }\n\n  async transaction(fn: (t: Transaction) => Promise<IdxMeta>, indexes: Map<string, IdxMeta>): Promise<IdxMetaCar> {\n    return this.executeTransaction(fn, async (t, done) => {\n      indexes.set(done.name, done)\n      const car = await this.loader?.commit(t, { indexes })\n      return { car, done }\n    })\n  }\n}\n\nexport class TransactionBlockstore extends FireproofBlockstore {\n  // declare ready: Promise<DbCarHeader>\n\n  constructor(name: string | null, clock: CRDTClock, opts?: FireproofOptions) {\n    // todo this will be a map of headers by branch name\n    if (name) {\n      super(name, new DbLoader(name, clock, opts), opts)\n    } else {\n      super(null)\n      // this.ready = Promise.resolve(DbLoader.defaultHeader as DbCarHeader)\n    }\n  }\n\n  async transaction(\n    fn: (t: Transaction) => Promise<BulkResult>,\n    _indexes?: undefined,\n    opts = { noLoader: false }\n  ): Promise<BulkResultCar> {\n    return this.executeTransaction(fn, async (t, done) => {\n      // if the fn will change noLoader, it will show up on done\n      const car = await this.loader?.commit(t, done, opts)\n      return { car, done }\n    })\n  }\n}\n\ntype IdxMetaCar = IdxMeta & CarCommit\ntype BulkResultCar = BulkResult & CarCommit\n\nexport class LoggingFetcher implements BlockFetcher {\n  blocks: TransactionBlockstore\n  loader: DbLoader | IdxLoader | null = null\n  loggedBlocks : Transaction\n  \n\n  constructor(blocks: TransactionBlockstore) {\n    this.blocks = blocks\n    this.loader = blocks.loader\n    this.loggedBlocks = new Transaction(blocks)\n  }\n\n  async get(cid: AnyLink) {\n    const block = await this.blocks.get(cid)\n    if (block) this.loggedBlocks.putSync(cid, block.bytes)\n    return block\n  }\n}\n", "import { ClockHead, DocUpdate } from './types'\n\ntype ApplyHeadWorkerFunction = (newHead: ClockHead, prevHead: ClockHead) => Promise<void>\n\ntype ApplyHeadTask = {\n  newHead: ClockHead\n  prevHead: ClockHead\n  updates: DocUpdate[] | null\n}\n\nexport type ApplyHeadQueue = {\n  push(task: ApplyHeadTask): AsyncGenerator<{ updates: DocUpdate[]; all: boolean }, void, unknown>\n}\n\nexport function applyHeadQueue(worker: ApplyHeadWorkerFunction): ApplyHeadQueue {\n  const queue: ApplyHeadTask[] = []\n  let isProcessing = false\n\n  async function* process() {\n    if (isProcessing || queue.length === 0) return\n    isProcessing = true\n    const allUpdates: DocUpdate[] = []\n    try {\n      while (queue.length > 0) {\n        queue.sort((a, b) => (b.updates ? 1 : -1))\n        const task = queue.shift()\n        if (!task) continue\n\n        await worker(task.newHead, task.prevHead)\n\n        if (task.updates) {\n          allUpdates.push(...task.updates)\n        }\n        // Yield the updates if there are no tasks with updates left in the queue or the current task has updates\n        if (!queue.some(t => t.updates) || task.updates) {\n          const allTasksHaveUpdates = queue.every(task => task.updates !== null)\n          yield { updates: allUpdates, all: allTasksHaveUpdates }\n          allUpdates.length = 0\n        }\n      }\n    } finally {\n      isProcessing = false\n      const generator = process()\n      let result = await generator.next()\n      while (!result.done) {\n        result = await generator.next()\n      }\n    }\n  }\n\n  return {\n    push(\n      task: ApplyHeadTask\n    ): AsyncGenerator<{ updates: DocUpdate[]; all: boolean }, void, unknown> {\n      queue.push(task)\n      return process()\n    }\n  }\n}\n", "import { clockChangesSince } from './crdt-helpers'\nimport { TransactionBlockstore } from './transaction'\nimport type { DocUpdate, ClockHead, BlockFetcher } from './types'\nimport { advance } from '@alanshaw/pail/clock'\nimport { root } from '@alanshaw/pail/crdt'\nimport { applyHeadQueue, ApplyHeadQueue } from './apply-head-queue'\n\nexport class CRDTClock {\n  // todo: track local and remote clocks independently, merge on read\n  // that way we can drop the whole remote if we need to\n  // should go with making sure the local clock only references locally available blocks on write\n  head: ClockHead = []\n\n  zoomers: Set<() => void> = new Set()\n  watchers: Set<(updates: DocUpdate[]) => void> = new Set()\n  emptyWatchers: Set<() => void> = new Set()\n\n  blocks: TransactionBlockstore | null = null\n\n  applyHeadQueue: ApplyHeadQueue\n\n  constructor() {\n    this.applyHeadQueue = applyHeadQueue(this.int_applyHead.bind(this))\n  }\n\n  setHead(head: ClockHead) {\n    this.head = head\n  }\n\n  async applyHead(newHead: ClockHead, prevHead: ClockHead, updates: DocUpdate[] | null = null) {\n    for await (const { updates: updatesAcc, all } of this.applyHeadQueue.push({\n      newHead,\n      prevHead,\n      updates\n    })) {\n      this.processUpdates(updatesAcc, all, prevHead)\n    }\n  }\n\n  async processUpdates(updatesAcc: DocUpdate[], all: boolean, prevHead: ClockHead) {\n    let internalUpdates = updatesAcc\n    if (this.watchers.size && !all) {\n      const changes = await clockChangesSince(this.blocks!, this.head, prevHead, {})\n      internalUpdates = changes.result\n    }\n    this.zoomers.forEach(fn => fn())\n    this.notifyWatchers(internalUpdates || [])\n  }\n\n  notifyWatchers(updates: DocUpdate[]) {\n    this.emptyWatchers.forEach(fn => fn())\n    this.watchers.forEach(fn => fn(updates || []))\n  }\n\n  onTick(fn: (updates: DocUpdate[]) => void) {\n    this.watchers.add(fn)\n  }\n\n  onTock(fn: () => void) {\n    this.emptyWatchers.add(fn)\n  }\n\n  onZoom(fn: () => void) {\n    this.zoomers.add(fn)\n  }\n\n  async int_applyHead(newHead: ClockHead, prevHead: ClockHead) {\n    const ogHead = sortClockHead(this.head)\n    newHead = sortClockHead(newHead)\n    await validateBlocks(newHead, this.blocks)\n    if (compareClockHeads(ogHead, newHead)) {\n      return\n    }\n    const ogPrev = sortClockHead(prevHead)\n    if (compareClockHeads(ogHead, ogPrev)) {\n      this.setHead(newHead)\n      return\n    }\n    let head = this.head\n    const noLoader = false\n    // const noLoader = this.head.length === 1 && !updates?.length\n    if (!this.blocks) throw new Error('missing blocks')\n    await this.blocks.transaction(\n      async tblocks => {\n        head = await advanceBlocks(newHead, tblocks, head)\n        const result = await root(tblocks, head)\n        for (const { cid, bytes } of [...result.additions, ...result.removals]) {\n          tblocks.putSync(cid, bytes)\n        }\n        return { head }\n      },\n      undefined,\n      { noLoader }\n    )\n    this.setHead(head)\n  }\n}\n\n// Helper functions\nfunction sortClockHead(clockHead: ClockHead) {\n  return clockHead.sort((a, b) => a.toString().localeCompare(b.toString()))\n}\n\nasync function validateBlocks(newHead: ClockHead, blocks: TransactionBlockstore | null) {\n  newHead.map(async cid => {\n    const got = await blocks!.get(cid)\n    if (!got) {\n      throw new Error('int_applyHead missing block: ' + cid.toString())\n    }\n  })\n}\n\nfunction compareClockHeads(head1: ClockHead, head2: ClockHead) {\n  return head1.toString() === head2.toString()\n}\n\nasync function advanceBlocks(newHead: ClockHead, tblocks: BlockFetcher, head: ClockHead) {\n  for (const cid of newHead) {\n    try {\n      head = await advance(tblocks, head, cid)\n    } catch (e) {\n      console.error('failed to advance', cid.toString(), e)\n      continue\n    }\n  }\n  return head\n}\n", "import { TransactionBlockstore, IndexBlockstore } from './transaction'\nimport { clockChangesSince, applyBulkUpdateToCrdt, getValueFromCrdt, readFiles, getAllEntries, clockVis, getBlock, getThatBlock } from './crdt-helpers'\nimport type { DocUpdate, BulkResult, ClockHead, FireproofOptions, ChangesOptions } from './types'\nimport type { Index } from './index'\nimport { CRDTClock } from './crdt-clock'\nimport { DbLoader } from './loaders'\n\nexport class CRDT {\n  name: string | null\n  opts: FireproofOptions = {}\n  ready: Promise<void>\n  blocks: TransactionBlockstore\n  indexBlocks: IndexBlockstore\n\n  indexers: Map<string, Index> = new Map()\n\n  clock: CRDTClock = new CRDTClock()\n  // isCompacting = false\n  // compacting : Promise<AnyLink|void> = Promise.resolve()\n  // writing: Promise<BulkResult|void> = Promise.resolve()\n\n  constructor(name?: string, opts?: FireproofOptions) {\n    this.name = name || null\n    this.opts = opts || this.opts\n    this.blocks = new TransactionBlockstore(this.name, this.clock, this.opts)\n    this.clock.blocks = this.blocks\n    this.indexBlocks = new IndexBlockstore(\n      this.opts.persistIndexes && this.name ? this.name + '.idx' : null,\n      this,\n      this.opts\n    )\n    this.ready = Promise.all([this.blocks.ready, this.indexBlocks.ready]).then(() => {})\n    this.clock.onZoom(() => {\n      for (const idx of this.indexers.values()) {\n        idx._resetIndex()\n      }\n    })\n    this.clock.onTock(async () => {\n      if (this.blocks.loader && this.blocks.loader.carLog.length < 100) return\n      await this.compact()\n    })\n  }\n\n  async bulk(updates: DocUpdate[], options?: object): Promise<BulkResult> {\n    await this.ready\n    const loader = this.blocks.loader as DbLoader\n\n    const prevHead = [...this.clock.head]\n\n    const writing = (async () => {\n      await loader?.compacting\n      if (loader?.isCompacting) {\n        throw new Error('cant bulk while compacting')\n      }\n      const got = await this.blocks.transaction(async (tblocks): Promise<BulkResult> => {\n        const { head } = await applyBulkUpdateToCrdt(tblocks, this.clock.head, updates, options)\n        updates = updates.map(({ key, value, del, clock }) => {\n          readFiles(this.blocks, { doc: value })\n          return { key, value, del, clock }\n        })\n        if (loader?.awaitingCompact) {\n          console.log('missing?', head.toString())\n        }\n        if (loader?.isCompacting) {\n          console.log('compacting?', head.toString())\n        }\n        return { head }\n      })\n      await this.clock.applyHead(got.head, prevHead, updates)\n      return got\n    })()\n    if (loader) {\n      const wr = loader.writing\n      loader.writing = wr.then(async () => {\n        loader.isWriting = true\n        await writing\n        loader.isWriting = false\n        return wr\n      })\n    }\n    return (await writing)!\n  }\n\n  async allDocs() {\n    await this.ready\n    const result: DocUpdate[] = []\n    for await (const entry of getAllEntries(this.blocks, this.clock.head)) {\n      result.push(entry)\n    }\n    return { result, head: this.clock.head }\n  }\n\n  async vis() {\n    await this.ready\n    const txt = []\n    for await (const line of clockVis(this.blocks, this.clock.head)) {\n      txt.push(line)\n    }\n    return txt.join('\\n')\n  }\n\n  async getBlock(cidString: string) {\n    await this.ready\n    return await getBlock(this.blocks, cidString)\n  }\n\n  async getThatBlock() {\n    const blockJson = { cid: 'bafyreib7ee4pscqpuioxobmh3ac5xbbslypmaqqbkugalhw67hnco6dvoa', bytes: 'omRkYXRhpGNrZXl4JDAxOGFmNzdiLWZmMTUtNzI5Ny04ODZiLTYwMjViM2MxODI2ZWRyb2902CpYJQABcRIgKVLI53HO1TFDbPUoSaybd0mop2oX/CRFm1RrpiY4ne9kdHlwZWNwdXRldmFsdWXYKlglAAFxEiAGw53MVtPzeeGT/itfdLBfCVu6MTj96AHU6v9a3K/wYGdwYXJlbnRzgdgqWCUAAXESIJiL5qjdpgghUfbQLpKJeCgMX+ubhoTpYBoZHYdzbQJ/' }\n    return await getThatBlock(blockJson)\n  }\n\n  async get(key: string) {\n    await this.ready\n    const result = await getValueFromCrdt(this.blocks, this.clock.head, key)\n    if (result.del) return null\n    return result\n  }\n\n  async changes(since: ClockHead = [], opts: ChangesOptions = {}) {\n    await this.ready\n    return await clockChangesSince(this.blocks, this.clock.head, since, opts)\n  }\n\n  async compact() {\n    await this.ready\n    if (this.blocks.loader) {\n      await (this.blocks.loader as DbLoader).compact(this.blocks)\n    }\n  }\n}\n", "import { uuidv7 } from 'uuidv7'\n\nimport { WriteQueue, writeQueue } from './write-queue'\nimport { CRDT } from './crdt'\nimport { index } from './index'\nimport type { BulkResult, DocUpdate, ClockHead, Doc, FireproofOptions, MapFn, QueryOpts, ChangesOptions } from './types'\nimport { DbResponse, ChangesResponse } from './types'\n\ntype DbName = string | null\n\nexport class Database {\n  static databases: Map<string, Database> = new Map()\n\n  name: DbName\n  opts: FireproofOptions = {}\n\n  _listening = false\n  _listeners: Set<ListenerFn> = new Set()\n  _noupdate_listeners: Set<ListenerFn> = new Set()\n  _crdt: CRDT\n  _writeQueue: WriteQueue\n\n  constructor(name?: string, opts?: FireproofOptions) {\n    this.name = name || null\n    this.opts = opts || this.opts\n    this._crdt = new CRDT(name, this.opts)\n    this._writeQueue = writeQueue(async (updates: DocUpdate[]) => {\n      return await this._crdt.bulk(updates)\n    })//, Infinity)\n    this._crdt.clock.onTock(() => {\n      this._no_update_notify()\n    })\n  }\n\n  async get(id: string): Promise<Doc> {\n    const got = await this._crdt.get(id).catch(e => {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      e.message = `Not found: ${id} - ` + e.message\n      throw e\n    })\n    if (!got) throw new Error(`Not found: ${id}`)\n    const { doc } = got\n    return { _id: id, ...doc } as Doc\n  }\n\n  async put(doc: Doc): Promise<DbResponse> {\n    const { _id, ...value } = doc\n    const docId = _id || uuidv7()\n    const result: BulkResult = await this._writeQueue.push({ key: docId, value } as DocUpdate)\n    return { id: docId, clock: result?.head } as DbResponse\n  }\n\n  async del(id: string): Promise<DbResponse> {\n    const result = await this._writeQueue.push({ key: id, del: true })\n    return { id, clock: result?.head } as DbResponse\n  }\n\n  async changes(since: ClockHead = [], opts: ChangesOptions = {}): Promise<ChangesResponse> {\n    const { result, head } = await this._crdt.changes(since, opts)\n    const rows = result.map(({ key, value, del, clock }) => ({\n      key, value: (del ? { _id: key, _deleted: true } : { _id: key, ...value }) as Doc, clock\n    }))\n    return { rows, clock: head }\n  }\n\n  async allDocs() {\n    const { result, head } = await this._crdt.allDocs()\n    const rows = result.map(({ key, value, del }) => ({\n      key, value: (del ? { _id: key, _deleted: true } : { _id: key, ...value }) as Doc\n    }))\n    return { rows, clock: head }\n  }\n\n  async allDocuments() {\n    return this.allDocs()\n  }\n\n  subscribe(listener: ListenerFn|NoUpdateListenerFn, updates?: boolean): () => void {\n    if (updates) {\n      if (!this._listening) {\n        this._listening = true\n        this._crdt.clock.onTick((updates: DocUpdate[]) => {\n          void this._notify(updates)\n        })\n      }\n      this._listeners.add(listener)\n      return () => {\n        this._listeners.delete(listener)\n      }\n    } else {\n      this._noupdate_listeners.add(listener)\n      return () => {\n        this._noupdate_listeners.delete(listener)\n      }\n    }\n  }\n\n  // todo if we add this onto dbs in fireproof.ts then we can make index.ts a separate package\n  async query(field: string | MapFn, opts: QueryOpts = {}) {\n    const idx = (typeof field === 'string')\n      ? index({ _crdt: this._crdt }, field)\n      : index({ _crdt: this._crdt }, makeName(field.toString()), field)\n    return await idx.query(opts)\n  }\n\n  async compact() {\n    await this._crdt.compact()\n  }\n\n  // move this stuff to connect\n  async getDashboardURL(compact = true) {\n    const baseUrl = 'https://dashboard.fireproof.storage/'\n    if (!this._crdt.blocks.loader?.remoteCarStore) return new URL('/howto', baseUrl)\n    if (compact) {\n      await this.compact()\n    }\n    const currents = await this._crdt.blocks.loader?.metaStore?.load()\n    if (!currents) throw new Error('Can\\'t sync empty database: save data first')\n    if (currents.length > 1) throw new Error('Can\\'t sync database with split heads: make an update first')\n    const current = currents[0]\n    const params = {\n      car: current.car.toString()\n    }\n    // @ts-ignore\n    if (current.key) { params.key = current.key.toString() }\n    // @ts-ignore\n    if (this.name) { params.name = this.name }\n    const url = new URL('/import#' + new URLSearchParams(params).toString(), baseUrl)\n    console.log('Import to dashboard: ' + url.toString())\n    return url\n  }\n\n  openDashboard() {\n    void this.getDashboardURL().then(url => {\n      if (url) window.open(url.toString(), '_blank')\n    })\n  }\n\n  async _notify(updates: DocUpdate[]) {\n    if (this._listeners.size) {\n      const docs: Doc[] = updates.map(({ key, value }) => ({ _id: key, ...value }))\n      for (const listener of this._listeners) {\n        await (async () => await listener(docs))().catch((e: Error) => {\n          console.error('subscriber error', e)\n        })\n      }\n    }\n  }\n\n  async _no_update_notify() {\n    if (this._noupdate_listeners.size) {\n      for (const listener of this._noupdate_listeners) {\n        await (async () => await listener([]))().catch((e: Error) => {\n          console.error('subscriber error', e)\n        })\n      }\n    }\n  }\n}\n\ntype UpdateListenerFn = (docs: Doc[]) => Promise<void> | void\ntype NoUpdateListenerFn = () => Promise<void> | void\ntype ListenerFn = UpdateListenerFn | NoUpdateListenerFn\n\nexport function fireproof(name: string, opts?: FireproofOptions): Database {\n  if (!Database.databases.has(name)) {\n    Database.databases.set(name, new Database(name, opts))\n  }\n  return Database.databases.get(name)!\n}\n\nfunction makeName(fnString: string) {\n  const regex = /\\(([^,()]+,\\s*[^,()]+|\\[[^\\]]+\\],\\s*[^,()]+)\\)/g\n  let found: RegExpExecArray | null = null\n  const matches = Array.from(fnString.matchAll(regex), match => match[1].trim())\n  if (matches.length === 0) {\n    found = /=>\\s*(.*)/.exec(fnString)\n  }\n  if (!found) {\n    return fnString\n  } else {\n    // it's a consise arrow function, match everythign after the arrow\n    return found[1]\n  }\n}\n"],
  "mappings": "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AAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAC7C;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAAA,IAAG;AAA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",
  "names": ["exports", "module", "encode", "MSB", "REST", "MSBALL", "INT", "offset", "exports", "module", "read", "MSB", "REST", "buf", "offset", "exports", "module", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "exports", "module", "exports", "exports", "match", "encode", "decode", "open", "close", "exports", "exports", "module", "offset", "index", "resolve", "params", "exports", "base64", "length", "string", "encode", "buffer", "i", "decode", "offset", "exports", "module", "EventEmitter", "exports", "module", "buf", "exports", "utf8", "string", "buffer", "offset", "exports", "module", "alloc", "slice", "size", "offset", "buf", "exports", "module", "util", "from", "mask", "length", "exports", "util", "Buffer", "merge", "src", "keys", "name", "message", "get", "i", "size", "exports", "module", "util", "base64", "utf8", "writer", "create", "alloc", "size", "push", "buf", "writeBytes", "fork", "exports", "module", "util", "buf", "exports", "module", "util", "utf8", "reader", "buffer", "create_array", "create", "buf", "length", "exports", "module", "util", "buffer", "exports", "module", "util", "self", "err", "exports", "exports", "module", "exports", "configure", "require_minimal", "exports", "module", "exports", "module", "root", "undefined", "exports", "module", "exports", "module", "assign", "code", "exports", "module", "index", "last", "exists", "mask", "exports", "module", "has", "context", "EventEmitter", "name", "length", "update", "index", "resolve", "offset", "buf", "decode", "offset", "code", "code", "digest", "size", "decode", "equals", "name", "encode", "length", "size", "i", "j", "decode", "string", "buffer", "name", "encode", "decode", "alphabet", "string", "buffer", "mask", "link", "base", "baseCache", "code", "digest", "self", "equals", "base", "decode", "offset", "length", "size", "cache", "cid", "base", "link", "current", "resolve", "enqueue", "decode", "encode", "name", "type", "isBuffer", "buf", "toString", "fromString", "string", "length", "size", "isBuffer", "string", "length", "buf", "offset", "offset", "buf", "set", "encodedSize", "buf", "encodedSize", "compareTokens", "length", "buf", "fromString", "encodedSize", "compareTokens", "toToken", "length", "toString", "toToken", "length", "buf", "encodedSize", "toToken", "length", "buf", "encodedSize", "buf", "encodedSize", "buf", "encodedSize", "ui8a", "offset", "entries", "keys", "length", "buf", "size", "encode", "decode", "encode_1", "encode", "MSB", "REST", "MSBALL", "INT", "offset", "decode", "read", "MSB$1", "REST$1", "buf", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "length", "varint", "_brrp_varint", "varint_default", "decode", "offset", "code", "varint_default", "encodeTo", "encodingLength", "bytes_exports", "coerce", "empty", "equals", "fromString", "toString", "create", "code", "digest", "size", "encodingLength", "encodeTo", "Digest", "decode", "coerce", "equals", "base", "name", "encode", "length", "size", "i", "j", "decode", "string", "buffer", "src", "_brrp__multiformats_scope_baseX", "base_x_default", "Encoder", "name", "Decoder", "or", "ComposedDecoder", "Codec", "from", "encode", "decode", "baseX", "alphabet", "base_x_default", "coerce", "string", "buffer", "mask", "rfc4648", "base58btc", "baseX", "base58flickr", "base32", "rfc4648", "base32upper", "base32pad", "base32padupper", "base32hex", "base32hexupper", "base32hexpad", "base32hexpadupper", "base32z", "format", "link", "base", "toStringV0", "baseCache", "base58btc", "toStringV1", "base32", "cache", "baseCache", "CID", "code", "DAG_PB_CODE", "SHA_256_CODE", "digest", "create", "self", "equals", "base", "format", "encodeCID", "cidSymbol", "decode", "coerce", "Digest", "offset", "length", "size", "parseCIDtoBytes", "base58btc", "base32", "toStringV0", "cid", "toStringV1", "encodingLength", "encodeTo", "CID", "encode", "decode", "keys", "name", "import_varint", "varint", "offset", "length", "reader", "length", "decode", "bytes", "multihash", "blockLength", "offset", "index", "read", "index", "reader", "reader", "fromBytes", "reader", "import_varint", "import_varint", "typeofs", "objectTypeNames", "is", "isBuffer", "getObjectType", "Type", "name", "Token", "type", "useBuffer", "textDecoder", "textEncoder", "isBuffer", "buf", "asU8A", "toString", "utf8Slice", "fromString", "string", "utf8ToBytes", "fromArray", "slice", "concat", "length", "alloc", "size", "compare", "isBuffer", "utf8ToBytes", "string", "length", "utf8Slice", "buf", "offset", "decodeCodePointsArray", "MAX_ARGUMENTS_LENGTH", "defaultChunkSize", "Bl", "alloc", "slice", "concat", "decodeErrPrefix", "encodeErrPrefix", "uintMinorPrefixBytes", "assertEnoughData", "uintBoundaries", "readUint8", "offset", "assertEnoughData", "decodeErrPrefix", "readUint16", "readUint32", "readUint64", "decodeUint8", "Token", "Type", "decodeUint16", "decodeUint32", "decodeUint64", "encodeUint", "buf", "encodeUintValue", "set", "encodedSize", "compareTokens", "decodeNegint8", "Token", "Type", "readUint8", "decodeNegint16", "readUint16", "decodeNegint32", "readUint32", "neg1b", "pos1b", "decodeNegint64", "readUint64", "decodeErrPrefix", "encodeNegint", "buf", "encodeUintValue", "encodedSize", "uintBoundaries", "compareTokens", "toToken", "length", "assertEnoughData", "buf", "slice", "Token", "Type", "decodeBytesCompact", "decodeBytes8", "readUint8", "decodeBytes16", "readUint16", "decodeBytes32", "readUint32", "decodeBytes64", "readUint64", "decodeErrPrefix", "tokenBytes", "fromString", "encodeBytes", "encodeUintValue", "encodedSize", "compareTokens", "compareBytes", "compare", "toToken", "length", "assertEnoughData", "Token", "Type", "toString", "slice", "decodeStringCompact", "decodeString8", "readUint8", "decodeString16", "readUint16", "decodeString32", "readUint32", "decodeString64", "readUint64", "decodeErrPrefix", "encodeString", "encodeBytes", "toToken", "length", "Token", "Type", "decodeArrayCompact", "decodeArray8", "readUint8", "decodeArray16", "readUint16", "decodeArray32", "readUint32", "decodeArray64", "readUint64", "decodeErrPrefix", "decodeArrayIndefinite", "encodeArray", "buf", "encodeUintValue", "encodeUint", "encodedSize", "toToken", "length", "Token", "Type", "decodeMapCompact", "decodeMap8", "readUint8", "decodeMap16", "readUint16", "decodeMap32", "readUint32", "decodeMap64", "readUint64", "decodeErrPrefix", "decodeMapIndefinite", "encodeMap", "buf", "encodeUintValue", "encodeUint", "encodedSize", "decodeTagCompact", "Token", "Type", "decodeTag8", "readUint8", "decodeTag16", "readUint16", "decodeTag32", "readUint32", "decodeTag64", "readUint64", "encodeTag", "buf", "encodeUintValue", "encodeUint", "encodedSize", "MINOR_FALSE", "MINOR_TRUE", "MINOR_NULL", "MINOR_UNDEFINED", "decodeUndefined", "decodeErrPrefix", "Token", "Type", "decodeBreak", "createToken", "decodeFloat16", "readFloat16", "decodeFloat32", "readFloat32", "decodeFloat64", "readFloat64", "encodeFloat", "buf", "encodeFloat16", "ui8a", "encodeFloat32", "encodeFloat64", "encodedSize", "buffer", "dataView", "offset", "encodeUint", "invalidMinor", "decodeErrPrefix", "errorer", "jump", "decodeUint8", "decodeUint16", "decodeUint32", "decodeUint64", "decodeNegint8", "decodeNegint16", "decodeNegint32", "decodeNegint64", "decodeBytesCompact", "decodeBytes8", "decodeBytes16", "decodeBytes32", "decodeBytes64", "decodeStringCompact", "decodeString8", "decodeString16", "decodeString32", "decodeString64", "decodeArrayCompact", "decodeArray8", "decodeArray16", "decodeArray32", "decodeArray64", "decodeArrayIndefinite", "decodeMapCompact", "decodeMap8", "decodeMap16", "decodeMap32", "decodeMap64", "decodeMapIndefinite", "decodeTagCompact", "decodeTag8", "decodeTag16", "decodeTag32", "decodeTag64", "decodeUndefined", "decodeFloat16", "decodeFloat32", "decodeFloat64", "decodeBreak", "quick", "Token", "Type", "quickEncodeToken", "fromArray", "makeCborEncoders", "Type", "encodeUint", "encodeNegint", "encodeBytes", "encodeString", "encodeArray", "encodeMap", "encodeTag", "encodeFloat", "cborEncoders", "buf", "Bl", "Ref", "encodeErrPrefix", "simpleTokens", "Token", "typeEncoders", "entries", "objectToTokens", "keys", "length", "sortMapEntries", "is", "DONE", "BREAK", "cborEncoders", "makeCborEncoders", "defaultEncodeOptions", "quickEncodeToken", "cborEncoders", "defaultEncodeOptions", "root", "writer", "size", "varint", "encode", "offset", "Token", "Type", "length", "buffer", "writer", "root", "from", "name", "code", "encode", "create", "digest", "index", "CID", "base", "encode", "decode", "create", "bytes_exports", "name", "from", "code", "decode", "encode", "name", "name", "code", "encode", "coerce", "decode", "size", "buffer", "writer", "encode", "reader", "decode", "code", "decode", "encode", "name", "size", "buffer", "offset", "concat", "encode", "decode", "code", "CID", "name", "readUInt32LE", "buffer", "offset", "identity", "entries", "compare", "keys", "last", "del", "chunker", "Node", "root", "newBranchEntries", "cache", "result", "entry", "cids", "results", "LeafClass", "BranchClass", "entries2", "final", "opts", "block", "encode", "create", "compare", "buffer", "readUInt32LE", "get", "cache", "chunker", "entries", "create", "encrypt", "get", "cache", "chunker", "root", "set", "block", "encode", "CID", "last", "create", "decrypt", "decode", "tree", "unwrap", "length", "last", "encrypt", "reader", "root", "get", "decrypt", "buf", "is", "fromString", "mapSorter", "defaultEncodeOptions", "encode", "decode", "rfc4648", "cidEncoder", "CID", "undefinedEncoder", "numberEncoder", "encodeOptions", "decodeOptions", "encode", "encodeOptions", "decode", "decodeOptions", "format", "parse", "decode", "resolve", "name", "target", "name", "format", "parse", "resolve", "DataStore", "RemoteWAL", "parse", "format", "MetaStore", "remove", "name", "MetaStore", "DataStore", "RemoteWAL", "CID", "reader", "cid", "root", "crypto", "readUInt32LE", "keys", "entries", "createGetNode", "get", "cache", "chunker", "compare", "LeafClass", "BranchClass", "create", "load", "value", "compare", "entries", "key", "classes", "create", "load", "refCompare", "compare", "del", "charwise", "create", "load", "root", "name", "result", "all", "parse", "base", "CID", "from", "name", "code", "encode", "Hasher", "digest", "readonly", "linksWithin", "index", "links", "base", "treeWithin", "tree", "get", "Block", "encode", "decode", "sha256", "sha512", "sha", "name", "sha256", "from", "sha512", "Block", "link", "encode", "sha256", "decode", "links", "Block", "encode", "sha256", "decode", "link", "root", "child", "value", "key", "entry", "get", "put", "result", "data", "event", "root", "root", "get", "entries", "code", "decode", "encode", "encodeLink", "name", "textDecoder", "decodeVarint", "offset", "index", "link", "links", "textEncoder", "link", "size", "index", "offset", "base", "textEncoder", "link", "code", "encode", "link", "decode", "$protobuf", "Data", "encode", "decode", "toJSON", "values", "UnixTime", "Metadata", "code", "name", "links", "encode", "entries", "encodeLink", "encode", "root", "decode", "message", "type", "links", "links", "length", "link", "size", "root", "name", "message", "message", "name", "effect", "effects", "tag", "tag", "group", "self", "group", "fork", "from", "index", "BLANK", "error", "init", "message", "none", "empty", "slice", "buffer", "empty", "offset", "get", "EMPTY_BUFFER", "EMPTY", "config", "empty", "EMPTY", "close", "buffer", "chunker", "offset", "size", "EMPTY", "has", "link", "links", "BLANK", "EMPTY", "keys", "has", "link", "EMPTY", "BLANK", "message", "write", "close", "writer", "config", "chunker", "link", "root", "fork", "EMPTY_BUFFER", "links", "buffer", "name", "name", "Node", "open", "write", "close", "defaults", "EMPTY", "layout", "root", "index", "length", "defaults", "sha256", "config", "code", "name", "create", "writer", "settings", "defaults", "write", "close", "effect", "message", "defaults", "create", "writer", "settings", "name", "link", "close", "entries", "links", "digest", "code", "fork", "empty", "from", "fromBytes", "get", "or", "set", "empty", "size", "from", "set", "bitField", "index", "get", "or", "fromBytes", "murmur", "configure", "bitWidth", "mask", "at", "from", "config", "create", "fork", "entries", "name", "index", "offset", "create", "config", "get", "offset", "index", "set", "remove", "config", "offset", "index", "fork", "entries", "import_murmurhash3js_revisited", "from", "mur", "bytes_exports", "utf8", "configure", "bitWidth", "at", "offset", "from", "mask", "and", "empty", "from", "fromBytes", "get", "or", "popcount", "set", "size", "toBytes", "unset", "empty", "size", "from", "index", "set", "unset", "get", "toBytes", "fromBytes", "popcount", "offset", "byte", "or", "and", "configure", "bitWidth", "get", "config", "configure", "create", "root", "set", "remove", "utf8", "hash64", "configure", "bitWidth", "at", "read", "from", "digest", "bitCount", "offset", "configure", "builder", "builder", "root", "get", "createWriter", "settings", "defaults", "close", "writer", "create", "import_err_code", "res", "import_err_code", "code", "name", "encode", "coerce", "create", "name", "resolve", "decode", "CID", "errCode", "import_err_code", "type", "blockLength", "import_err_code", "size", "offset", "length", "errCode", "buf", "resolve", "name", "errCode", "decode", "import_err_code", "rawContent", "buf", "resolve", "name", "errCode", "import_err_code", "import_err_code", "import_reader", "import_minimal", "import_writer", "configure", "util", "ReaderClass", "ReaderBufferClass", "WriterClass", "WriterBufferClass", "buf", "buf", "message", "CODEC_TYPES", "name", "type", "encode", "decode", "encode", "writer", "decode", "reader", "encode", "decode", "Data", "DataType", "__DataTypeValues", "UnixTime", "reader", "length", "tag", "buf", "Metadata", "DEFAULT_FILE_MODE", "DEFAULT_DIRECTORY_MODE", "type", "errcode", "message", "Data", "size", "index", "identity", "identity", "buf", "base2", "base2", "base64", "base64pad", "base64url", "base64urlpad", "base64", "base64pad", "base64url", "base64urlpad", "encode", "decode", "identity_exports", "identity", "code", "name", "encode", "digest", "identity", "textEncoder", "textDecoder", "identity_exports", "asUint8Array", "buf", "size", "asUint8Array", "createCodec", "name", "encode", "decode", "buf", "string", "fromString", "string", "base", "asUint8Array", "SparseArray", "map", "acc", "index", "fromString", "length", "mask", "concat", "length", "offset", "asUint8Array", "hashFn", "concat", "buffer", "buf", "links", "link", "name", "context", "decode", "src_default", "isAsyncIterable", "peekable", "src_default", "isAsyncIterable", "peekable", "src_default", "resolve", "last", "message", "code", "buffer", "buffer", "pushable", "resolve", "push", "options", "_pushable", "isAsyncIterable", "src_default", "isAsyncIterable", "source", "src_default", "resolve", "offset", "length", "links", "src_default", "link", "import_err_code", "message", "AbortError", "resolve", "step", "index", "__classPrivateFieldGet", "AbortError", "EventEmitter", "resolve", "_PQueue_doesIntervalAllowAnother_get", "_PQueue_doesConcurrentAllowAnother_get", "_PQueue_next", "_PQueue_onResumeInterval", "_PQueue_isIntervalPaused_get", "_PQueue_tryToStartAnother", "_PQueue_initializeIntervalIfNeeded", "_PQueue_onInterval", "_PQueue_processQueue", "_PQueue_throwOnAbort", "_PQueue_onEvent", "filter", "buf", "errCode", "src_default", "link", "code", "decode", "resolve", "read", "resolve", "links", "src_default", "link", "name", "decode", "entries", "name", "link", "resolve", "decode", "errCode", "code", "resolve", "name", "errCode", "CID", "errCode", "name", "encodeFile", "collect", "createWriter", "name", "writer", "create", "update", "link", "put", "encode", "encodeFile", "name", "get", "reader", "decode", "keys", "entries", "parse", "name", "DataStore", "name", "task", "name", "del", "name", "del", "updates", "current", "match"]
}
